/* -*- mode: c++ -*- */
/**
 * @file   Board.h
 * @author Sebastien Fourey <http://www.greyc.ensicaen.fr/~seb>
 * @date   Sat Aug 18 2007
 * 
 * @brief Definition of inline methods of the Board class.  
 */
/*
 * \@copyright This File is part of the Board library which is
 * licensed under the terms of the GNU Lesser General Public Licence.
 * See the LICENCE file for further details.
 */

namespace LibBoard {

inline
void
Board::clear( unsigned char red, unsigned char green, unsigned char blue )
{
  clear( DGtal::Color( red, green, blue ) );
}

inline
Board &
Board::setLineStyle( Shape::LineStyle style )
{
  _state.lineStyle = style;
  return *this;
}

inline
Board &
Board::setLineCap( Shape::LineCap cap )
{
  _state.lineCap = cap;
  return *this;
}
  
inline
Board &
Board::setLineJoin( Shape::LineJoin join )
{
  _state.lineJoin = join;
  return *this;
}

inline
void
Board::fillGouraudTriangle( const double x1, const double y1,
          const DGtal::Color & color1,
          const double x2, const double y2, 
          const DGtal::Color & color2,
          const double x3, const double y3,
          const DGtal::Color & color3,
          unsigned char divisions,
          int depthValue /* = -1 */ )
{
  fillGouraudTriangle( Point( x1, y1 ), color1,
           Point( x2, y2 ), color2,
           Point( x3, y3 ), color3,
           divisions, depthValue );           
}

inline
void
Board::fillGouraudTriangle( const double x1, const double y1,
          const float brightness1,
          const double x2, const double y2, 
          const float brightness2,
          const double x3, const double y3,
          const float brightness3,
          unsigned char divisions,
          int depthValue /* = -1 */ )
{
  fillGouraudTriangle( Point( x1, y1 ), brightness1,
           Point( x2, y2 ), brightness2,
           Point( x3, y3 ), brightness3,
           divisions, depthValue );
}


#ifdef WITH_CAIRO
inline
void
Board::saveCairo( const char * filename, CairoType type, PageSize asize, double margin ) const
{
  saveCairo( filename, type, pageSizes[asize][0], pageSizes[asize][1], margin );
}
inline
void
Board::saveCairo( const char * filename, CairoType type, double pageWidth, double pageHeight, double margin ) const
{
  cairo_surface_t *surface;
  cairo_t *cr;
  
  double cairoWidth, cairoHeight;
  
  TransformCairo transform;
  Rect box = boundingBox();

  bool clipping = _clippingPath.size() > 2;
  if ( clipping )
    box = box && _clippingPath.boundingBox();
  transform.setBoundingBox( box, pageWidth, pageHeight, margin );
  
  if ( pageWidth > 0 && pageHeight > 0 )
  {
    cairoWidth = pageWidth;
    cairoHeight = pageHeight;
  }
  else
  {
    cairoWidth = box.width;
    cairoHeight = box.height;
  }
  
  switch (type)
  {
  case CairoPDF:
      surface = cairo_pdf_surface_create (filename, cairoWidth, cairoHeight); break;
  case CairoPS:
      surface = cairo_ps_surface_create (filename, cairoWidth, cairoHeight); break;
  case CairoEPS:
    surface = cairo_ps_surface_create (filename, cairoWidth, cairoHeight); 
    cairo_ps_surface_set_eps(surface, true); break;
  case CairoSVG:
      surface = cairo_svg_surface_create (filename, cairoWidth, cairoHeight); break;
    case CairoPNG:
    default:
      surface = cairo_image_surface_create (CAIRO_FORMAT_ARGB32, (int)cairoWidth, (int)cairoHeight);
  }
  
  cr = cairo_create (surface);
  
  /* For 1.0 x 1.0 coordinate space */
  //cairo_scale (cr, cairoWidth, cairoHeight);
  
  //temp: http://zetcode.com/tutorials/cairographicstutorial/basicdrawing/
  //temp: http://www.graphviz.org/pub/scm/graphviz-cairo/plugin/cairo/gvrender_cairo.c
      
  // Draw the background color if needed.
  if ( _backgroundColor != DGtal::Color::None ) { 
    Rectangle r( box, DGtal::Color::None, _backgroundColor, 0.0 );
    r.flushCairo( cr, transform );
  }
  
  // Draw the shapes.
  std::vector< Shape* > shapes = _shapes;
  stable_sort( shapes.begin(), shapes.end(), shapeGreaterDepth );
  std::vector< Shape* >::const_iterator i = shapes.begin();
  std::vector< Shape* >::const_iterator end = shapes.end();
  while ( i != end ) {
    (*i)->flushCairo( cr, transform );
    ++i;
  }
  
  if (type==CairoPNG)
    cairo_surface_write_to_png (surface, filename);
      
  cairo_destroy (cr);
  cairo_surface_destroy (surface);
}
#endif


} // namespace LibBoard
