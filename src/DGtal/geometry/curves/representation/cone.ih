/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file cone.ih
 * @author Isabelle Sivignon (\c isabelle.sivignon@gipsa-lab.grenoble-inp.fr )
 * gipsa-lab Grenoble Images Parole Signal Automatique (CNRS, UMR 5216), CNRS, France
 *
 * @date 2012/02/24
 *
 * Implementation of inline methods defined in cone.h
 *
 * This file is part of the DGtal library.
 */

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////



//creation of a cone

cone::cone()
{
  myInf = true;
  myMin = 0;
  myMax = 0;
}

cone::cone(double m, double mm, bool a)
{
  myMin = m;
  myMax = mm;
  myB = a;
  myInf = false;
}

cone::cone(double angle0, double angle1)
{
  myB = 0;
  
  // angle0 and angle1 are ordered in direct orientation such that the angle between made by the two directions is lower than PI.

  
  // case angle0-angle1 = PI -> infinite cone
  if(fabs(fabs(angle0-angle1)-M_PI) < 0.00001)
    {
      // the orientation is supposed to be ok (depends on the points involved)
      // std::cerr << "init by angles" << std::endl;
      myMin = angle0;
      myMax = angle1;
    }
  else
    if(fabs(angle0-angle1)<M_PI)
      {
	if(angle0-angle1>0)
	  {
	    myMin = angle1;
	    myMax = angle0;
	  }
	else
	  {
	    myMin = angle0;
	    myMax = angle1;
	  }
      }
    else
      {
	// the cone includes the direction of angle=0
	myB = 1;
	if(angle0>angle1)
	  {
	    myMin = angle0;
	    myMax = angle1; 
	  }
	else
	  {
	    myMin = angle1;
	    myMax = angle0; 
	  }
      }
  myInf = false;
}

cone::cone(double x, double y, double x0, double y0, double x1, double y1)
{
  //std::cerr << x << " " << y << " " << x0 << " " << y0 << " " << x1 << " " << y1 << std::endl;
  double angle0 = Tools::computeAngle(x, y, x0, y0);
  double angle1 = Tools::computeAngle(x, y, x1, y1);
  //std::cerr << angle0 << " " << angle1 << std::endl;
  *this = cone(angle0,angle1);
  myInf = false;
}

bool cone::isEmpty()
{
  if(myInf)
    return false;
  else
    if(myMin==myMax)
      return true;
    else
      return false;
}


cone& cone::operator=(const cone& c)
{
  myMin =c.myMin;
  myMax=c.myMax;
  myB = c.myB;
  myInf = c.myInf;
  return *this;
}

// // Computes the symmetrical cone
cone cone::symmetricalCone()
{
  cone cnew(myMin+M_PI,myMax+M_PI);
  return cnew;
}

// Computes the intersection between the self cone and another one.
void cone::intersectCones(cone c)
{
  cone res;
  
  // computes the intersection between the self cone and one half of another cone
  res = intersectConesSimple(c);
  
  // if they are disjoint, try the intersection with the other half
  if(res.isEmpty())
    {
      //std::cout << "symmetrical" << std::endl;
      cone sym = c.symmetricalCone();
      res = intersectConesSimple(sym);
    }
  
  *this = res;
}


//intersection of the self cone with another cone: considers only one half of the cone
cone cone::intersectConesSimple(cone c)
{
  cone res;
  
  // if the cone is infinite, the new cone is c
  if(myInf)
    {
      res = c;
      res.myInf = false;
    }
  else    
    // the directions of the new cone are not included in the old one
    if(!Tools::isBetween(c.myMin, myMin, myMax, 2*M_PI) && !Tools::isBetween(c.myMax, myMin,
							 myMax,
							 2*M_PI)) 
      {
	// first possibility: the cones are disjoint
	if(!Tools::isBetween(myMin, c.myMin, c.myMax, 2*M_PI) && !Tools::isBetween(myMax, c.myMin,
							       c.myMax, 2*M_PI))
	  res = cone(0,0);
	else
	  // or the new cone includes the old one, nothing changes, the cone remains the same.
	  res = *this;
      }
    else
      // the old cone is "cut" by the new one
      if(Tools::isBetween(c.myMin, myMin, myMax, 2*M_PI))
	if(Tools::isBetween(c.myMax, myMin, myMax, 2*M_PI))
	  res = c;
	else
	  res = cone(c.myMin, myMax);
      else
	res = cone(myMin,c.myMax);
  
  return res;
}


void cone::selfDisplay ( std::ostream & out)
{
  out << "[Cone]" <<  endl;
  if(myInf)
    out << "Infinite" << endl;
  else
    out << "[Cone min = " << myMin << " max = " << myMax << "]" << endl;
  out << "[End Cone]" <<  endl; 
}
