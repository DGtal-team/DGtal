/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file Naive3DDSSComputer.ih
 * @author Kacper Pluta (\c kacper.pluta@esiee.fr )
 * Laboratoire d'Informatique Gaspard-Monge - LIGM, A3SI, France
 *
 * @date 2014/10/07
 *
 * Implementation of inline methods defined in Naive3DDSSComputer.h
 *
 * This file is part of the DGtal library.
 */

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
#include <boost/math/common_factor_rt.hpp>
#include "DGtal/io/Color.h"
//////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////
// Implementation of inline methods                                          //
/**
 * Default constructor.
 * not valid
 */
template <typename TIterator, typename TInteger, int connectivity>
inline
DGtal::Naive3DDSSComputer<TIterator,TInteger,connectivity>::Naive3DDSSComputer()
{
  //projections
  std::vector<DGtal::Dimension> v1,v2,v3;
  v1.push_back(0);
  v1.push_back(1);
  v2.push_back(0);
  v2.push_back(2);
  v3.push_back(1);
  v3.push_back(2);
  myProjXY.init(v1.begin(),v1.end());
  myProjXZ.init(v2.begin(),v2.end());
  myProjYZ.init(v3.begin(),v3.end());
  blockXY = blockXZ = blockYZ = false;
  lenXY = lenXZ = lenYZ = 0;
}

/**
 * Constructor with initialisation
 */
template <typename TIterator, typename TInteger, int connectivity>
inline
DGtal::Naive3DDSSComputer<TIterator,TInteger,connectivity>::Naive3DDSSComputer(const ConstIterator& it)
{
  //projections
  std::vector<DGtal::Dimension> v1,v2,v3;
  v1.push_back(0);
  v1.push_back(1);
  v2.push_back(0);
  v2.push_back(2);
  v3.push_back(1);
  v3.push_back(2);
  myProjXY.init(v1.begin(),v1.end());
  myProjXZ.init(v2.begin(),v2.end());
  myProjYZ.init(v3.begin(),v3.end());

  init(it);
}

/**
 * Initialisation.
 * @param it an iterator on a sequence of points
 */
template <typename TIterator, typename TInteger, int connectivity>
inline
void DGtal::Naive3DDSSComputer<TIterator,TInteger,connectivity>::init ( const ConstIterator& it )
{
  //begin and end iterators
  myBegin = it;
  myEnd = it;
  myEnd++;
  //adapters and projections
  IteratorAdapter XYit(it,myProjXY);
  myXYalgo.init(XYit);
  IteratorAdapter XZit(it,myProjXZ);
  myXZalgo.init(XZit);
  IteratorAdapter YZit(it,myProjYZ);
  myYZalgo.init(YZit);
  blockXY = blockXZ = blockYZ = false;
  lenXY = lenXZ = lenYZ = 0;
}

/**
 * Copy constructor.
 * @param other the object to clone.
 * Forbidden by default.
 */
template <typename TIterator, typename TInteger, int connectivity>
inline
DGtal::Naive3DDSSComputer<TIterator,TInteger,connectivity>::Naive3DDSSComputer (
                                          const Naive3DDSSComputer<TIterator,TInteger,connectivity> & other ) :
  myProjXY(other.myProjXY), myProjXZ(other.myProjXZ), myProjYZ(other.myProjYZ),
  myXYalgo(other.myXYalgo), myXZalgo(other.myXZalgo), myYZalgo(other.myYZalgo),
  myBegin(other.myBegin), myEnd(other.myEnd)
{
    blockXY = other.blockXY;
    blockXZ = other.blockXZ;
    blockYZ = other.blockYZ;
    lenXY = other.lenXY;
    lenXZ = other.lenXZ;
    lenYZ = other.lenYZ;
}

/**
 * Assignment.
 * @param other the object to copy.
 * @return a reference on 'this'.
 * Forbidden by default.
 */
template <typename TIterator, typename TInteger, int connectivity>
inline
DGtal::Naive3DDSSComputer<TIterator,TInteger,connectivity> &
DGtal::Naive3DDSSComputer<TIterator,TInteger,connectivity>::operator= (
                                      const Naive3DDSSComputer<TIterator,TInteger,connectivity> & other )
{
  myProjXY = other.myProjXY;
  myProjXZ = other.myProjXZ;
  myProjYZ = other.myProjYZ;
  myXYalgo = other.myXYalgo;
  myXZalgo = other.myXZalgo;
  myYZalgo = other.myYZalgo;
  myBegin = other.myBegin;
  myEnd = other.myEnd;
  blockXY = other.blockXY;
  blockXZ = other.blockXZ;
  blockYZ = other.blockYZ;
  lenXY = other.lenXY;
  lenXZ = other.lenXZ;
  lenYZ = other.lenYZ;
  return *this;
}

template <typename TIterator, typename TInteger, int connectivity>
inline
typename DGtal::Naive3DDSSComputer<TIterator,TInteger,connectivity>::Self
DGtal::Naive3DDSSComputer<TIterator,TInteger,connectivity>::getSelf() const {
  return Self();
}

template <typename TIterator, typename TInteger, int connectivity>
inline
typename DGtal::Naive3DDSSComputer<TIterator,TInteger,connectivity>::Reverse
DGtal::Naive3DDSSComputer<TIterator,TInteger,connectivity>::getReverse() const {
  return Reverse();
}

template <typename TIterator, typename TInteger, int connectivity>
inline
bool
DGtal::Naive3DDSSComputer<TIterator,TInteger,connectivity>::isInDSS ( const Point3d & point) const {
  short test = 0;
  if ( myXYalgo.isInDSS ( myProjXY ( point ) ) )
      test++;
  if ( myXZalgo.isInDSS ( myProjXZ ( point ) ) )
      test++;
  if ( myYZalgo.isInDSS ( myProjYZ ( point ) ) )
      test++;

  return test >= 2 ? true : false;
}

template <typename TIterator, typename TInteger, int connectivity>
inline
bool
DGtal::Naive3DDSSComputer<TIterator,TInteger,connectivity>::isInDSS ( const ConstIterator & it) const {
  short test = 0;
  if ( myXYalgo.isInDSS ( myProjXY ( *it ) ) )
     test++;
  if ( myXZalgo.isInDSS ( myProjXZ ( *it ) ) )
      test++;
  if ( myYZalgo.isInDSS ( myProjYZ ( *it ) ) )
      test++;

  return test >= 2 ? true : false;
}

/**
 * Equality operator.
 * @param other the object to compare with.
 * @return 'true' either if the points perfectly match
 * or if the first points match to the last ones
 * (same DSS scanned in the conversed way)
 * and 'false' otherwise
 */
template <typename TIterator, typename TInteger, int connectivity>
inline
bool
DGtal::Naive3DDSSComputer<TIterator,TInteger,connectivity>::operator==(
                                      const Naive3DDSSComputer<TIterator,TInteger,connectivity>& other ) const
{
  return (  (	myXYalgo == other.myXYalgo ) &&
            (	myXZalgo == other.myXZalgo ) &&
            (	myYZalgo == other.myYZalgo ) &&
            (*myBegin == *other.myBegin) &&
            (*myEnd == *other.myEnd) );
}

/**
 * Difference operator.
 * @param other the object to compare with.
 * @return 'false' if equal
 * 'true' otherwise
 */
template <typename TIterator, typename TInteger, int connectivity>
inline
bool
DGtal::Naive3DDSSComputer<TIterator,TInteger,connectivity>::operator!=(
                                      const Naive3DDSSComputer<TIterator,TInteger,connectivity> & other ) const
{
  return (!(*this == other));
}

/**
 * Tests whether the union between a point
 * (add to the front of the DSS
 * with respect to the scan orientation)
 * and a DSS is a DSS.
 * Computes the parameters of the new DSS
 * with the added point if true.
 * @param it an iterator on a sequence of points
 * @return 'true' if the union is a DSS, 'false' otherwise.
 */
template <typename TIterator, typename TInteger, int connectivity>
inline
bool
DGtal::Naive3DDSSComputer<TIterator,TInteger,connectivity>::extendFront()
{
    if ( !isExtendableFront() ) return false;

    short test = 0;
    if ( myXYalgo.isExtendableFront() && !blockXY )
    {
        Point2d txy = myXYalgo.front();
        myXYalgo.extendFront();
        if ( myXYalgo.front() != txy )
        {
            test++;
            lenXY++;
        }
        else
	{
	    myXYalgo.retractFront();
            blockXY = true;
	}
    }
    if ( myXZalgo.isExtendableFront() && !blockXZ )
    {
        Point2d txz = myXZalgo.front();
        myXZalgo.extendFront();
        if ( myXZalgo.front() != txz )
        {
            test++;
            lenXZ++;
        }
        else
	{
	    myXZalgo.retractFront();
            blockXZ = true;
	}
    }
    if ( myYZalgo.isExtendableFront() && !blockYZ )
    {
        Point2d tyz = myYZalgo.front();
        myYZalgo.extendFront();
        if ( myYZalgo.front() != tyz )
        {
            test++;
            lenYZ++;
        }
        else
	{
	    myYZalgo.retractFront();
            blockYZ = true;
	}
    }
    if ( test >= 2 )
    {
        myEnd++;
        return true;
    }
    else return false;
}

/** Tests whether the 3D DSS can be extended at the front.
 *
 * @return 'true' if yes, 'false' otherwise
 */
template <typename TIterator, typename TInteger, int connectivity>
inline
bool
DGtal::Naive3DDSSComputer<TIterator, TInteger,connectivity>::isExtendableFront()
{
    //projection on xy-plane
    short test = 0;
    if ( myXYalgo.isExtendableFront() && !blockXY )
        test++;
    //projection on xz-plane
    if ( myXZalgo.isExtendableFront() && !blockXZ )
        test++;
    //projection on yz-plane
    if ( myYZalgo.isExtendableFront() && !blockYZ )
        test++;
    if ( test >= 2 )
        return true;
    else return false;
}

template <typename TIterator, typename TInteger, int connectivity>
inline
TIterator
DGtal::Naive3DDSSComputer<TIterator,TInteger,connectivity>::begin() const {
  return myBegin;
}

template <typename TIterator, typename TInteger, int connectivity>
inline
TIterator
DGtal::Naive3DDSSComputer<TIterator,TInteger,connectivity>::end() const {
  return myEnd;
}

//-----------------------------------------------------------------
/**
 * Checks the validity/consistency of the object.
 * @return 'true' if the object is valid, 'false' otherwise.
 */

template <typename TIterator, typename TInteger, int connectivity>
inline
bool
DGtal::Naive3DDSSComputer<TIterator,TInteger,connectivity>::isValid() const
{
  return ( ( myXYalgo.isValid() ) &&
           ( myXZalgo.isValid() ) &&
           ( myYZalgo.isValid() ) );
}

/**
 * Computes the parameters
 * (direction, intercept, thickness)
 * of the DSS
 * @param direction
 * @param intercept
 * @param thickness
 */
template <typename TIterator, typename TInteger, int connectivity>
inline
void
DGtal::Naive3DDSSComputer<TIterator,TInteger,connectivity>
::getParameters ( Point3d& direction, PointD3d& intercept, PointD3d& thickness ) const
{
    if ( lenXY > lenYZ && lenXZ > lenYZ ) { //XY-plane, XZ-plane

        Integer a1 = myXYalgo.b();
        Integer b1 = myXYalgo.a();
        Integer a2 = myXZalgo.b();
        Integer c1 = myXZalgo.a();

        if ( c1 == 0 || ( a1 == 0 && a2 == 0 ) )
            direction = Point3d ( a1, b1, c1 );
        else
        {
            if ( b1 == 0  )
                direction = Point3d ( a2, b1, c1 );
            else
            {
                direction = Point3d ( a1 * a2 , a2 * b1 , a1 * c1 );
            }
        }

        Integer mu1 = myXYalgo.mu();
        Integer mu2 = myXZalgo.mu();
        double y = (double) -NumberTraits<TInteger>::castToInt64_t(mu1) / a1;
        double z = (double) -NumberTraits<TInteger>::castToInt64_t(mu2) / a2;
        intercept = PointD3d(0,y,z);

        Integer omega1 = myXYalgo.omega()-1;
        Integer omega2 = myXZalgo.omega()-1;
        double ty = (double) -NumberTraits<TInteger>::castToInt64_t(omega1) / a1;
        double tz = (double) -NumberTraits<TInteger>::castToInt64_t(omega2) / a2;
        thickness = PointD3d(0,ty,tz);

    } else {

        if ( lenYZ > lenXZ && lenXY > lenXZ ) { //XY-plane, YZ-plane

            Integer a1 = myXYalgo.b();
            Integer b1 = myXYalgo.a();
            Integer b2 = myYZalgo.b();
            Integer c2 = myYZalgo.a();

            if ( a1 == 0 || ( b2 == 0 && b1 == 0 ) )
                direction = Point3d ( a1, b2, c2 );
            else
            {
                if ( c2 == 0 )
                    direction = Point3d ( a1, b1, c2 );
                else
                {
                    direction = Point3d ( b2 * a1 , b1 * b2 , b1 * c2 );
                }
            }

            Integer mu1 = myXYalgo.mu();
            Integer mu2 = myYZalgo.mu();
            double x = (double) NumberTraits<TInteger>::castToInt64_t(mu1) / b1;
            double z = (double) -NumberTraits<TInteger>::castToInt64_t(mu2) / b2;
            intercept = PointD3d(x,0,z);

            Integer omega1 = myXYalgo.omega()-1;
            Integer omega2 = myYZalgo.omega()-1;
            double tx = (double) NumberTraits<TInteger>::castToInt64_t(omega1) / b1;
            double tz = (double) -NumberTraits<TInteger>::castToInt64_t(omega2) / b2;
            thickness = PointD3d(tx,0,tz);

        } else { //YZ-plane, XZ-plane

            std::cerr << "YZ-XZ" << std::endl;

            Integer b2 = myYZalgo.b();
            Integer c2 = myYZalgo.a();
            Integer a2 = myXZalgo.b();
            Integer c1 = myXZalgo.a();

            if ( a2 == 0 || ( c2 == 0 && c1 == 0 ) )
                direction = Point3d ( a2, b2, c2 );
            else
            {
                if ( b2 == 0 )
                    direction = Point3d ( a2, b2, c1 );
                else
                {
                    direction = Point3d ( c2 * a2, c1 * b2, c1 * c2 );
                }
            }

            Integer mu1 = myYZalgo.mu();
            Integer mu2 = myXZalgo.mu();
            double y = (double) NumberTraits<TInteger>::castToInt64_t(mu1) / c2;
            double x = (double) NumberTraits<TInteger>::castToInt64_t(mu2) / c1;
            intercept = PointD3d(x,y,0);

            Integer omega1 = myYZalgo.omega()-1;
            Integer omega2 = myXZalgo.omega()-1;
            double ty = (double) NumberTraits<TInteger>::castToInt64_t(omega1) / c2;
            double tx = (double) NumberTraits<TInteger>::castToInt64_t(omega2) / c1;
            thickness = PointD3d(tx,ty,0);
        }
    }
}

template <typename TIterator, typename TInteger, int connectivity>
inline
void
DGtal::Naive3DDSSComputer<TIterator,TInteger,connectivity>
::get2DSegmentsLength ( unsigned int & pLenXY, unsigned int & pLenXZ, unsigned int & pLenYZ ) const
{
  pLenXY = lenXY;
  pLenXZ = lenXZ;
  pLenYZ = lenYZ;
}

//-----------------------------------------------------------------------------
template <typename TIterator, typename TInteger, int connectivity>
inline
const typename DGtal::Naive3DDSSComputer<TIterator,TInteger,connectivity>::ArithmeticalDSSComputer2d &
DGtal::Naive3DDSSComputer<TIterator,TInteger,connectivity>::arithmeticalDSS2dXY() const
{
  return myXYalgo;
}
//-----------------------------------------------------------------------------
template <typename TIterator, typename TInteger, int connectivity>
inline
const typename DGtal::Naive3DDSSComputer<TIterator,TInteger,connectivity>::ArithmeticalDSSComputer2d &
DGtal::Naive3DDSSComputer<TIterator,TInteger,connectivity>::arithmeticalDSS2dXZ() const
{
  return myXZalgo;
}
//-----------------------------------------------------------------------------
template <typename TIterator, typename TInteger, int connectivity>
inline
const typename DGtal::Naive3DDSSComputer<TIterator,TInteger,connectivity>::ArithmeticalDSSComputer2d &
DGtal::Naive3DDSSComputer<TIterator,TInteger,connectivity>::arithmeticalDSS2dYZ() const
{
  return myYZalgo;
}
//-----------------------------------------------------------------------------
template <typename TIterator, typename TInteger, int connectivity>
inline
const typename DGtal::Naive3DDSSComputer<TIterator,TInteger,connectivity>::ArithmeticalDSSComputer2d &
DGtal::Naive3DDSSComputer<TIterator,TInteger,connectivity>::arithmeticalDSS2d( Dimension i ) const
{
  ASSERT( ( 0 <= i ) && ( i < 3 ) );
  switch ( i ) {
  case 0: return myYZalgo; break;
  case 1: return myXZalgo; break;
  default: return myXYalgo; break;
  }
}

template <typename TIterator, typename TInteger, int connectivity>
inline
bool
DGtal::Naive3DDSSComputer<TIterator,TInteger,connectivity>::validArithmeticalDSS2d( Dimension i ) const
{
  ASSERT( ( 0 <= i ) && ( i < 3 ) );
  if ( i == 0 && ( lenYZ >= lenXZ || lenYZ >= lenXY ) )
    return true; 
  else if ( i == 1 && ( lenXZ >= lenXY || lenXZ >= lenYZ ) )
    return true; 
  else if ( i == 2 && ( lenXY >= lenXZ || lenXY >= lenYZ ) )
  return true;
  return false;
}

/**
 * @return the style name used for drawing this object.
 */
template <typename TIterator, typename TInteger, int connectivity>
inline
std::string
DGtal::Naive3DDSSComputer<TIterator,TInteger,connectivity>::className() const
{
  return "Naive3DDSSComputer";
}


///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions and external operators                 //

//------------------------------------------------------------------------------
//   TEXT DISPLAY

/**
 * Writes/Displays the object on an output stream.
 * @param out the output stream where the object is written.
 */
template <typename TIterator, typename TInteger, int connectivity>
inline
void
DGtal::Naive3DDSSComputer<TIterator,TInteger,connectivity>::selfDisplay ( std::ostream & out)
{

  out << "[Naive3DDSSComputer]" <<  std::endl;
  out << "[XYprojection]" <<  std::endl;
  out << myXYalgo <<  std::endl;
  out << "[XZprojection]" <<  std::endl;
  out << myXZalgo <<  std::endl;
  out << "[YZprojection]" <<  std::endl;
  out << myYZalgo <<  std::endl;
  out << "[End Naive3DDSSComputer]" <<  std::endl;

}


//                                                                           //
///////////////////////////////////////////////////////////////////////////////


