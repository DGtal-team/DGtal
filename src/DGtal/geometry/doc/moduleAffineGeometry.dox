
/* 
 * Useful to avoid writing DGtal:: in front of every class.
 */
namespace DGtal {

/**
   
@page moduleAffineGeometry Affine geometry of points and vectors

@writers Jacques-Olivier Lachaud

@since 2.0

Part of the \ref packageGeometry.

This part of the manual describes how to perform some elementary
affine geometry computations: affine dimension of a set of points,
subset of maximum affine dimension, completion of a partial basis,
computation of an orthogonal vector. This module is notably used in
QuickHull algorithm.

[TOC]

The following programs are related to this documentation:
testAffineGeometry.cpp exampleAffineGeometry.cpp


See \subpage moduleQuickHull

@section dgtal_affgeom_sec1 Generic functions for affine geometry

A set of generic functions is provided in header
`DGtal/geometry/tools/AffineGeometry.h` for several affine geometry
computations. They can be conveniently used since they deduce
automatically the type of parameters.  All these functions support
number types for points and vectors that are either integers (int32_t,
int64_t, BigInteger) or floating-point numbers (float, double). The
computations are \b exact when types are integral (up to integer
overflow), while a tolerance can be provided for floating-point
numbers (default tolerance: between -1e-12 and 1e-12 is zero).

- functions::computeAffineDimension Given a range of points \a X,
  returns the affine dimension of its spanned affine subspace.

- functions::computeAffineSubset Given a range of points \a X, returns
  a subset of these points that form an affine basis of \a
  X. Equivalently it is a simplex whose affine space spans all the
  points of \a X.

- functions::computeAffineBasis( const std::vector< TPoint >& X, const
  double tolerance ) Given a range of points \a X, returns a
  point and a range of vectors forming an affine basis containing \a
  X.

- functions::computeAffineBasis( const std::vector< TPoint >& X, const
  TIndexRange& I ) Given a range of points \a X and the indices \a I
  of points in \a X which form an affine subset of \a X, returns a
  point and a range of vectors forming an affine basis containing \a
  X.

- functions::computeIndependentVector Given a partial basis of
  vectors, returns a new vector that is independent.

- functions::computeCompleteBasis Complete the vectors \a basis with
  independent vectors so as to form a basis of the space. The last
  added vector is guaranteed to be \b orthogonal to all the previous
  vectors.

- functions::computeOrthogonalVector Given `d-1` independent vectors
  in dD, returns a vector that is orthogonal to each of them.

- functions::computeSimplifiedVector Given a vector, returns the
  aligned vector with its component simplified by the gcd of all
  components (when the components are integers) or the aligned vector
  with a maximum oo-norm of 1 (when the components are floating-point
  numbers).

This example (similar to exampleAffineGeometry.cpp) shows how to
process the affine geometry of a set of points that is not full
dimensional.
  
@code
#include "DGtal/base/Common.h"
#include "DGtal/kernel/PointVector.h"
#include "DGtal/geometry/tools/AffineGeometry.h"

template <typename T> std::ostream&
operator<<( std::ostream& out, const std::vector< T >& object )
{ // to display vector<T>
  out << "[";
  for ( auto t : object ) out << " " << t;
  out << " ]";
  return out;
}

using namespace DGtal;
int main()
{
  typedef PointVector< 3, int64_t> Point;
  std::vector< Point > X = {  Point{21, -29, -21}, Point{-6, 14, 8}, Point{-19, 1, 9}, Point{39, 16, -12}, Point{-26, 29, 23}, Point{-4, 45, 19}, Point{6, 31, 9}, Point{9, 6, -2}, Point{8, 49, 15} };

  std::cout << "Dimension is " << Point::dimension << "\n";
  std::cout << "X = " << X << "\n";
  std::cout << "Expected dimension of affine set of points X is "
            << (Point::dimension-1) << "\n";
  std::cout << "AffineDim(X) = " << functions::computeAffineDimension( X ) << "\n";
  auto I = functions::computeAffineSubset( X );
  std::cout << "AffineSubset(X) = " << I << "\n";
  auto B = functions::computeAffineBasis( X );
  std::cout << "AffineBasis(X) =: p+B = " << B.first << " + " << B.second << "\n";
  auto e = functions::computeIndependentVector( B.second );
  std::cout << "Independent(X) =: e = " << e << "\n";
  Point n;
  functions::computeOrthogonalVector( n, B.second );
  std::cout << "Orthogonal(X) =: n = " << n << "\n";
  Point ns = functions::computeSimplifiedVector( n );
  std::cout << "Orthogonal(X)/gcd =: ns = " << ns << "\n";  
  for ( auto i = 0; i < B.second.size(); i++ )
    std::cout << "B[" << i << "] . ns = " << B.second[i] << " . " << ns
              << " == " << B.second[i].dot(ns) << " (should be 0)\n";
}
@endcode  

outputs
\verbatim
Dimension is 3
X = [ (21, -29, -21) (-6, 14, 8) (-19, 1, 9) (39, 16, -12) (-26, 29, 23) (-4, 45, 19) (6, 31, 9) (9, 6, -2) (8, 49, 15) ]
Expected dimension of affine set of points X is 2
AffineDim(X) = 2
AffineSubset(X) = [ 0 1 2 ]
AffineBasis(X) =: p+B = (21, -29, -21) + [ (-27, 43, 29) (-40, 30, 30) ]
Independent(X) =: e = (1, 0, 0)
Orthogonal(X) =: n = (420, -350, 910)
Orthogonal(X)/gcd =: ns = (6, -5, 13)
B[0] . ns = (-27, 43, 29) . (6, -5, 13) == 0 (should be 0)
B[1] . ns = (-40, 30, 30) . (6, -5, 13) == 0 (should be 0)
\endverbatim

@section dgtal_affgeom_sec2 Class AffineGeometry

*/

} //  namespace DGtal
