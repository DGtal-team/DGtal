
/* 
 * Useful to avoid writing DGtal:: in front of every class.
 */
namespace DGtal {

/**
   
@page moduleAffineGeometry Affine geometry of points and vectors

@writers Jacques-Olivier Lachaud

@since 2.0

Part of the \ref packageGeometry.

This part of the manual describes how to perform some elementary
affine geometry computations: affine dimension of a set of points,
subset of maximum affine dimension, completion of a partial basis,
computation of an orthogonal vector. This module is notably used in
QuickHull algorithm.

[TOC]

The following programs are related to this documentation:
testAffineGeometry.cpp exampleAffineGeometry.cpp


See \subpage moduleQuickHull

@section dgtal_affgeom_sec1 Generic functions for affine geometry

A set of generic functions is provided in header
`DGtal/geometry/tools/AffineGeometry.h` for several affine geometry
computations. They can be conveniently used since they deduce
automatically the type of parameters.  All these functions support
number types for points and vectors that are either integers (int32_t,
int64_t, BigInteger) or floating-point numbers (float, double). The
computations are \b exact when types are \b integral (up to integer
overflow), while a \b tolerance can be provided for floating-point
numbers (default tolerance: between -1e-12 and 1e-12 is zero).

* <b> affine dimension and affine subset </b>

  - functions::computeAffineDimension( const std::vector< TPoint >& X,
  const double tolerance ) Given a range of points \a X, returns the
  affine dimension of its spanned affine subspace.

  - functions::computeAffineSubset( const std::vector< TPoint >& X,
  const double tolerance ) Given a range of points \a X, returns a
  subset of these points that form an affine basis of \a
  X. Equivalently it is a simplex whose affine space spans all the
  points of \a X.

  - functions::computeAffineSubset( const std::vector<TPoint>& X, const
  TIndexRange& I, const double tolerance ) Given a range of points \a
  X and a subset of it given by indices \a I, returns a subset of
  these points that form an affine basis of \a X[I]. Equivalently it
  is a simplex whose affine space spans all the points of \a X[I].

* <b> affine basis and independent vectors </b>

  The computed bases are in echelon reduced form, except when using
  completeBasis where the last vector may be asked to be orthogonal to
  all the others.

  - functions::getAffineBasis( TInputPoint& o, std::vector< TPoint >&
  basis, const std::vector< TInputPoint >& X, const double tolerance )
  Given a range of points \a X, outputs a point and a range of vectors
  forming an affine basis containing \a X.

  - functions::getAffineBasis( TInputPoint& o, std::vector< TPoint >&
  basis, const std::vector< TInputPoint >& X, const TIndexRange& I,
  const double tolerance ) Given a range of points \a X and the
  indices \a I of points in \a X which form an affine subset of \a X,
  returns a point and a range of vectors forming an affine basis
  containing \a X.

  - functions::computeIndependentVector( const std::vector< TPoint >&
  basis, const double tolerance ) Given a partial basis of vectors,
  returns a returns a canonic unit vector that is independent.

  - functions::getCompleteBasis( std::vector< TPoint >& basis, bool
  normal_vector, const double tolerance ) Complete the vectors \a
  basis with independent vectors so as to form a basis of the
  space. When \a normal_vector is true, the last added vector is
  guaranteed to be \b orthogonal to all the previous vectors,
  otherwise it is just an independent canonic vector.

* <b> orthogonal vector to basis of codimension 1 </b>

  - functions::computeOrthogonalVectorToBasis( const
  std::vector<TPoint>& basis ) Given `d-1` independent vectors \a
  basis in dD, returns a vector that is orthogonal to each of them.

  - functions::getOrthogonalVector( TPoint& w, const std::vector<
  TInputPoint >& X, const TIndexRange& I, const double tolerance )
  Given a range of points \a X, a range of indices \a I specifying the
  affine subset of interest, returns a vector that is orthogonal to
  this affine subset, if it is d-1-dimensional.

  - functions::getOrthogonalVector( TPoint& w, const std::vector<
  TInputPoint >& X, const double tolerance ) Given a range of points
  \a X, returns a vector that is orthogonal to this affine set, if it
  is d-1-dimensional.

* <b> utilities </b>

  - functions::computeSimplifiedVector( const TPoint& v ) Given a
  vector, returns the aligned vector with its component simplified by
  the gcd of all components (when the components are integers) or the
  aligned vector with a maximum oo-norm of 1 (when the components are
  floating-point numbers).

This example (similar to exampleAffineGeometry.cpp) shows how to
process the affine geometry of a set of points that is not full
dimensional.
  
@code
#include "DGtal/base/Common.h"
#include "DGtal/kernel/PointVector.h"
#include "DGtal/geometry/tools/AffineGeometry.h"

template <typename T> std::ostream&
operator<<( std::ostream& out, const std::vector< T >& object )
{ // to display vector<T>
  out << "[";
  for ( auto t : object ) out << " " << t;
  out << " ]";
  return out;
}

using namespace DGtal;
int main()
{
  typedef PointVector< 3, int64_t> Point;
  std::vector< Point > X = {
    Point{21, -29, -21}, Point{-6, 14, 8}, Point{-19, 1, 9},
    Point{39, 16, -12}, Point{-26, 29, 23}, Point{-4, 45, 19},
    Point{6, 31, 9}, Point{9, 6, -2}, Point{8, 49, 15}
  };

  std::cout << "Dimension is " << Point::dimension << "\n";
  std::cout << "X = " << X << "\n";
  std::cout << "Expected dimension of affine set of points X is "
            << (Point::dimension-1) << "\n";
  std::cout << "AffineDim(X) = " << functions::computeAffineDimension( X ) << "\n";
  auto I = functions::computeAffineSubset( X );
  std::cout << "AffineSubset(X) = " << I << "\n";
  Point o;
  std::vector<Point> B;
  functions::getAffineBasis( o, B, X, I );
  std::cout << "AffineBasis(X) =: p+B = " << o << " + " << B << "\n";
  auto e = functions::computeIndependentVector( B );
  std::cout << "Independent(X) =: e = " << e << "\n";
  Point n = functions::computeOrthogonalVectorToBasis( B );
  std::cout << "Orthogonal(X) =: n = " << n << "\n";
  Point ns = functions::computeSimplifiedVector( n );
  std::cout << "Orthogonal(X)/gcd =: ns = " << ns << "\n";  
  for ( auto i = 0; i < B.size(); i++ )
    std::cout << "B[" << i << "] . ns = " << B[i] << " . " << ns
              << " == " << B[i].dot(ns) << " (should be 0)\n";
}
@endcode  

outputs
\verbatim
Dimension is 3
X = [ (-5, -25, 0) (19, 22, 7) (0, -19, 0) (-20, -17, 10) (20, 5, 0) (0, -6, 5) (9, 23, 12) (-14, -41, -2) (22, 10, 1) (34, -38, -23) (12, 11, 6) ]
Expected dimension of affine set of points X is 2
AffineDim(X) = 2
AffineSubset(X) = [ 0 1 2 ]
AffineBasis(X) =: p+B = (-5, -25, 0) + [ (24, 47, 7) (0, -13, -5) ]
Independent(X) =: e = (1, 0, 0)
Orthogonal(X) =: n = (-6, 5, -13)
Orthogonal(X)/gcd =: ns = (-6, 5, -13)
B[0] . ns = (24, 47, 7) . (-6, 5, -13) == 0 (should be 0)
B[1] . ns = (0, -13, -5) . (-6, 5, -13) == 0 (should be 0)
\endverbatim

@section dgtal_affgeom_sec2 Class AffineGeometry

If you need to finetune how affine geometry computations are
performed, you may use the static methods of class AffineGeometry
directly. The advantage is that you can specify a type for
computations that is \b more \b precise than the type of input data.

\code
typedef SpaceND<3, int> Space;
typedef Space::Point    Point;
typedef SpaceND<3, int64_t> ComputationSpace;
typedef ComputationSpace::Point  ComputationPoint;
...
typedef AffineGeometry<ComputationPoint> Affine;

std::vector<Point> X = { Point{1, 0, 0}, Point{2, 1, 0}, Point{3, 2, 0},
                         Point{3, 1, 1}, Point{5, 2, 2}, Point{4, 2, 1} };
auto I = Affine::affineSubset( X ); /// 3 points with indices (0,1,3)
auto B = Affine::affineBasis( X );  /// (1,0,0) and 2 basis vectors (1,1,0) and (2,1,1).
auto d = Affine::affineDimension( X ); /// 2
/// Computations are made with int64_t.
/// vectors of B also use this precision.
\endcode

The same services are provided as AffineGeometry static methods:

* <b> affine dimension and affine subset </b>

  - AffineGeometry::affineDimension( const std::vector<TInputPoint>&
    X, const double tolerance ) Given a range of points \a X, returns
    the affine dimension of its spanned affine subspace.
  
  - AffineGeometry::affineSubset( const std::vector<TInputPoint>& X,
    const double tolerance ) Given a range of points \a X, returns a
    subset of these points that form an affine basis of \a
    X. Equivalently it is a simplex whose affine space spans all the
    points of \a X.

  - AffineGeometry::affineSubset( const std::vector<TInputPoint>& X,
    const TIndexRange& I, const double tolerance ) Given a range of
    points \a X and a subset of it given by indices \a I, returns a
    subset of these points that form an affine basis of \a
    X[I]. Equivalently it is a simplex whose affine space spans all
    the points of \a X[I].
                  
* <b> affine basis and independent vectors </b>

  The computed bases are in echelon reduced form, except when using
  completeBasis where the last vector may be asked to be orthogonal to
  all the others.

  - AffineGeometry::affineBasis( const std::vector<TInputPoint>& X,
    const double tolerance = ) Given a range of points \a X, returns a
    point and a range of vectors forming an affine basis containing \a
    X.

  - AffineGeometry::affineBasis( const std::vector<TInputPoint>& X,
    const TIndexRange& I, const double tolerance ) Given a range of
    points \a X and a range of indices \a I describing its subset of
    interest, returns a point and a range of vectors forming an affine
    basis containing the subset `X[I]`.

  - AffineGeometry::independentVector( const Points& basis, const
    double tolerance ) Given a partial basis of vectors, returns a new
    vector that is independent.

  - AffineGeometry::completeBasis( Points& basis, bool normal_vector,
    const double tolerance ) Complete the vectors \a basis with
    independent vectors so as to form a basis of the space. When \a
    normal_vector is true, the last added vector is guaranteed to be
    \b orthogonal to all the previous vectors.

* <b> orthogonal vector to basis of codimension 1 </b>

  - AffineGeometry::orthogonalVector( const Points& basis ) Given
    `d-1` independent vectors in dD, returns a vector that is
    orthogonal to each of them.

* <b> utilities </b>

  Reducing a vector onto a basis is a Gaussian elimination but
  slightly modified to handle integers (in case of lattice points and
  vectors).

  - AffineGeometry::reductionOnBasis( const Point& v, const Points&
    basis, const double tolerance ) Reduces the vector \a v on the
    (partial or not) basis of vectors \a basis, and returns the part
    of \a v that cannot be expressed as a linear combination of
    vectors of \a basis, and hence a null vector if \a v is a linear
    combination of the vectors of the basis.

  - AffineGeometry::reduceVector( Point& w, const Point& b, const
    double tolerance ) Reduces vector \a w by the vector \a b, and
    returns the coefficients \f$ (\alpha,\beta) \f$ for reduction such
    that \f$ \alpha w - \beta b \f$ is the returned reduced vector,
    \f$ \alpha \ge 0 \f$.

  - AffineGeometry::simplifiedVector( Point v ) Given a vector,
    returns the aligned vector with its component simplified by the
    gcd of all components (when the components are integers) or the
    aligned vector with unit L2-norm (when the components are
    floating-point numbers).

@section dgtal_affgeom_sec3 Notes

Several functions that works with lattice vectors use functions
specialized to integer computations:

- functions::getDeterminantBareiss( TInternalNumber& result,
  const SimpleMatrix<TComponent, TN, TN>& matrix )

- functions::getDeterminantBareiss( TInternalNumber& result,
  const std::vector< std::vector< TComponent > >& matrix )

- functions::computeLLLBasis( const std::vector< std::vector<
  TComponent>>& B, TDouble delta );

- functions::reduceBasisWithLLL( std::vector< std::vector<
  TComponent>>& B, TDouble delta );

*/

} //  namespace DGtal
