/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file ConvexityHelper.ih
 * @author Jacques-Olivier Lachaud (\c jacques-olivier.lachaud@univ-savoie.fr )
 * Laboratory of Mathematics (CNRS, UMR 5127), University of Savoie, France
 *
 * @date 2020/01/02
 *
 * Implementation of inline methods defined in ConvexityHelper.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
#include <string>
#include <sstream>
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------

//-----------------------------------------------------------------------------
template < int dim, typename TInteger >
typename DGtal::ConvexityHelper< dim, TInteger>::LatticePolytope
DGtal::ConvexityHelper< dim, TInteger>::computeLatticePolytope
( const std::vector< Point >& input_points,
  bool remove_duplicates,
  bool make_minkowski_summable )
{
  typedef typename LatticePolytope::Domain     Domain;
  typedef typename LatticePolytope::HalfSpace  PolytopeHalfSpace;
  typedef QuickHull< LatticeConvexHullKernel > ConvexHull;
  typedef typename ConvexHull::HalfSpace       ConvexHullHalfSpace;
  typedef typename ConvexHull::Ridge           Ridge;
  if ( input_points.empty() ) return LatticePolytope();
  // Compute domain
  Point l = input_points[ 0 ];
  Point u = input_points[ 0 ];
  for ( const auto& p : input_points ) {
    l = l.inf( p );
    u = u.sup( p );
  }
  Domain domain( l, u );
  // Compute convex hull
  ConvexHull hull;
  hull.setInput( input_points, remove_duplicates );
  bool ok = hull.computeConvexHull( ConvexHull::Status::FacetsCompleted );
  if ( ! ok ) return LatticePolytope();
  // Initialize polytope
  std::vector< ConvexHullHalfSpace > HS;
  std::vector< PolytopeHalfSpace >   PHS;
  hull.getFacetHalfSpaces( HS );
  PHS.reserve( HS.size() );
  for ( auto& H : HS ) {
    Vector  N;
    Integer nu;
    for ( Dimension i = 0; i < dim; ++i )
      N[ i ] = (Integer) H.internalNormal()[ i ];
    nu = (Integer) H.internalIntercept();
    PHS.emplace_back( N, nu );
  }
  if ( make_minkowski_summable && dimension >= 4 )
    trace.warning() << "[ConvexityHelper::computeLatticePolytope]"
                    << " Not implemented starting from dimension 4."
                    << std::endl;
  if ( make_minkowski_summable && dimension == 3 )
    {
      // Compute ridge vertices to add edge constraints.
      std::vector< Point > positions;
      std::vector< IndexRange > facet_vertices; 
      std::vector< IndexRange > ridge_vertices; 
      std::map< Ridge, Index > ridge2index;
      hull.getVertexPositions( positions );
      computeFacetAndRidgeVertices( hull, facet_vertices,
                                    ridge2index, ridge_vertices );
      for ( auto p : ridge2index ) {
        const auto   r = p.first;
        const auto&  U = PHS[ r.first  ].N; // normal of facet 1
        const auto&  V = PHS[ r.second ].N; // normal of facet 2
        const auto&  S = ridge_vertices[ p.second ]; // vertices along facets 1, 2
        ASSERT( S.size() == 2 && "Invalid ridge" );
        const auto& P0 = positions[ S[ 0 ] ];
        const auto& P1 = positions[ S[ 1 ] ];
        auto         E = P1 - P0; // edge 1, 2
        const auto UxV =
          detail::BoundedLatticePolytopeSpecializer< dimension, Integer>
          ::crossProduct( U, V ); // parallel to E
        ASSERT( E.dot( UxV ) != 0 && "Invalid E / UxV" );
        if ( E.dot( UxV ) <= 0 ) E = -E; // force correct orientation
        const auto  E1 = 
          detail::BoundedLatticePolytopeSpecializer< dimension, Integer>
          ::crossProduct( U, E ); // edge on facet 1
        const auto  E2 = 
          detail::BoundedLatticePolytopeSpecializer< dimension, Integer>
          ::crossProduct( E, V ); // edge on facet 2
        ASSERT( E1.dot( U ) == 0 && "Invalid E1 / U" );
        ASSERT( E1.dot( V ) <  0 && "Invalid E1 / V" );
        ASSERT( E2.dot( V ) == 0 && "Invalid E1 / V" );
        ASSERT( E2.dot( U ) <  0 && "Invalid E1 / U" );
        for ( Dimension k = 0; k < dimension; ++k ) {
          const auto W = U[ k ] * V - V[ k ] * U;
          const auto nn1 = W.dot( E1 ); 
          const auto nn2 = W.dot( E2 ); 
          if ( nn1 > 0 && nn2 > 0 ) {
            PHS.emplace_back( -W, -W.dot( P0 ) );
            ASSERT( E1.dot(-W ) < 0 && "Invalid E1 /-W" );
            ASSERT( E2.dot(-W ) < 0 && "Invalid E2 /-W" );
          }
          else if ( nn1 < 0 && nn2 < 0 ) {
            PHS.emplace_back( W, W.dot( P0 ) );
            ASSERT( E1.dot( W ) < 0 && "Invalid E1 / W" );
            ASSERT( E2.dot( W ) < 0 && "Invalid E2 / W" );
          }
        }
      }
    }
  return LatticePolytope( domain, PHS.cbegin(), PHS.cend(),
                          dimension <= 3, true );
}

//-----------------------------------------------------------------------------
template < int dim, typename TInteger >
template < typename TSurfaceMesh >
bool
DGtal::ConvexityHelper< dim, TInteger>::computeConvexHullBoundary
( TSurfaceMesh&               mesh,
  const std::vector< Point >& input_points,
  bool remove_duplicates )
{
  typedef TSurfaceMesh                         SurfaceMesh;
  typedef QuickHull< LatticeConvexHullKernel > ConvexHull;
  typedef typename ConvexHull::IndexRange      IndexRange;
  ConvexHull hull;
  hull.setInput( input_points, remove_duplicates );
  bool ok = hull.computeConvexHull( ConvexHull::Status::VerticesCompleted );
  if ( !ok ) return false;
  std::vector< RealPoint > positions;
  hull.getVertexPositions( positions );
  std::vector< IndexRange > faces;
  hull.getFacetVertices( faces );
  mesh = SurfaceMesh( positions.cbegin(), positions.cend(),
                      faces.cbegin(), faces.cend() );
  return true;
}

//-----------------------------------------------------------------------------
template < int dim, typename TInteger >
bool
DGtal::ConvexityHelper< dim, TInteger>::computeConvexHullBoundary
( PolygonalSurface< Point >&  polysurf,
  const std::vector< Point >& input_points,
  bool remove_duplicates )
{
  typedef QuickHull< LatticeConvexHullKernel > ConvexHull;
  typedef typename ConvexHull::IndexRange      IndexRange;
  ConvexHull hull;
  hull.setInput( input_points, remove_duplicates );
  bool ok = hull.computeConvexHull( ConvexHull::Status::VerticesCompleted );
  if ( !ok ) return false;
  std::vector< Point > positions;
  hull.getVertexPositions( positions );
  std::vector< IndexRange > faces;
  hull.getFacetVertices( faces );
  // build polygonal surface
  polysurf.clear();
  for ( auto p : positions ) polysurf.addVertex( p );
  for ( auto f : faces )     polysurf.addPolygonalFace( f );
  return polysurf.build();
}

//-----------------------------------------------------------------------------
template < int dim, typename TInteger >
bool
DGtal::ConvexityHelper< dim, TInteger>::computeConvexHullCellComplex
( ConvexCellComplex< Point >& cell_complex,
  const std::vector< Point >& input_points,
  bool remove_duplicates )
{
  typedef QuickHull< LatticeConvexHullKernel > ConvexHull;
  typedef typename ConvexHull::IndexRange      IndexRange;
  typedef typename ConvexCellComplex< Point >::FaceRange FaceRange;
  ConvexHull hull;
  hull.setInput( input_points, remove_duplicates );
  bool ok = hull.computeConvexHull( ConvexHull::Status::VerticesCompleted );
  cell_complex.clear();
  if ( ! ok ) return false;
  // Build complex, only 1 finite cell and as many faces as convex hull facets.
  // Taking care of faces for each cell (here one cell borders all faces).
  std::vector< IndexRange > faces;
  hull.getFacetVertices( faces );
  FaceRange all_faces;
  for ( Index i = 0; i < faces.size(); i++ )
    all_faces.push_back( { i, true } );
  cell_complex.cell_faces.push_back( all_faces );
  // Vertices of this unique cell will be computed lazily on request.
  // Taking care of each face.
  for ( const auto& vtcs : faces )
    {
      // every inner face borders cell 0
      cell_complex.true_face_cell.push_back( 0 );
      // every outer face borders the infinite cell
      cell_complex.false_face_cell.push_back( cell_complex.infiniteCell() );
    }
  // Taking care of vertices (in consistent order) of every face
  cell_complex.true_face_vertices.swap( faces );
  // Taking care of vertex positions
  hull.getVertexPositions( cell_complex.vertex_position );
  return true;
}

//-----------------------------------------------------------------------------
template < int dim, typename TInteger >
bool
DGtal::ConvexityHelper< dim, TInteger>::computeDelaunayCellComplex
( ConvexCellComplex< Point >& cell_complex,
  const std::vector< Point >& input_points,
  bool remove_duplicates )
{
  typedef QuickHull< LatticeDelaunayKernel >   Delaunay;
  typedef typename Delaunay::Ridge             Ridge;
  typedef typename Delaunay::IndexRange        IndexRange;
  typedef typename ConvexCellComplex< Point >::FaceRange FaceRange;
  
  std::cout << "Compute convex hull in higher dimension" << std::endl;
  Delaunay del;
  del.setInput( input_points, remove_duplicates );
  bool ok = del.computeConvexHull( Delaunay::Status::VerticesCompleted );
  cell_complex.clear();
  if ( ! ok ) return false;
  
  // Build complex, as many maximal cells as convex hull facets.
  // convex hull facet -> cell of complex
  // convex hull ridge -> face of complex
  // (1) Get cell vertices, count ridges/faces and compute their vertices
  std::map< Ridge, Index > r2f;
  computeFacetAndRidgeVertices( del,
                                cell_complex.cell_vertices,
                                r2f,
                                cell_complex.true_face_vertices );
  // (2) assign ridges/faces to cell and conversely
  const Index  nb_r = r2f.size();
  std::cout << "assign ridges/faces to cell and conversely" << std::endl;
  cell_complex.true_face_cell .resize( nb_r, cell_complex.infiniteCell() );
  cell_complex.false_face_cell.resize( nb_r, cell_complex.infiniteCell() );
  cell_complex.true_face_vertices.resize( nb_r );
  for ( Index cur_f = 0; cur_f < del.nbFiniteFacets(); ++cur_f ) { 
    const auto& facet = del.facets[ cur_f ];
    FaceRange current_faces;
    for ( auto neigh_f : facet.neighbors ) {
      const Ridge r { std::min( cur_f, neigh_f ), std::max( cur_f, neigh_f ) };
      const bool pos = cur_f < neigh_f;
      const Index cur_r = r2f[ r ];
      cell_complex.true_face_cell [ cur_r ] = r.first;
      if ( r.second >= del.nbFiniteFacets() )
        cell_complex.false_face_cell[ cur_r ] = cell_complex.infiniteCell();
      else
        cell_complex.false_face_cell[ cur_r ] = r.second;
      current_faces.emplace_back( cur_r, pos );
    }
    cell_complex.cell_faces.push_back( current_faces );
  }
  // (3) Takes care of vertex positions
  std::cout << "takes care of vertex positions" << std::endl;
  del.getVertexPositions( cell_complex.vertex_position );
  return true;
}
    
//-----------------------------------------------------------------------------
template < int dim, typename TInteger >
template < typename QHull >
void
DGtal::ConvexityHelper< dim, TInteger>::computeFacetAndRidgeVertices
( const QHull& hull,
  std::vector< IndexRange >& cell_vertices,
  std::map< typename QHull::Ridge, Index >& r2f,
  std::vector< IndexRange >& face_vertices )
{
  typedef typename QHull::Ridge             Ridge;
  typedef typename QHull::IndexRange        IndexRange;

  ASSERT( hull.status() >= typename QHull::Status::VerticesCompleted
          && hull.status() >= typename QHull::Status::AllCompleted );
  
  // Get cell vertices and sort them
  hull.getFacetVertices( cell_vertices );
  std::vector< IndexRange > sorted_cell_vertices = cell_vertices;
  for ( auto& vtcs : sorted_cell_vertices )
    std::sort( vtcs.begin(), vtcs.end() );
  cell_vertices.resize( hull.nbFiniteFacets() );
  
  // Count ridges/faces and compute their vertices
  Index  nb_r = 0;
  face_vertices.clear();
  for ( Index cur_f = 0; cur_f < hull.nbFiniteFacets(); ++cur_f )  { 
    const auto& facet = hull.facets[ cur_f ];
    for ( auto neigh_f : facet.neighbors ) {
      const Ridge r { std::min( cur_f, neigh_f ), std::max( cur_f, neigh_f ) };
      auto itr = r2f.find( r );
      if ( itr == r2f.end() ) {
        IndexRange result;
        std::set_intersection( sorted_cell_vertices[ cur_f ].cbegin(),
                               sorted_cell_vertices[ cur_f ].cend(),
                               sorted_cell_vertices[ neigh_f ].cbegin(),
                               sorted_cell_vertices[ neigh_f ].cend(), 
                               std::back_inserter( result ) );
        face_vertices.push_back( result );
        r2f[ r ] = nb_r++;
      }
    }
  }
}

//                                                                           //
///////////////////////////////////////////////////////////////////////////////
