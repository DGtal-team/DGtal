/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file DigitalConvexity.ih
 * @author Jacques-Olivier Lachaud (\c jacques-olivier.lachaud@univ-savoie.fr )
 * Laboratory of Mathematics (CNRS, UMR 5127), University of Savoie, France
 *
 * @date 2020/01/31
 *
 * Implementation of inline methods defined in DigitalConvexity.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
#include "DGtal/geometry/volumes/ConvexityHelper.h"
//////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
template <typename TKSpace>
DGtal::DigitalConvexity<TKSpace>::
DigitalConvexity( Clone<KSpace> K, bool safe )
  : myK( K ), mySafe( safe )
{
}
//-----------------------------------------------------------------------------
template <typename TKSpace>
DGtal::DigitalConvexity<TKSpace>::
DigitalConvexity( Point lo, Point hi, bool safe )
  : mySafe( safe )
{
  myK.init( lo, hi, true );
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
const TKSpace&
DGtal::DigitalConvexity<TKSpace>::
space() const
{
  return myK;
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
template <typename PointIterator>
typename DGtal::DigitalConvexity<TKSpace>::LatticePolytope
DGtal::DigitalConvexity<TKSpace>::
makeSimplex( PointIterator itB, PointIterator itE )
{
  return LatticePolytope( itB, itE );
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
typename DGtal::DigitalConvexity<TKSpace>::LatticePolytope
DGtal::DigitalConvexity<TKSpace>::
makeSimplex( std::initializer_list<Point> l )
{
  return LatticePolytope( l );
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
template <typename PointIterator>
typename DGtal::DigitalConvexity<TKSpace>::RationalPolytope
DGtal::DigitalConvexity<TKSpace>::
makeRationalSimplex( Integer d, PointIterator itB, PointIterator itE )
{
  return RationalPolytope( d, itB, itE );
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
typename DGtal::DigitalConvexity<TKSpace>::RationalPolytope
DGtal::DigitalConvexity<TKSpace>::
makeRationalSimplex( std::initializer_list<Point> l )
{
  return RationalPolytope( l );
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
template <typename PointIterator>
bool
DGtal::DigitalConvexity<TKSpace>::
isSimplexFullDimensional( PointIterator itB, PointIterator itE )
{
  typedef SimpleMatrix<Integer,dimension,dimension> Matrix;
  const Dimension d = KSpace::dimension;
  std::vector<Point> pts( d+1 );
  Dimension k = 0;
  for ( ; itB != itE && k <= d; ++itB, ++k ) pts[ k ] = *itB;
  // A simplex has exactly d+1 vertices.
  if ( k != d+1 ) return false;
  Matrix M;
  for ( Dimension i = 0; i < d; ++i )
    for ( Dimension j = 0; j < d; ++j )
      M.setComponent( i, j, pts[ i ][ j ] - pts[ d ][ j ] );
  // A simplex has its vectors linearly independent.
  return M.determinant() != 0;
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
bool
DGtal::DigitalConvexity<TKSpace>::
isSimplexFullDimensional( std::initializer_list<Point> l )
{
  return isSimplexFullDimensional( l.begin(), l.end() );
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
template <typename PointIterator>
typename DGtal::DigitalConvexity<TKSpace>::SimplexType
DGtal::DigitalConvexity<TKSpace>::
simplexType( PointIterator itB, PointIterator itE )
{
  typedef SimpleMatrix<Integer,dimension,dimension> Matrix;
  const Dimension d = KSpace::dimension;
  std::vector<Point> pts( d+1 );
  Dimension k = 0;
  for ( ; itB != itE && k <= d; ++itB, ++k ) pts[ k ] = *itB;
  // A simplex has exactly d+1 vertices.
  if ( k != d+1 ) return SimplexType::INVALID;
  Matrix M;
  for ( Dimension i = 0; i < d; ++i )
    for ( Dimension j = 0; j < d; ++j )
      M.setComponent( i, j, pts[ i ][ j ] - pts[ d ][ j ] );
  // A simplex has its vectors linearly independent.
  auto V = M.determinant();
  return (V == 0) ? SimplexType::DEGENERATED
    : ( ((V == 1) || (V==-1)) ? SimplexType::UNITARY : SimplexType::COMMON );
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
void
DGtal::DigitalConvexity<TKSpace>::
displaySimplex( std::ostream& out, std::initializer_list<Point> l )
{
  displaySimplex( out, l.begin(), l.end() );
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
template <typename PointIterator>
void
DGtal::DigitalConvexity<TKSpace>::
displaySimplex( std::ostream& out, PointIterator itB, PointIterator itE )
{
  typedef SimpleMatrix<Integer,dimension,dimension> Matrix;
  const Dimension d = KSpace::dimension;
  std::vector<Point> pts( d+1 );
  Dimension k = 0;
  for ( ; itB != itE && k <= d; ++itB, ++k ) pts[ k ] = *itB;
  // A simplex has exactly d+1 vertices.
  if ( k != d+1 ) { out << "[SPLX INVALID]"; return; }
  Matrix M;
  for ( Dimension i = 0; i < d; ++i )
    for ( Dimension k = 0; k < d; ++k )
      M.setComponent( i, k, pts[ i ][ k ] - pts[ d ][ k ] );
  // A simplex has its vectors linearly independent.
  auto V = M.determinant();
  out << "[SPLX V=" << V;
  for ( Dimension i = 0; i < d; ++i ) {
    out << " (";
    for ( Dimension j = 0; j < d; ++j )
      out << " " << M( i, j );
    out << " )";
  }
  out << " ]";
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
typename DGtal::DigitalConvexity<TKSpace>::SimplexType
DGtal::DigitalConvexity<TKSpace>::
simplexType( std::initializer_list<Point> l )
{
  return simplexType( l.begin(), l.end() );
}


//-----------------------------------------------------------------------------
template <typename TKSpace>
typename DGtal::DigitalConvexity<TKSpace>::PointRange
DGtal::DigitalConvexity<TKSpace>::
insidePoints( const LatticePolytope& polytope )
{
  PointRange pts;
  polytope.getPoints( pts );
  return pts;
}
//-----------------------------------------------------------------------------
template <typename TKSpace>
typename DGtal::DigitalConvexity<TKSpace>::PointRange
DGtal::DigitalConvexity<TKSpace>::
interiorPoints( const LatticePolytope& polytope )
{
  PointRange pts;
  polytope.getInteriorPoints( pts );
  return pts;
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
typename DGtal::DigitalConvexity<TKSpace>::PointRange
DGtal::DigitalConvexity<TKSpace>::
insidePoints( const RationalPolytope& polytope )
{
  PointRange pts;
  polytope.getPoints( pts );
  return pts;
}
//-----------------------------------------------------------------------------
template <typename TKSpace>
typename DGtal::DigitalConvexity<TKSpace>::PointRange
DGtal::DigitalConvexity<TKSpace>::
interiorPoints( const RationalPolytope& polytope )
{
  PointRange pts;
  polytope.getInteriorPoints( pts );
  return pts;
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
template <typename PointIterator>
typename DGtal::DigitalConvexity<TKSpace>::CellGeometry
DGtal::DigitalConvexity<TKSpace>::
makeCellCover( PointIterator itB, PointIterator itE,
               Dimension i, Dimension k ) const
{
  ASSERT( 0 <= i );
  ASSERT( i <= k );
  ASSERT( k <= KSpace::dimension );
  CellGeometry cgeom( myK, i, k, false );
  cgeom.addCellsTouchingPoints( itB, itE );
  return cgeom;
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
typename DGtal::DigitalConvexity<TKSpace>::CellGeometry
DGtal::DigitalConvexity<TKSpace>::
makeCellCover( const LatticePolytope& P,
               Dimension i, Dimension k ) const
{
  ASSERT( 0 <= i );
  ASSERT( i <= k );
  ASSERT( k <= KSpace::dimension );
  CellGeometry cgeom( myK, i, k, false );
  cgeom.addCellsTouchingPolytope( P );
  return cgeom;
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
typename DGtal::DigitalConvexity<TKSpace>::CellGeometry
DGtal::DigitalConvexity<TKSpace>::
makeCellCover( const RationalPolytope& P,
               Dimension i, Dimension k ) const
{
  ASSERT( 0 <= i );
  ASSERT( i <= k );
  ASSERT( k <= KSpace::dimension );
  CellGeometry cgeom( myK, i, k, false );
  cgeom.addCellsTouchingPolytope( P );
  return cgeom;
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
typename DGtal::DigitalConvexity<TKSpace>::LatticePolytope 
DGtal::DigitalConvexity<TKSpace>::
makePolytope( const PointRange& X, bool make_minkowski_summable ) const
{
  if ( mySafe )
    {
      typedef typename detail::ConvexityHelperInternalInteger< Integer, true >::Type
        InternalInteger;
      return ConvexityHelper< dimension, Integer, InternalInteger >::
        computeLatticePolytope( X, false, make_minkowski_summable );
    }
  else
    {
      typedef typename detail::ConvexityHelperInternalInteger< Integer, false >::Type
        InternalInteger;
      return ConvexityHelper< dimension, Integer, InternalInteger >::
        computeLatticePolytope( X, false, make_minkowski_summable );
    }
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
typename DGtal::DigitalConvexity<TKSpace>::PointRange
DGtal::DigitalConvexity<TKSpace>::
U( Dimension i, const PointRange& X ) const
{
  PointRange Y( X );
  PointRange Z;
  Z.reserve( X.size() );
  auto add_one = [&i] ( Point & p ) { p[ i ] += 1; };
  std::for_each( Y.begin(), Y.end(), add_one );
  std::set_union( X.cbegin(), X.cend(), Y.cbegin(), Y.cend(),
                  std::back_inserter( Z ) );
  return  Z;
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
bool
DGtal::DigitalConvexity<TKSpace>::
is0Convex( const PointRange& X ) const
{
  if ( X.empty() ) return true;
  const auto P = makePolytope( X );
  return P.count() == X.size();
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
bool
DGtal::DigitalConvexity<TKSpace>::
isFullyConvex( const PointRange& Z, bool convex0 ) const
{
  ASSERT( dimension <= 64 );
  typedef DGtal::int64_t Direction;
  typedef std::vector< Direction > Directions;
  std::array< Directions, dimension > C;
  const bool cvx0 = convex0 ? true : is0Convex( Z );
  if ( ! cvx0 ) return false;
  C[ 0 ].push_back( (Direction) 0 );
  std::map< Direction, PointRange > X;
  X[ 0 ] = Z;
  std::sort( X[ 0 ].begin(), X[ 0 ].end() );
  for ( Dimension k = 1; k < dimension; k++ )
    {
      for ( const auto beta : C[ k-1 ] )
        {
          for ( Dimension j = 0; j < dimension; j++ )
            {
              const Direction dir_j = Direction(1) << j;
              if ( beta < dir_j )
                {
                  const Direction alpha = beta | dir_j;
                  C[ k ].push_back( alpha );
                  X[ alpha ] = U( j, X[ beta ] );
                  if ( ! is0Convex( X[ alpha ] ) ) return false;
                }
            }
        }
    }
  return true;
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
bool
DGtal::DigitalConvexity<TKSpace>::
isFullyConvexFast( const PointRange& Z  ) const
{ 
  LatticeSet C_Z( Z.cbegin(), Z.cend(), 0 );
  const auto nb_cells = C_Z.starOfPoints().size();
  const auto s = sizeStarCvxH( Z );
  return s == nb_cells; 
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
typename DGtal::DigitalConvexity<TKSpace>::PointRange
DGtal::DigitalConvexity<TKSpace>::
ExtrCvxH( const PointRange& X ) const
{
  if ( mySafe )
    {
      typedef typename detail::ConvexityHelperInternalInteger< Integer, true >::Type
        InternalInteger;
      return ConvexityHelper< dimension, Integer, InternalInteger >::
        computeLatticePolytopeVertices( X, false, false );
    }
  else
    {
      typedef typename detail::ConvexityHelperInternalInteger< Integer, false >::Type
        InternalInteger;
      return ConvexityHelper< dimension, Integer, InternalInteger >::
        computeLatticePolytopeVertices( X, false, false );
    }
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
typename  DGtal::DigitalConvexity<TKSpace>::LatticeSet
DGtal::DigitalConvexity<TKSpace>::
StarCvxH( const PointRange& X, Dimension axis ) const
{
  PointRange cells;
  typedef BoundedLatticePolytopeCounter<Space> Counter;
  typedef typename Counter::Interval           Interval;
  // Computes Minkowski sum of Z with hypercube
  PointRange Z = U( 0, X );
  for ( Dimension k = 1; k < dimension; k++ )
    Z = U( k, Z );
  // Builds polytope
  const auto P = makePolytope( Z );
  // Extracts lattice points within polytope
  // they correspond 1-1 to the d-cells intersected by Cvxh( Z )
  Counter C( P );
  const Dimension a = axis >= dimension ? C.longestAxis() : axis;
  auto cellP = C.getLatticeCells( a );
  return LatticeSet( cellP, a );
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
typename DGtal::DigitalConvexity<TKSpace>::LatticeSet
DGtal::DigitalConvexity<TKSpace>::
Star( const PointRange& X, const Dimension axis ) const
{
  const Dimension a = axis >= dimension ? 0 : axis;
  LatticeSet L( X.cbegin(), X.cend(), a );
  return L.starOfPoints();
}
//-----------------------------------------------------------------------------
template <typename TKSpace>
typename DGtal::DigitalConvexity<TKSpace>::LatticeSet
DGtal::DigitalConvexity<TKSpace>::
StarCells( const PointRange& C, const Dimension axis ) const
{
  const Dimension a = axis >= dimension ? 0 : axis;
  LatticeSet L( C.cbegin(), C.cend(), a );
  return L.starOfCells();
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
typename DGtal::DigitalConvexity<TKSpace>::LatticeSet
DGtal::DigitalConvexity<TKSpace>::
toLatticeSet( const PointRange& X, const Dimension axis ) const
{
  const Dimension a = axis >= dimension ? 0 : axis;
  return LatticeSet( X.cbegin(), X.cend(), a );
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
typename DGtal::DigitalConvexity<TKSpace>::PointRange
DGtal::DigitalConvexity<TKSpace>::
toPointRange( const LatticeSet& L ) const
{
  return L.toPointRange();
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
typename  DGtal::DigitalConvexity<TKSpace>::Integer
DGtal::DigitalConvexity<TKSpace>::
sizeStarCvxH( const PointRange& X ) const
{
  PointRange cells;
  typedef BoundedLatticePolytopeCounter<Space> Counter;
  typedef typename Counter::Interval           Interval;
  // Computes Minkowski sum of Z with hypercube
  PointRange Z = U( 0, X );
  for ( Dimension k = 1; k < dimension; k++ )
    Z = U( k, Z );
  // Builds polytope
  const auto P = makePolytope( Z );
  // Extracts lattice points within polytope
  // they correspond 1-1 to the d-cells intersected by Cvxh( Z )
  Counter C( P );
  const Dimension a = C.longestAxis();
  auto cellP = C.getLatticeCells( a );
  
  // Counts the number of cells
  Integer nb = 0;
  for ( const auto& value : cellP )
    {
      Point    p = value.first;
      Interval I = value.second;
      nb += I.second - I.first + 1;
    }
  return nb;
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
typename DGtal::DigitalConvexity<TKSpace>::PointRange 
DGtal::DigitalConvexity<TKSpace>::
Extr( const PointRange& C ) const
{
  // JOL: using std::set< Point > or std::unordered_set< Point > is slightly slower.
  // We prefer to use vector for easier vectorization.
  std::vector<Point> E;
  E.reserve( 2*C.size() );
  for ( auto&& kp : C )
    {
      auto c = myK.uCell( kp );
      if ( myK.uDim( c ) == 0 )
        E.push_back( myK.uCoords( c ) );
      else
        {
          auto faces = myK.uFaces( c );
          for ( auto&& f : faces )
            if ( myK.uDim( f ) == 0 )
              E.push_back( myK.uCoords( f ) );
        }
    }
  std::sort( E.begin(), E.end() );
  auto last = std::unique( E.begin(), E.end() );
  E.erase( last, E.end() );
  return E;
}
//-----------------------------------------------------------------------------
template <typename TKSpace>
typename DGtal::DigitalConvexity<TKSpace>::PointRange 
DGtal::DigitalConvexity<TKSpace>::
Extr( const LatticeSet& C ) const
{
  return C.extremaOfCells();
}
//-----------------------------------------------------------------------------
template <typename TKSpace>
typename DGtal::DigitalConvexity<TKSpace>::LatticeSet
DGtal::DigitalConvexity<TKSpace>::
Skel( const LatticeSet& C ) const
{
  return C.skeletonOfCells();
}
//-----------------------------------------------------------------------------
template <typename TKSpace>
typename DGtal::DigitalConvexity<TKSpace>::PointRange 
DGtal::DigitalConvexity<TKSpace>::
ExtrSkel( const LatticeSet& C ) const
{
  return C.skeletonOfCells().extremaOfCells();
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
typename DGtal::DigitalConvexity<TKSpace>::PointRange 
DGtal::DigitalConvexity<TKSpace>::
FC_direct( const PointRange& Z ) const
{
  typedef std::size_t    Size;
  typedef typename LatticePolytope::Domain Domain;
  typedef typename Counter::Interval       Interval;
  PointRange cells;
  // Computes Minkowski sum of Z with hypercube
  PointRange X( Z );
  for ( Dimension k = 0; k < dimension; k++ )
    X = U( k, X );
  // Builds polytope
  const auto P = makePolytope( X );
  // Extracts lattice points within polytope
  // they correspond 1-1 to the d-cells intersected by Cvxh( Z )
  Counter C( P );
  const Dimension a = C.longestAxis();
  Point lo = C.lowerBound();
  Point hi = C.upperBound();
  hi[ a ]  = lo[ a ];
  const Domain projD( lo, hi ); //< the projected domain of the polytope.
  const Point  One = Point::diagonal( 1 );
  const Size  size = projD.size();
  std::unordered_map< Point, Interval > cellP;
  Point q;
  for ( auto&& p : projD )
    {
      q = 2*p - One;
      const auto I = C.intersectionIntervalAlongAxis( p, a );
      const auto n = I.second - I.first;
      if ( n != 0 )
        {
          // Now the second bound is included
          cellP[ q ] = Interval( 2 * I.first - 1, 2 * I.second - 3 );
        }
    }
  // It remains to compute all the k-cells, 0 <= k < d, intersected by Cvxh( Z )
  for ( Dimension k = 0; k < dimension; k++ )
    {
      if ( k == a ) continue;
      std::vector< Point >    q_computed;
      std::vector< Interval > I_computed;
      for ( const auto& value : cellP )
        {
          Point    p = value.first;
          Interval I = value.second;
          Point    r = p; r[ k ] += 2;
          const auto it = cellP.find( r );
          if ( it == cellP.end() ) continue; // neighbor is empty
          // Otherwise compute common part.
          Interval J = it->second;
          auto     f = std::max( I.first,  J.first  );
          auto     s = std::min( I.second, J.second );
          if ( f <= s )
            {
              Point    q = p; q[ k ] += 1;
              q_computed.push_back( q );
              I_computed.push_back( Interval( f, s ) );
            }
        }
      // Add new columns to map Point -> column
      for ( auto i = 0; i < q_computed.size(); ++i )
        {
          cellP[ q_computed[ i ] ] = I_computed[ i ];
        }
    }
  // The built complex is open.
  // Check it and fill skelP
  std::unordered_map< Point, std::vector< Interval > > skelP;
  for ( const auto& value : cellP )
    {
      Point    p = value.first;
      Interval I = value.second;
      auto     n = I.second - I.first + 1;
      if ( n % 2 == 0 )
        trace.error() << "Weird thickness step 1="
                      << n << std::endl;
      std::vector< Interval > V( 1, I );
      auto result = skelP.insert( std::make_pair( p, V ) );
    }

  // std::cout << "Extract skel" << std::endl;
  // Now extracting implicitly its Skel
  for ( const auto& value : cellP )
    {
      const Point&   p = value.first;
      const auto&    I = value.second;
      for ( Dimension k = 0; k < dimension; k++ )
        {
          if ( k == a ) continue;
          if ( ( p[ k ] & 0x1 ) != 0 ) continue; // if open along axis continue
          // if closed, check upper incident cells along direction k
          Point q = p;  q[ k ] -= 1;
          Point r = p;  r[ k ] += 1;
          auto itq = skelP.find( q );
          if ( itq != skelP.end() )
            {
              auto& W = itq->second;
              eraseInterval( I, W );
              // if ( W.empty() ) skelP.erase( itq );
            }
          auto itr = skelP.find( r );
          if ( itr != skelP.end() )
            {
              auto& W = itr->second;
              eraseInterval( I, W );
              // if ( W.empty() ) skelP.erase( itr );
            }
        }
    }
  // Extract skel along main axis
  for ( const auto& value : cellP )
    {
      const Point& p = value.first;
      auto         I = value.second;
      const auto itp = skelP.find( p );
      if ( itp == skelP.end() ) continue;
      if ( ( I.first & 0x1 )  != 0 ) I.first  += 1;
      if ( ( I.second & 0x1 ) != 0 ) I.second -= 1;
      auto& W = itp->second;
      for ( auto x = I.first; x <= I.second; x += 2 )
        {
          eraseInterval( Interval{ x-1,x-1} , W );
          eraseInterval( Interval{ x+1,x+1} , W );
        }
    }  
  // Erase empty stacks
  for ( auto it = skelP.begin(), itE = skelP.end(); it != itE; )
    {
      const auto&    V = it->second;
      if ( V.empty() )
        {
          auto it_erase = it;
          ++it;
          skelP.erase( it_erase );
        }
      else ++it;
    }
  // Skel is constructed, now compute its Extr.
  PointRange  O;
  for ( const auto& value : skelP )
    {
      Point    p = value.first;
      auto     W = value.second;
      for ( auto&& I : W )
        {
          p[ a ] = I.first;
          O.push_back( p );
        }
    }
  return Extr( O );
}
//-----------------------------------------------------------------------------
template <typename TKSpace>
typename DGtal::DigitalConvexity<TKSpace>::PointRange 
DGtal::DigitalConvexity<TKSpace>::
FC_LatticeSet( const PointRange& Z ) const
{
  const auto StarCvxZ     = StarCvxH( Z );
  const auto SkelStarCvxZ = StarCvxZ.skeletonOfCells().toPointRange();
  return Extr( SkelStarCvxZ );
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
typename DGtal::DigitalConvexity<TKSpace>::PointRange 
DGtal::DigitalConvexity<TKSpace>::
FC( const PointRange& Z, EnvelopeAlgorithm algo ) const
{
  if ( algo == EnvelopeAlgorithm::DIRECT )
    return FC_direct( Z );
  else if ( algo == EnvelopeAlgorithm::LATTICE_SET )
    return FC_LatticeSet( Z );
  else
    return Z;
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
typename DGtal::DigitalConvexity<TKSpace>::PointRange 
DGtal::DigitalConvexity<TKSpace>::
envelope( const PointRange& Z, EnvelopeAlgorithm algo ) const
{
  myDepthLastFCE = 0;
  auto In = Z;
  while (true) {
    auto card_In = In.size();
    In = FC( In, algo );
    if ( In.size() == card_In ) return In;
    myDepthLastFCE++;
  }
  trace.error() << "[DigitalConvexity::envelope] Should never pass here."
                << std::endl;
  return Z; // to avoid warnings.
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
typename DGtal::DigitalConvexity<TKSpace>::PointRange 
DGtal::DigitalConvexity<TKSpace>::
relativeEnvelope( const PointRange& Z, const PointRange& Y,
                  EnvelopeAlgorithm algo ) const
{
  myDepthLastFCE = 0;
  auto In = Z;
  while (true) {
    PointRange Out;
    std::set_intersection( In.cbegin(), In.cend(),
                           Y.cbegin(), Y.cend(),
                           std::back_inserter( Out ) );
    In = FC( Out, algo ); 
    if ( In.size() == Out.size() ) return Out;
    myDepthLastFCE++;
  }
  return Z;
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
template <typename Predicate>
typename DGtal::DigitalConvexity<TKSpace>::PointRange 
DGtal::DigitalConvexity<TKSpace>::
relativeEnvelope( const PointRange& Z, const Predicate& PredY,
                  EnvelopeAlgorithm algo ) const
{
  myDepthLastFCE = 0;
  auto In = Z;
  while (true) {
    auto Out = filter( In, PredY );
    In = FC( Out, algo ); 
    if ( In.size() == Out.size() ) return In;
    myDepthLastFCE++;
  }
  return Z;
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
typename DGtal::DigitalConvexity<TKSpace>::Size
DGtal::DigitalConvexity<TKSpace>::
depthLastEnvelope() const
{
  return myDepthLastFCE;
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
bool
DGtal::DigitalConvexity<TKSpace>::
isKConvex( const LatticePolytope& P, const Dimension k ) const
{
  if ( k == 0 ) return true;
  auto S = insidePoints( P );
  auto touched_cells     = makeCellCover( S.begin(), S.end(), k, k );
  auto intersected_cells = makeCellCover( P, k, k );
  return intersected_cells.nbCells() == touched_cells.nbCells();
  // JOL: number should be enough
  // && intersected_cells.subset( touched_cells );
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
bool
DGtal::DigitalConvexity<TKSpace>::
isFullyConvex( const LatticePolytope& P ) const
{
  auto S = insidePoints( P );
  for ( Dimension k = 1; k < KSpace::dimension; ++ k )
    {
      auto touched_cells     = makeCellCover( S.begin(), S.end(), k, k );
      auto intersected_cells = makeCellCover( P, k, k );
      if ( ( intersected_cells.nbCells() != touched_cells.nbCells() ) )
        // JOL: number should be enough
        // || ( ! intersected_cells.subset( touched_cells ) ) )
        return false;
    }
  return true;
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
bool
DGtal::DigitalConvexity<TKSpace>::
isKSubconvex( const LatticePolytope& P, const CellGeometry& C, const Dimension k ) const
{
  auto intersected_cells = makeCellCover( P, k, k );
  return intersected_cells.subset( C );
}
//-----------------------------------------------------------------------------
template <typename TKSpace>
bool
DGtal::DigitalConvexity<TKSpace>::
isFullySubconvex( const LatticePolytope& P, const CellGeometry& C ) const
{
  auto intersected_cells = makeCellCover( P, C.minCellDim(), C.maxCellDim() );
  return intersected_cells.subset( C );
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
bool
DGtal::DigitalConvexity<TKSpace>::
isFullySubconvex( const LatticePolytope& P, const LatticeSet& StarX ) const
{
  LatticePolytope Q = P + typename LatticePolytope::UnitSegment( 0 );
  for ( Dimension k = 1; k < dimension; k++ )
    Q = Q + typename LatticePolytope::UnitSegment( k );
  typedef BoundedLatticePolytopeCounter<Space> Counter;
  Counter C( Q );
  const auto cells = C.getLatticeCells( StarX.axis() );
  LatticeSet StarP( cells, StarX.axis() );
  return StarX.includes( StarP );
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
bool
DGtal::DigitalConvexity<TKSpace>::
isFullySubconvex( const PointRange& Y, const LatticeSet& StarX ) const
{
  const auto SCY = StarCvxH( Y, StarX.axis() );
  return StarX.includes( SCY );
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
bool
DGtal::DigitalConvexity<TKSpace>::
isKSubconvex( const Point& a, const Point& b,
              const CellGeometry& C, const Dimension k ) const
{
  CellGeometry cgeom( myK, k, k, false );
  cgeom.addCellsTouchingSegment( a, b );
  return cgeom.subset( C );
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
bool
DGtal::DigitalConvexity<TKSpace>::
isFullySubconvex( const Point& a, const Point& b,
                  const CellGeometry& C ) const
{
  CellGeometry cgeom( myK, C.minCellDim(), C.maxCellDim(), false );
  cgeom.addCellsTouchingSegment( a, b );
  return cgeom.subset( C );
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
bool
DGtal::DigitalConvexity<TKSpace>::
isFullySubconvex( const Point& a, const Point& b,
                  const LatticeSet& StarX ) const
{
  // TODO
  LatticeSet L_ab( StarX.axis() );
  const auto    V = b - a;
  L_ab.insert( 2*a );
  // addCellsTouchingPoint( a );
  for ( Integer k = 0; k < dimension; k++ )
    {
      const Integer n = ( V[ k ] >= 0 ) ? V[ k ] : -V[ k ];
      const Integer d = ( V[ k ] >= 0 ) ? 1 : -1;
      if ( n == 0 ) continue;
      Point kc;
      for ( Integer i = 1; i < n; i++ )
        {
          for ( Dimension j = 0; j < dimension; j++ )
            {
              if ( j == k ) kc[ k ] = 2 * ( a[ k ] + d * i );
              else
                {
                  const auto v = V[ j ];
                  const auto q = ( v * i ) / n;
                  const auto r = ( v * i ) % n; // might be negative
                  kc[ j ] = 2 * ( a[ j ] + q );
                  if ( r < 0 )      kc[ j ] -= 1;
                  else if ( r > 0 ) kc[ j ] += 1;
                }
            }
          L_ab.insert( kc );
        }
    }
  if ( a != b ) L_ab.insert( 2*b );
  LatticeSet Star_ab = L_ab.starOfCells();
  return StarX.includes( Star_ab );
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
bool
DGtal::DigitalConvexity<TKSpace>::
isKConvex( const RationalPolytope& P, const Dimension k ) const
{
  if ( k == 0 ) return true;
  auto S = insidePoints( P );
  auto touched_cells     = makeCellCover( S.begin(), S.end(), k, k );
  auto intersected_cells = makeCellCover( P, k, k );
  return intersected_cells.nbCells() == touched_cells.nbCells()
    && intersected_cells.subset( touched_cells );
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
bool
DGtal::DigitalConvexity<TKSpace>::
isFullyConvex( const RationalPolytope& P ) const
{
  auto S = insidePoints( P );
  for ( Dimension k = 1; k < KSpace::dimension; ++ k )
    {
      auto touched_cells     = makeCellCover( S.begin(), S.end(), k, k );
      auto intersected_cells = makeCellCover( P, k, k );
      if ( ( intersected_cells.nbCells() != touched_cells.nbCells() )
           || ( ! intersected_cells.subset( touched_cells ) ) )
        return false;
    }
  return true;
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
bool
DGtal::DigitalConvexity<TKSpace>::
isKSubconvex( const RationalPolytope& P, const CellGeometry& C,
              const Dimension k ) const
{
  auto intersected_cells = makeCellCover( P, k, k );
  return intersected_cells.subset( C );
}
//-----------------------------------------------------------------------------
template <typename TKSpace>
bool
DGtal::DigitalConvexity<TKSpace>::
isFullySubconvex( const RationalPolytope& P, const CellGeometry& C ) const
{
  auto intersected_cells = makeCellCover( P, C.minCellDim(), C.maxCellDim() );
  return intersected_cells.subset( C );
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
void 
DGtal::DigitalConvexity<TKSpace>::
eraseInterval( Interval I, std::vector< Interval > & V )
{
  for ( std::size_t i = 0; i < V.size(); )
    {
      Interval& J = V[ i ];
      // I=[a,b], J=[a',b'], a <= b, a' <= b'
      if ( I.second < J.first ) { break; } // b < a' : no further intersection
      if ( J.second < I.first ) { ++i; continue; } // b' < a : no further intersection
      // a' <= b and a <= b'
      //       a ----------  b
      // a' ...............  a'
      //     b' ................. b'
      
      // a' ..................... b' => a'..a-1       b+1 b'
      Interval K1( J.first, I.first - 1 );
      Interval K2( I.second + 1, J.second );
      bool K1_exist = K1.second >= K1.first;
      bool K2_exist = K2.second >= K2.first;
      if ( K1_exist && K2_exist )
        {
          V[ i ] = K2;
          V.insert( V.begin() + i, K1 );
          break; // no further intersection possible
        }
      else if ( K1_exist )
        {
          V[ i ] = K1; i++;
        }
      else if ( K2_exist )
        {
          V[ i ] = K2; break;
        }
      else
        {
          V.erase( V.begin() + i );
        }
    }
}

//-----------------------------------------------------------------------------
template <typename TKSpace>
template <typename Predicate>
typename DGtal::DigitalConvexity<TKSpace>::PointRange 
DGtal::DigitalConvexity<TKSpace>::
filter( const PointRange& E, const Predicate& Pred )
{
  PointRange Out;
  Out.reserve( E.size() );
  for ( auto&& p : E )
    if ( Pred( p ) ) Out.push_back( p );
  return Out;
}

///////////////////////////////////////////////////////////////////////////////
// Interface - public :

/**
 * Writes/Displays the object on an output stream.
 * @param out the output stream where the object is written.
 */
template <typename TKSpace>
inline
void
DGtal::DigitalConvexity<TKSpace>::selfDisplay ( std::ostream & out ) const
{
  out << "[DigitalConvexity]";
}

/**
 * Checks the validity/consistency of the object.
 * @return 'true' if the object is valid, 'false' otherwise.
 */
template <typename TKSpace>
inline
bool
DGtal::DigitalConvexity<TKSpace>::isValid() const
{
  return true;
}


///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions                                        //

//-----------------------------------------------------------------------------
template <typename TKSpace>
inline
std::ostream&
DGtal::operator<< ( std::ostream & out,
                    const DigitalConvexity<TKSpace> & object )
{
  object.selfDisplay( out );
  return out;
}

//                                                                           //
///////////////////////////////////////////////////////////////////////////////
