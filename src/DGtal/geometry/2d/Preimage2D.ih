/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file Preimage2D.ih
 * @author Tristan Roussillon (\c tristan.roussillon@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Syst√®mes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 *
 * @date 2010/10/26
 *
 * @brief Implementation of inline methods defined in Preimage2D.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------


template <typename Shape>
inline
DGtal::Preimage2D<Shape>::Preimage2D(
  const Point & firstPoint, 
  const Point & secondPoint)
{
  myPHull.push_front(firstPoint);
  myQHull.push_front(secondPoint);
}



template <typename Shape>
inline
DGtal::Preimage2D<Shape>::~Preimage2D()
{
}


template <typename Shape>
inline
bool
DGtal::Preimage2D<Shape>::addFront(
    const Point & aP, 
    const Point & aQ)
{

  bool isEmpty = false;

  //predicates definition from critical shapes
  BackwardIterator PHullBack = myPHull.rbegin();
  ForwardIterator QHullFront = myQHull.begin();
  PHullBackQHullFrontPred p1( Shape(*PHullBack, *QHullFront) );

  BackwardIterator QHullBack = myQHull.rbegin();
  ForwardIterator PHullFront = myPHull.begin();
  QHullBackPHullFrontPred p2( Shape(*QHullBack, *PHullFront) );

  //constraint involved by aP
  if ( p1(aP) ) {
    if ( p2(aP) ) {

      //update PHull
      update<ForwardIterator,PHullUpdateForPAddingPred>
        (aP, myPHull, PHullFront, myPHull.end());

      //add aP to myPHull
      if (aP != *myPHull.begin()) myPHull.push_front(aP);

      //update myQHull
      update<BackwardIterator,QHullUpdateForPAddingPred>
        (aP, myQHull, QHullBack, myQHull.rend());


    } //else nothing to do

    //constraint involved by aQ
    if ( p2(aQ) ) {
      if ( p1(aQ) ) {

        //update myQHull
        update<ForwardIterator,QHullUpdateForQAddingPred>
          (aQ, myQHull, QHullFront, myQHull.end());

        //add aQ to myQHull
        if (aQ != *myQHull.begin()) myQHull.push_front(aQ);

        //update myPHull

        update<BackwardIterator,PHullUpdateForQAddingPred>
          (aQ, myPHull, PHullBack, myPHull.rend());

      } //else nothing to do

    } else isEmpty = true;

  } else isEmpty = true;

  return (!isEmpty);
}

template <typename Shape>
template <typename Iterator, typename Predicate>
inline
void
DGtal::Preimage2D<Shape>::update(
    const Point & aPoint,
    Container & aContainer,
    Iterator & anIterator,
    const Iterator & anEndIterator)
{

  Point p, q;
  q = *anIterator;
  anIterator++;
  if (anIterator != anEndIterator) {
    p = *anIterator;
    Predicate pred( Shape(p,q) );
//      std::cerr << pred << std::endl;


    while ( (anIterator != anEndIterator) && 
            (pred(aPoint)) ) {

      //deletion
      anIterator--;
//      std::cerr << "ERASE " << (*anIterator) << std::endl;
//      anIterator = aContainer.erase(anIterator);
//does not compile if type 'Iterator' is the type ' ::reverse_iterator'
//erase only takes parameter of type ' ::iterator'

      anIterator = 
        DGtal::OpInSTLContainers<Container,Iterator>
             ::erase(aContainer, anIterator);

      //update of pred
      q = p;  
      anIterator++;
      if (anIterator != anEndIterator) {
        p = *anIterator;
        pred = Predicate( Shape(p,q) );
      }
    }  
  }

}
///////////////////////////////////////////////////////////////////////////////
// Interface - public :

template <typename Shape>
inline
DGtal::DrawableWithBoard2D*
DGtal::Preimage2D<Shape>::defaultStyle( std::string /*mode*/ ) const
{
  return new DrawableWithBoard2D; 
}

template <typename Shape>
inline
std::string
DGtal::Preimage2D<Shape>::styleName() const
{
  return "Preimage2D";
}

template <typename Shape>
inline
void 
DGtal::Preimage2D<Shape>::selfDraw(Board2D & aBoard) const
{

  ConstForwardIterator i = myPHull.begin();
  Point pt(*i);
  ++i;
  while ( i != myPHull.end() ) {
    Shape s(pt, *i);
    s.selfDraw(aBoard);
    pt = Point(*i);
    ++i;
  }

  i = myQHull.begin();
  pt = Point(*i);
  ++i;
  while ( i != myQHull.end() ) {
    Shape s(pt, *i);
    s.selfDraw(aBoard);
    pt = Point(*i);
    ++i;
  }

  Point Pf(*myPHull.begin());
  Point Pl(*myPHull.rbegin());
  Point Qf(*myQHull.begin());
  Point Ql(*myQHull.rbegin());

  Shape s1(Pf, Ql);
  s1.selfDraw(aBoard);
  Shape s2(Qf, Pl);
  s2.selfDraw(aBoard);

}


template <typename Shape>
inline
void
DGtal::Preimage2D<Shape>::selfDisplay ( std::ostream & out ) const
{
  out << "[Preimage2D]\n";
  out << "first part: \n";
  for (ConstForwardIterator i = myPHull.begin(); 
       i != myPHull.end(); ++i) {
    out << *i << ", ";
  }
  out << "\n";
  out << "second part: \n";
  for (ConstForwardIterator i = myQHull.begin(); 
       i != myQHull.end(); ++i) {
    out << *i << ", ";
  }
  out << "\n";
}

template <typename Shape>
inline
bool
DGtal::Preimage2D<Shape>::isValid() const
{
    return true;
}



///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions                                        //

template <typename Shape>
inline
std::ostream&
DGtal::operator<< ( std::ostream & out, 
      const Preimage2D<Shape> & object )
{
  object.selfDisplay( out );
  return out;
}

//                                                                           //
///////////////////////////////////////////////////////////////////////////////


