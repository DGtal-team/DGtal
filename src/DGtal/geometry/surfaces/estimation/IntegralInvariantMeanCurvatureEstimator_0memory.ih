/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file IntegralInvariantMeanCurvatureEstimator_0memory.ih
 * @author Jeremy Levallois (\c jeremy.levallois@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Systèmes d'information - LIRIS (CNRS, UMR 5205), INSA-Lyon, France
 * LAboratoire de MAthématiques - LAMA (CNRS, UMR 5127), Université de Savoie, France
 *
 * @date 2012/04/19
 *
 * Implementation of inline methods defined in IntegralInvariantMeanCurvatureEstimator_0memory.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------



template< typename TKSpace, typename TShapeFunctor, DGtal::Dimension dimension >
inline
DGtal::IntegralInvariantMeanCurvatureEstimator_0memory< TKSpace, TShapeFunctor, dimension >::IntegralInvariantMeanCurvatureEstimator_0memory ( const KSpace & space, const ShapeCellFunctor & shapeFunctor )
    : myKernelFunctor( NumberTraits< Quantity >::ONE ),
      myConvolver( shapeFunctor, myKernelFunctor, space )
{}

template< typename TKSpace, typename TShapeFunctor >
inline
DGtal::IntegralInvariantMeanCurvatureEstimator_0memory< TKSpace, TShapeFunctor, 2 >::IntegralInvariantMeanCurvatureEstimator_0memory ( const KSpace & space, const ShapeCellFunctor & shapeFunctor )
    : myKernelFunctor( NumberTraits< Quantity >::ONE ),
      myConvolver( shapeFunctor, myKernelFunctor, space )
{}

template< typename TKSpace, typename TShapeFunctor >
inline
DGtal::IntegralInvariantMeanCurvatureEstimator_0memory< TKSpace, TShapeFunctor, 3 >::IntegralInvariantMeanCurvatureEstimator_0memory ( const KSpace & space, const ShapeCellFunctor & shapeFunctor )
    : myKernelFunctor( NumberTraits< Quantity >::ONE ),
      myConvolver( shapeFunctor, myKernelFunctor, space )
{}






template< typename TKSpace, typename TShapeFunctor, DGtal::Dimension dimension >
inline
void
DGtal::IntegralInvariantMeanCurvatureEstimator_0memory< TKSpace, TShapeFunctor, dimension >::init( const double _h, const double re )
{
    trace.error() << "Not available yet.";
}

template< typename TKSpace, typename TShapeFunctor >
inline
void
DGtal::IntegralInvariantMeanCurvatureEstimator_0memory< TKSpace, TShapeFunctor, 2 >::init( const double _h, const double re )
{
    h = _h;
    radius = re;

    meanFunctor.init( h, radius );

    /*dh2 = h * h;
    d3_r = 3.0 / radius;
    dPI_2 = M_PI / 2.0;
    d1_r2 = 1.0 / ( radius * radius );*/

    RealPoint rOrigin = RealPoint ( 0.0, 0.0 );
    Domain::Point pOrigin = Domain::Point( 0, 0 );
    kernel = new KernelSupport( rOrigin, radius );

    kernels = std::vector< DigitalShape > ( 9 );
    masks = std::vector< EuclideanMinus* >( 9 );

    /// Computation of shifting masks
    for( int y = -1; y <= 1; ++y )
    {
        for( int x = -1; x <= 1; ++x )
        {
            RealPoint shiftPoint = rOrigin + RealPoint( x * h , y * h );
            KernelSupport * kernelShifted = new KernelSupport( shiftPoint, radius );
            unsigned int offset = ( x + 1 ) + (( y + 1 ) * 3 );

            if( offset == 4 ) // Full kernel, already done
            {
                delete kernelShifted;
                RealPoint shiftPoint2 = rOrigin + RealPoint( 2.0 * radius, 2.0 * radius );
                KernelSupport * kernelShifted2 = new KernelSupport( shiftPoint2, 0.0 );
                EuclideanMinus * current = new EuclideanMinus( *kernel, *kernelShifted2 );

                masks[ offset ] = current;
                kernels[ offset ].attach( *current );
                kernels[ offset ].init( kernel->getLowerBound(), kernel->getUpperBound(), h );
            }
            else
            {
                EuclideanMinus * current = new EuclideanMinus( *kernel, *kernelShifted );

                masks[ offset ] = current;
                kernels[ offset ].attach( *current );
                kernels[ offset ].init( kernel->getLowerBound(), kernel->getUpperBound(), h );
            }
        }
    }
    /// End of computation of masks

    myConvolver.init( pOrigin, kernels );
}

template< typename TKSpace, typename TShapeFunctor >
inline
void
DGtal::IntegralInvariantMeanCurvatureEstimator_0memory< TKSpace, TShapeFunctor, 3 >::init( const double _h, const double re )
{
    h = _h;
    radius =  re;

    meanFunctor.init( h, radius );

    /*dh3 = h * h * h;
    d8_3r = 8.0 / ( 3.0 * radius );
    double r2 = radius * radius;
    d_4_PIr4 = 4.0 / ( M_PI * r2 * r2 );*/

    RealPoint rOrigin = RealPoint ( 0.0, 0.0, 0.0 );
    Domain::Point pOrigin = Domain::Point( 0, 0, 0 );
    kernel = new KernelSupport( rOrigin, radius );

    kernels = std::vector< DigitalShape >( 27 );
    masks = std::vector< EuclideanMinus* >( 27 );

    /// Computation of masks
    for( int z = -1; z <= 1; ++z )
    {
        for( int y = -1; y <= 1; ++y )
        {
            for( int x = -1; x <= 1; ++x )
            {
                RealPoint shiftPoint = rOrigin + RealPoint( x * h, y * h, z * h );
                KernelSupport * kernelShifted = new KernelSupport( shiftPoint, radius );
                unsigned int offset = ( x + 1 ) + (( y + 1 ) * 3 ) + (( z + 1 ) * 9 );

                if( offset == 13 ) // Full kernel
                {
                    delete kernelShifted;
                    RealPoint shiftPoint2 = rOrigin + RealPoint( 2.0 * radius, 2.0 * radius, 2.0 * radius );
                    KernelSupport * kernelShifted2 = new KernelSupport( shiftPoint2, 0.0 );
                    EuclideanMinus * current = new EuclideanMinus( *kernel, *kernelShifted2 );

                    masks[ offset ] = current;
                    kernels[ offset ].attach( *current );
                    kernels[ offset ].init( kernel->getLowerBound(), kernel->getUpperBound(), h );
                }
                else
                {
                    EuclideanMinus * current = new EuclideanMinus( *kernel, *kernelShifted );

                    masks[ offset ] = current;
                    kernels[ offset ].attach( *current );
                    kernels[ offset ].init( kernel->getLowerBound(), kernel->getUpperBound(), h );
                }
            }
        }
    }
    /// End of computation of masks

    myConvolver.init( pOrigin, kernels );
}






template< typename TKSpace, typename TShapeFunctor, DGtal::Dimension dimension >
template< typename ConstIteratorOnCells >
inline
typename DGtal::IntegralInvariantMeanCurvatureEstimator_0memory< TKSpace, TShapeFunctor, dimension >::Quantity
DGtal::IntegralInvariantMeanCurvatureEstimator_0memory< TKSpace, TShapeFunctor, dimension >::eval( const ConstIteratorOnCells & it )
{
    Quantity measure;
    trace.error() << "Not available yet.";
    return measure;
}

template< typename TKSpace, typename TShapeFunctor >
template< typename ConstIteratorOnCells >
inline
typename DGtal::IntegralInvariantMeanCurvatureEstimator_0memory< TKSpace, TShapeFunctor, 2 >::Quantity
DGtal::IntegralInvariantMeanCurvatureEstimator_0memory< TKSpace, TShapeFunctor, 2 >::eval ( const ConstIteratorOnCells & it )
{

    Quantity measure = ( Quantity )myConvolver.eval( it );
    return meanFunctor( measure );
}

template< typename TKSpace, typename TShapeFunctor >
template< typename ConstIteratorOnCells >
inline
typename DGtal::IntegralInvariantMeanCurvatureEstimator_0memory< TKSpace, TShapeFunctor, 3 >::Quantity
DGtal::IntegralInvariantMeanCurvatureEstimator_0memory< TKSpace, TShapeFunctor, 3 >::eval ( const ConstIteratorOnCells & it )
{
    Quantity measure = ( Quantity )myConvolver.eval( it );
    return meanFunctor( measure );
}



template< typename TKSpace, typename TShapeFunctor >
template< typename ConstIteratorOnCells, typename Shape >
inline
typename DGtal::IntegralInvariantMeanCurvatureEstimator_0memory< TKSpace, TShapeFunctor, 2 >::Quantity
DGtal::IntegralInvariantMeanCurvatureEstimator_0memory< TKSpace, TShapeFunctor, 2 >::eval ( const ConstIteratorOnCells & it,
                                                                                    const Shape & shape )
{

    Quantity measure = ( Quantity )myConvolver.eval( it, shape, h );
    return meanFunctor( measure );
}

template< typename TKSpace, typename TShapeFunctor >
template< typename ConstIteratorOnCells, typename Shape >
inline
typename DGtal::IntegralInvariantMeanCurvatureEstimator_0memory< TKSpace, TShapeFunctor, 3 >::Quantity
DGtal::IntegralInvariantMeanCurvatureEstimator_0memory< TKSpace, TShapeFunctor, 3 >::eval ( const ConstIteratorOnCells & it,
                                                                                    const Shape & shape )
{
    Quantity measure = ( Quantity )myConvolver.eval( it, shape, h );
    return meanFunctor( measure );
}



template< typename TKSpace, typename TShapeFunctor, DGtal::Dimension dimension >
template< typename ConstIteratorOnCells, typename OutputIterator >
inline
void
DGtal::IntegralInvariantMeanCurvatureEstimator_0memory< TKSpace, TShapeFunctor, dimension >::eval( const ConstIteratorOnCells & itb,
                                                                                           const ConstIteratorOnCells & ite,
                                                                                           OutputIterator & result )
{
    trace.error() << "IntegralInvariantMeanCurvatureEstimator_0memory@eval() : Not available yet.";
}

template< typename TKSpace, typename TShapeFunctor >
template< typename ConstIteratorOnCells, typename OutputIterator >
inline
void
DGtal::IntegralInvariantMeanCurvatureEstimator_0memory< TKSpace, TShapeFunctor, 2 >::eval( const ConstIteratorOnCells & itb,
                                                                                   const ConstIteratorOnCells & ite,
                                                                                   OutputIterator & result )
{
    myConvolver.eval( itb, ite, result, meanFunctor );

    /*std::vector< Quantity > quantities;
    std::back_insert_iterator< std::vector< Quantity > > quantitiesIterator( quantities );
    myConvolver.eval( itb, ite, quantitiesIterator );

    Quantity measure;

    DGtal::Dimension qsize = quantities.size();
    for( DGtal::Dimension  i = 0; i < qsize; ++i )
    {
        measure = quantities[ i ];
        measure *= dh2;
        *result = d3_r * ( dPI_2 - d1_r2 * measure );
        ++result;
    }*/
}

template< typename TKSpace, typename TShapeFunctor >
template< typename ConstIteratorOnCells, typename OutputIterator >
inline
void
DGtal::IntegralInvariantMeanCurvatureEstimator_0memory< TKSpace, TShapeFunctor, 3 >::eval( const ConstIteratorOnCells & itb,
                                                                                   const ConstIteratorOnCells & ite,
                                                                                   OutputIterator & result )
{
    myConvolver.eval( itb, ite, result, meanFunctor );

    /*std::vector< Quantity > quantities;
    std::back_insert_iterator< std::vector< Quantity > > quantitiesIterator( quantities );
    myConvolver.eval ( itb, ite, quantitiesIterator );

    Quantity measure;

    DGtal::Dimension qsize = quantities.size();
    for( DGtal::Dimension  i = 0; i < qsize; ++i )
    {
        measure = quantities[ i ];
        measure *= dh3;
        *result = d8_3r - d_4_PIr4 * measure;
        ++result;
    }*/
}

template< typename TKSpace, typename TShapeFunctor >
template< typename ConstIteratorOnCells, typename OutputIterator, typename Shape >
inline
void
DGtal::IntegralInvariantMeanCurvatureEstimator_0memory< TKSpace, TShapeFunctor, 2 >::eval( const ConstIteratorOnCells & itb,
                                                                                   const ConstIteratorOnCells & ite,
                                                                                   OutputIterator & result,
                                                                                   const Shape & shape )
{
    myConvolver.eval( itb, ite, result, shape, h, meanFunctor );

    /*std::vector< Quantity > quantities;
    std::back_insert_iterator< std::vector< Quantity > > quantitiesIterator( quantities );
    myConvolver.eval( itb, ite, quantitiesIterator, shape, h );

    Quantity measure;

    DGtal::Dimension qsize = quantities.size();
    for( DGtal::Dimension  i = 0; i < qsize; ++i )
    {
        measure = quantities[ i ];
        measure *= dh2;
        *result = d3_r * ( dPI_2 - d1_r2 * measure );
        ++result;
    }*/
}


template< typename TKSpace, typename TShapeFunctor >
template< typename ConstIteratorOnCells, typename OutputIterator, typename Shape >
inline
void
DGtal::IntegralInvariantMeanCurvatureEstimator_0memory< TKSpace, TShapeFunctor, 3 >::eval( const ConstIteratorOnCells & itb,
                                                                                   const ConstIteratorOnCells & ite,
                                                                                   OutputIterator & result,
                                                                                   const Shape & shape )
{
    myConvolver.eval( itb, ite, result, shape, h, meanFunctor );

    /*std::vector< Quantity > quantities;
    std::back_insert_iterator< std::vector< Quantity > > quantitiesIterator( quantities );
    myConvolver.eval ( itb, ite, quantitiesIterator, h, shape  );

    Quantity measure;

    DGtal::Dimension qsize = quantities.size();
    for( DGtal::Dimension  i = 0; i < qsize; ++i )
    {
        measure = quantities[ i ];
        measure *= dh3;
        *result = d8_3r - d_4_PIr4 * measure;
        ++result;
    }*/
}







template< typename TKSpace, typename TShapeFunctor, DGtal::Dimension dimension >
inline
void
DGtal::IntegralInvariantMeanCurvatureEstimator_0memory< TKSpace, TShapeFunctor, dimension >::selfDisplay( std::ostream & out ) const
{
    out << "[IntegralInvariantMeanCurvatureEstimator_0memory]";
}

template< typename TKSpace, typename TShapeFunctor >
inline
void
DGtal::IntegralInvariantMeanCurvatureEstimator_0memory< TKSpace, TShapeFunctor, 2 >::selfDisplay( std::ostream & out ) const
{
    out << "[IntegralInvariantMeanCurvatureEstimator_0memory]";
}

template< typename TKSpace, typename TShapeFunctor >
inline
void
DGtal::IntegralInvariantMeanCurvatureEstimator_0memory< TKSpace, TShapeFunctor, 3 >::selfDisplay( std::ostream & out ) const
{
    out << "[IntegralInvariantMeanCurvatureEstimator_0memory]";
}






template< typename TKSpace, typename TShapeFunctor, DGtal::Dimension dimension >
inline
bool
DGtal::IntegralInvariantMeanCurvatureEstimator_0memory< TKSpace, TShapeFunctor, dimension >::isValid() const
{
    return true;
}

template< typename TKSpace, typename TShapeFunctor >
inline
bool
DGtal::IntegralInvariantMeanCurvatureEstimator_0memory< TKSpace, TShapeFunctor, 2 >::isValid() const
{
    return true;
}

template< typename TKSpace, typename TShapeFunctor >
inline
bool
DGtal::IntegralInvariantMeanCurvatureEstimator_0memory< TKSpace, TShapeFunctor, 3 >::isValid() const
{
    return true;
}






template< typename TKSpace, typename TShapeFunctor, DGtal::Dimension dimension >
inline
std::ostream&
DGtal::operator<< ( std::ostream & out, const IntegralInvariantMeanCurvatureEstimator_0memory< TKSpace, TShapeFunctor, dimension > & object )
{
    object.selfDisplay( out );
    return out;
}

template< typename TKSpace, typename TShapeFunctor >
inline
std::ostream&
DGtal::operator<< ( std::ostream & out, const IntegralInvariantMeanCurvatureEstimator_0memory< TKSpace, TShapeFunctor, 2 > & object )
{
    object.selfDisplay( out );
    return out;
}

template< typename TKSpace, typename TShapeFunctor >
inline
std::ostream&
DGtal::operator<< ( std::ostream & out, const IntegralInvariantMeanCurvatureEstimator_0memory< TKSpace, TShapeFunctor, 3 > & object )
{
    object.selfDisplay( out );
    return out;
}
