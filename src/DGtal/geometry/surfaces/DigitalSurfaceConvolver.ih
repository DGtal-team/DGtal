/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file DigitalSurfaceConvolver.ih
 * @author Jeremy Levallois (\c jeremy.levallois@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Systèmes d'information - LIRIS (CNRS, UMR 5205), INSA-Lyon, France
 * LAboratoire de MAthématiques - LAMA (CNRS, UMR 5127), Université de Savoie, France
 *
 * @date 2012/03/27
 *
 * Implementation of inline methods defined in DigitalSurfaceConvolver.h
 *
 * This file is part of the DGtal library.
 */

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
//////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////
#include "DGtal/geometry/surfaces/DigitalSurfaceConvolver.h"
#include "DGtal/kernel/NumberTraits.h"
///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////// nD /////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

template< typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator, DGtal::Dimension dimension >
inline
DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, dimension >
::DigitalSurfaceConvolver( ConstAlias< Functor > f,
                           ConstAlias< KernelFunctor > g,
                           ConstAlias< KSpace > space)
    : myFFunctor( f ),
      myGFunctor( g ),
      myKSpace( space ),
      isInit( false ),
      isInitMask( false )
{
}

template< typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator, DGtal::Dimension dimension >
inline
void
DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, dimension >::init( Clone< KernelConstIterator > itgbegin,
                                                                                                        Clone< KernelConstIterator > itgend,
                                                                                                        Clone< Spel > kOrigin
                                                                                                        )
{
    myItKernelBegin = itgbegin;
    myItKernelEnd = itgend;
    myKernelSpelOrigin = kOrigin;

    isInit = true;
    isInitMask = false;
}

template< typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator, DGtal::Dimension dimension >
inline
void
DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, dimension >::init( Clone< KernelConstIterator > itgbegin,
                                                                                                        Clone< KernelConstIterator > itgend,
                                                                                                        Clone< Spel > kOrigin,
                                                                                                        Alias< std::vector< PairIterators > > mask )
{
    myItKernelBegin = itgbegin;
    myItKernelEnd = itgend;
    myKernelSpelOrigin = kOrigin;
    myMask = mask;

    isInit = true;
    isInitMask = true;
}

template< typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator, DGtal::Dimension dimension >
template< typename ConstIteratorOnCells >
inline
typename DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, dimension >::Quantity
DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, dimension >::eval
( const ConstIteratorOnCells & it )
{
    ASSERT ( isInit == true );

    typedef typename KSpace::Point Point;

    Quantity currentResult = NumberTraits< Quantity >::ZERO;
    Quantity currentResult2 = NumberTraits< Quantity >::ZERO;

    Spel currentCell = myKSpace.sIndirectIncident( *it, *myKSpace.sOrthDirs( *it )); //nD Cell next to *it (spel)
    Spel currentCell2 = myKSpace.sDirectIncident( *it, *myKSpace.sOrthDirs( *it ));
    Spel shiftedCell;

    Point shift = currentCell.myCoordinates - myKernelSpelOrigin.myCoordinates;
    Point shift2 = currentCell2.myCoordinates - myKernelSpelOrigin.myCoordinates;
    Point shiftedPoint;

    for(  KernelConstIterator itgcurrent = myItKernelBegin; itgcurrent != myItKernelEnd; ++itgcurrent )
    {
        /// Computation for the cell inside the shape.
        shiftedPoint = ( *itgcurrent ).myCoordinates;
        shiftedPoint += shift;
        shiftedCell.myCoordinates = shiftedPoint;

        currentResult += myFFunctor( shiftedCell ) * myGFunctor( *itgcurrent );

        /// Computation for the cell outside the shape.
        shiftedPoint = ( *itgcurrent ).myCoordinates;
        shiftedPoint += shift2;
        shiftedCell.myCoordinates = shiftedPoint;

        currentResult2 += myFFunctor( shiftedCell ) * myGFunctor( *itgcurrent );
    }


    /// In order to get better results, we compute the convolution kernel centered inside and outside the spel ins the shape border, and divide the result by 2.
    return ( currentResult + currentResult2 ) / Quantity( 2.0 );
}

template <typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator, DGtal::Dimension dimension>
template<typename ConstIteratorOnCells, typename OutputIterator>
inline
void
DGtal::DigitalSurfaceConvolver<Functor, KernelFunctor, KSpace, KernelConstIterator, dimension>::eval
( const ConstIteratorOnCells & itbegin,
  const ConstIteratorOnCells & itend,
  OutputIterator & result )
{
    //ASSERT ( isInitMask == true ); //Actually, this don't use the optimization by masks

    for( ConstIteratorOnCells itcurrent = itbegin;
         itcurrent != itend;
         ++itcurrent )
    {
        *result = eval( itcurrent );
        ++result;
    }

    return result;
}

template< typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator, DGtal::Dimension dimension >
template< typename ConstIteratorOnCells >
inline
typename DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, dimension >::CovarianceMatrix
DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, dimension >::evalCovarianceMatrix
( const ConstIteratorOnCells & it )
{
    ASSERT ( isInit == true );

    typedef typename KSpace::Point Point;
    typedef typename Functor::Quantity FQuantity;

    Spel currentCell = myKSpace.sIndirectIncident( *it, *myKSpace.sOrthDirs( *it ));
    Point shiftedPoint, currentPoint;
    Point shift = currentCell.myCoordinates - myKernelSpelOrigin.myCoordinates;

    Spel shiftedCell;

    FQuantity fShiftedCell;

    CovarianceMatrix Ja;
    MatrixQuantity XXT;
    XXT.constant( NumberTraits< Quantity >::ZERO );
    VectorQuantity Sa;
    Sa.reset();
    Quantity Va = NumberTraits< Quantity >::ZERO;

    SCellToMidPoint< KSpace > midpoint( myKSpace );

    for( KernelConstIterator itgcurrent = myItKernelBegin; itgcurrent != myItKernelEnd; ++itgcurrent )
    {
        shiftedPoint = ( *itgcurrent ).myCoordinates;
        shiftedPoint += shift;
        shiftedCell.myCoordinates = shiftedPoint;

        fShiftedCell = myFFunctor( shiftedCell );

        if( fShiftedCell != NumberTraits< FQuantity >::ZERO )
        {
            currentPoint = midpoint( shiftedCell );

            for( Dimension line = 0; line < dimension; ++line )
            {
                for( Dimension column = 0; column < dimension; ++column )
                {
                    XXT.setComponent( line, column, XXT( line, column ) + fShiftedCell * currentPoint[ line ] * currentPoint[ column ]);
                }

                Sa[ line ] += fShiftedCell * currentPoint[ line ];
            }

            Va += fShiftedCell * myGFunctor( *itgcurrent );
        }
    }

    double dVa = (double) NumberTraits< Quantity >::castToDouble( Va );
    double One_Va = 1.0 / dVa;

    for( Dimension line = 0; line < dimension; ++line )
    {
        for( Dimension column = 0; column < dimension; ++column )
        {
            Ja.setComponent( line, column, ((double) NumberTraits< Quantity >::castToDouble( XXT( line, column ))) - dVa * ( One_Va * ((double) NumberTraits< Quantity >::castToDouble( Sa[ line ] ))) * ( One_Va * ((double) NumberTraits< Quantity >::castToDouble( Sa[ column ] ))));
        }
    }

    return Ja;
}

template< typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator, DGtal::Dimension dimension >
template< typename ConstIteratorOnCells, typename OutputIterator >
inline
void
DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, dimension >::evalCovarianceMatrix
( const ConstIteratorOnCells & itbegin,
  const ConstIteratorOnCells & itend,
  OutputIterator & result )
{
    for( ConstIteratorOnCells itcurrent = itbegin;
         itcurrent != itend;
         ++itcurrent )
    {
        *result = evalCovarianceMatrix( itcurrent );
        ++result;
    }

    return result;
}

template <typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator, DGtal::Dimension dimension>
inline
bool
DGtal::DigitalSurfaceConvolver<Functor, KernelFunctor, KSpace, KernelConstIterator, dimension>::isValid() const
{
    return true;
}

template< typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator, DGtal::Dimension dimension >
void
DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, dimension >::fillMoments
( Quantity* aMomentMatrix,
  const Point & aPoint,
  double direction )
{

}

template< typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator, DGtal::Dimension dimension >
void
DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, dimension >::computeCovarianceMatrix
( const Quantity* aMomentMatrix,
  CovarianceMatrix & aCovarianceMatrix )
{

}

template< typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator, DGtal::Dimension dimension >
template< typename Shape >
double
DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, dimension >::computeShiftFromShape
( const Shape & shape,
  const double h,
  const Spel & aInnerSpel,
  const Spel & aOutterSpel )
{
    double lambda = -1.0;
    return lambda;
}






//////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////// 2D /////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

template< typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator >
inline
DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, 2 >
::DigitalSurfaceConvolver( ConstAlias< Functor > f,
                           ConstAlias< KernelFunctor > g,
                           ConstAlias< KSpace > space)
    : dimension( 2 ),
      myFFunctor( f ),
      myGFunctor( g ),
      myKSpace( space ),
      isInit( false ),
      isInitMask( false )
{
}

template< typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator >
inline
void
DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, 2 >::init( Clone< KernelConstIterator > itgbegin,
                                                                                                Clone< KernelConstIterator > itgend,
                                                                                                Clone< Spel > kOrigin
                                                                                                )
{
    myItKernelBegin = itgbegin;
    myItKernelEnd = itgend;
    myKernelSpelOrigin = kOrigin;

    isInit = true;
    isInitMask = false;
}

template< typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator >
inline
void
DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, 2 >::init( Clone< KernelConstIterator > itgbegin,
                                                                                                Clone< KernelConstIterator > itgend,
                                                                                                Clone< Spel > kOrigin,
                                                                                                Alias< std::vector< PairIterators > > mask )
{
    myItKernelBegin = itgbegin;
    myItKernelEnd = itgend;
    myKernelSpelOrigin = kOrigin;
    myMask = mask;

    ASSERT ( myMask.size () == 9 );

    isInit = true;
    isInitMask = true;
}

template< typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator >
template< typename ConstIteratorOnCells >
inline
typename DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, 2 >::Quantity
DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, 2 >::eval
( const ConstIteratorOnCells & it )
{
    ASSERT ( isInit == true );

    typedef typename KSpace::Point Point;

    Quantity currentResult = NumberTraits< Quantity >::ZERO;
    Quantity currentResult2 = NumberTraits< Quantity >::ZERO;

    Spel currentCell = myKSpace.sIndirectIncident( *it, *myKSpace.sOrthDirs( *it )); //nD Cell next to *it (spel)
    Spel currentCell2 = myKSpace.sDirectIncident( *it, *myKSpace.sOrthDirs( *it ));
    Spel shiftedCell;

    Point shift = currentCell.myCoordinates - myKernelSpelOrigin.myCoordinates;
    Point shift2 = currentCell2.myCoordinates - myKernelSpelOrigin.myCoordinates;
    Point shiftedPoint;

    for(  KernelConstIterator itgcurrent = myItKernelBegin; itgcurrent != myItKernelEnd; ++itgcurrent )
    {
        /// Computation for the cell inside the shape.
        shiftedPoint = ( *itgcurrent ).myCoordinates;
        shiftedPoint += shift;
        shiftedCell.myCoordinates = shiftedPoint;

        currentResult += myFFunctor( shiftedCell ) * myGFunctor( *itgcurrent );

        /// Computation for the cell outside the shape.
        shiftedPoint = ( *itgcurrent ).myCoordinates;
        shiftedPoint += shift2;
        shiftedCell.myCoordinates = shiftedPoint;

        currentResult2 += myFFunctor( shiftedCell ) * myGFunctor( *itgcurrent );
    }

    /// In order to get better results, we compute the convolution kernel centered inside and outside the spel ins the shape border, and divide the result by 2.
    return ( currentResult + currentResult2 ) / Quantity( 2.0 );
}

template <typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator>
template<typename ConstIteratorOnCells, typename OutputIterator>
inline
void
DGtal::DigitalSurfaceConvolver<Functor, KernelFunctor, KSpace, KernelConstIterator, 2>::eval
( const ConstIteratorOnCells & itbegin,
  const ConstIteratorOnCells & itend,
  OutputIterator & result )
{
    ASSERT ( isInitMask == true );

    typedef typename KSpace::Point Point;

    Spel lastCell, lastCell2, currentCell, currentCell2, shiftedCell;

    Quantity lastResult = NumberTraits< Quantity >::ZERO;
    Quantity lastResult2 = NumberTraits< Quantity >::ZERO;
    Quantity currentResult, currentResult2, maskQuantity;

    Point shift, shift2, shiftedPoint, diffLastCurrentCell, diffWithCurrentCell;

    int x, y, x2, y2, x2y2, offset;

    Dimension total = 0;
#ifdef DEBUG_VERBOSE
    Dimension recount = 0;
#endif

    for( ConstIteratorOnCells itcurrent = itbegin; itcurrent != itend; ++itcurrent )
    {
        currentResult = NumberTraits< Quantity >::ZERO;
        currentResult2 = NumberTraits< Quantity >::ZERO;

        currentCell = myKSpace.sIndirectIncident( *itcurrent, *myKSpace.sOrthDirs( *itcurrent )); /// Cell on the border, but inside the shape
        currentCell2 = myKSpace.sDirectIncident( *itcurrent, *myKSpace.sOrthDirs( *itcurrent )); /// Cell on the border, but outside the shape

        shift = currentCell.myCoordinates - myKernelSpelOrigin.myCoordinates;
        shift2 = currentCell2.myCoordinates - myKernelSpelOrigin.myCoordinates;

        if(  total == 0 ) /// Computation on full kernel, we have no previous results
        {
            /// Computation for the cell inside the shape. Using full kernel.
            for(  KernelConstIterator itgcurrent = myItKernelBegin; itgcurrent != myItKernelEnd; ++itgcurrent )
            {
                shiftedPoint = ( *itgcurrent ).myCoordinates;
                shiftedPoint += shift;
                shiftedCell.myCoordinates = shiftedPoint;

                currentResult += myFFunctor( shiftedCell ) * myGFunctor( *itgcurrent );
            }

            /// Computation for the cell outside the shape. Using previous result and masks.
            diffWithCurrentCell = currentCell2.myCoordinates - currentCell.myCoordinates;

            x = diffWithCurrentCell[ 0 ];
            y = diffWithCurrentCell[ 1 ];
            x2 = x * x;
            y2 = y * y;
            x2y2 = x2 + y2;

            offset = (( x / 2) + 1 ) + ((( y / 2 ) + 1 ) * 3 ); /// x/2 because we are in a KSpace, and we want a digital offset

            if( x2y2 != 4 && x2y2 != 8 ) /// Inside and outside cells aren't adjacent, but should be. It's a honeypot.
            {
                trace.error() << "Error - Found that inside and outside cells aren't adjacent. That's not logic.\n";
            }
            else if( offset == 4 ) /// Full kernel in 2D. Never reached because case already considered before. It's a honeypot.
            {
                trace.error() << "Error - Ask to compute full kernel at the wrong moment. Maybe it's an offset computation bug ?\n";
            }
            else
            {
                maskQuantity = NumberTraits< Quantity >::ZERO;

                for(  KernelConstIterator itgcurrent = myMask[ offset ].first, itgend = myMask[ offset ].second; itgcurrent != itgend; ++itgcurrent )
                {
                    shiftedPoint = ( *itgcurrent ).myCoordinates - diffWithCurrentCell;
                    shiftedPoint += shift2;
                    shiftedCell.myCoordinates = shiftedPoint;

                    maskQuantity -= myFFunctor( shiftedCell ) * myGFunctor( *itgcurrent );
                }

                for(  KernelConstIterator itgcurrent = myMask[ 8 - offset ].first, itgend = myMask[ 8 - offset ].second; itgcurrent != itgend; ++itgcurrent ) /// 8 is the size of the array
                {
                    shiftedPoint = ( *itgcurrent ).myCoordinates;
                    shiftedPoint += shift2;
                    shiftedCell.myCoordinates = shiftedPoint;

                    maskQuantity += myFFunctor( shiftedCell ) * myGFunctor( *itgcurrent );
                }

                currentResult2 = currentResult + maskQuantity;
            }
        }
        else
        {
            /// Computation for the cell inside the shape
            if(  currentCell == lastCell )
            {
                currentResult = lastResult;
            }
            else if(  currentCell == lastCell2 )
            {
                currentResult = lastResult2;
            }
            else
            {
                diffLastCurrentCell = currentCell.myCoordinates - lastCell.myCoordinates;

                x = diffLastCurrentCell[ 0 ];
                y = diffLastCurrentCell[ 1 ];
                x2 = x * x;
                y2 = y * y;
                x2y2 = x2 + y2;

                offset = (( x / 2 ) + 1 ) + ((( y / 2 ) + 1 ) * 3 ); /// x/2 because we are in a KSpace, and we want a digital offset

                if( x2y2 != 4 && x2y2 != 8 ) /// Previous and current cells aren't adjacent. Compute on the full kernel
                {
#ifdef DEBUG_VERBOSE
                    ++recount;
#endif

                    for( KernelConstIterator itgcurrent = myItKernelBegin; itgcurrent != myItKernelEnd; ++itgcurrent )
                    {
                        shiftedPoint = ( *itgcurrent ).myCoordinates;
                        shiftedPoint += shift;
                        shiftedCell.myCoordinates = shiftedPoint;

                        currentResult += myFFunctor( shiftedCell ) * myGFunctor( *itgcurrent );
                    }
                }
                else if( offset == 4 ) /// Full kernel in 2D. Never reached because case already considered before. It's a honeypot.
                {
                    trace.error() << "Error - Ask to compute full kernel at the wrong moment. Maybe it's an offset computation bug ?\n";
                }
                else
                {
                    maskQuantity = NumberTraits< Quantity >::ZERO;

                    /// Part to substract from previous result.
                    for(  KernelConstIterator itgcurrent = myMask[ offset ].first, itgend = myMask[ offset ].second; itgcurrent != itgend; ++itgcurrent )
                    {
                        shiftedPoint = ( *itgcurrent ).myCoordinates - diffLastCurrentCell;
                        shiftedPoint += shift;
                        shiftedCell.myCoordinates = shiftedPoint;

                        maskQuantity -= myFFunctor( shiftedCell ) * myGFunctor( *itgcurrent );
                    }

                    /// Part to add from previous result.
                    for(  KernelConstIterator itgcurrent = myMask[ 8 - offset ].first, itgend = myMask[ 8 - offset ].second; itgcurrent != itgend; ++itgcurrent ) /// 8 is the size of the array
                    {
                        shiftedPoint = ( *itgcurrent ).myCoordinates;
                        shiftedPoint += shift;
                        shiftedCell.myCoordinates = shiftedPoint;

                        maskQuantity += myFFunctor( shiftedCell ) * myGFunctor( *itgcurrent );
                    }

                    currentResult = lastResult + maskQuantity;
                }
            }

            /// Computation for the cell outside the shape.
            if(  currentCell2 == lastCell )
            {
                currentResult2 = lastResult;
            }
            else if(  currentCell2 == lastCell2 )
            {
                currentResult2 = lastResult2;
            }
            else
            {
                diffWithCurrentCell = currentCell2.myCoordinates - currentCell.myCoordinates;

                x = diffWithCurrentCell[ 0 ];
                y = diffWithCurrentCell[ 1 ];
                x2 = x * x;
                y2 = y * y;
                x2y2 = x2 + y2;

                offset = (( x / 2) + 1 ) + ((( y / 2 ) + 1 ) * 3 ); /// x/2 because we are in a KSpace, and we want a digital offset

                if(  x2y2 != 4 && x2y2 != 8 ) /// Inside and outside cells aren't adjacent, but should be. It's a honeypot.
                {
                    trace.error() << "Error - Found that inside and outside cells aren't adjacent. That's not logic.\n";
                }
                else if(  offset == 4 ) /// Full kernel in 2D. Never reached because case already considered before. It's a honeypot.
                {
                    trace.error() << "Error - Ask to compute full kernel at the wrong moment. Maybe it's an offset computation bug ?\n";
                }
                else
                {
                    maskQuantity = NumberTraits< Quantity >::ZERO;

                    /// Part to substract from previous result.
                    for(  KernelConstIterator itgcurrent = myMask[ offset ].first, itgend = myMask[ offset ].second; itgcurrent != itgend; ++itgcurrent )
                    {
                        shiftedPoint = ( *itgcurrent ).myCoordinates - diffWithCurrentCell;
                        shiftedPoint += shift2;
                        shiftedCell.myCoordinates = shiftedPoint;

                        maskQuantity -= myFFunctor( shiftedCell ) * myGFunctor( *itgcurrent );
                    }

                    /// Part to add from previous result.
                    for(  KernelConstIterator itgcurrent = myMask[ 8 - offset ].first, itgend = myMask[ 8 - offset ].second; itgcurrent != itgend; ++itgcurrent ) /// 8 is the size of the array
                    {
                        shiftedPoint = ( *itgcurrent ).myCoordinates;
                        shiftedPoint += shift2;
                        shiftedCell.myCoordinates = shiftedPoint;

                        maskQuantity += myFFunctor( shiftedCell ) * myGFunctor( *itgcurrent );
                    }

                    currentResult2 = currentResult + maskQuantity;
                }
            }
        }

        /// In order to get better results, we compute the convolution kernel centered inside and outside the spel ins the shape border, and divide the result by 2.
        *result = ( currentResult + currentResult2 ) / Quantity( 2.0 ); /// Set the current cell result to the output iterator. (The result is the mean between inside's and outside's cell lying to the shape border).
        ++result;

        lastResult = currentResult;
        lastResult2 = currentResult2;
        lastCell = currentCell;
        lastCell2 = currentCell2;

        ++total;
    }

#ifdef DEBUG_VERBOSE
    std::cout << "#total cells = " << total << std::endl;
    std::cout << "#recount = " << recount << std::endl;
#endif
}

template <typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator>
template<typename ConstIteratorOnCells, typename OutputIterator, typename Shape >
inline
void
DGtal::DigitalSurfaceConvolver<Functor, KernelFunctor, KSpace, KernelConstIterator, 2>::eval
( const ConstIteratorOnCells & itbegin,
  const ConstIteratorOnCells & itend,
  OutputIterator & result,
  const Shape & shape,
  const double h )
{
    ASSERT ( isInitMask == true );

    typedef typename KSpace::Point Point;

    Spel lastCell, lastCell2, currentCell, currentCell2, shiftedCell;

    Quantity lastResult = NumberTraits< Quantity >::ZERO;
    Quantity lastResult2 = NumberTraits< Quantity >::ZERO;
    Quantity currentResult, currentResult2, maskQuantity;

    Point shift, shift2, shiftedPoint, diffLastCurrentCell, diffWithCurrentCell;

    int x, y, x2, y2, x2y2, offset;

    Dimension total = 0;
#ifdef DEBUG_VERBOSE
    Dimension recount = 0;
#endif

    for( ConstIteratorOnCells itcurrent = itbegin; itcurrent != itend; ++itcurrent )
    {
        currentResult = NumberTraits< Quantity >::ZERO;
        currentResult2 = NumberTraits< Quantity >::ZERO;

        currentCell = myKSpace.sDirectIncident( *itcurrent, *myKSpace.sOrthDirs( *itcurrent )); /// Cell on the border, but inside the shape
        currentCell2 = myKSpace.sIndirectIncident( *itcurrent, *myKSpace.sOrthDirs( *itcurrent )); /// Cell on the border, but outside the shape


        double lambda = computeShiftFromShape( shape, h, currentCell, currentCell2 );

        shift = currentCell.myCoordinates - myKernelSpelOrigin.myCoordinates;
        shift2 = currentCell2.myCoordinates - myKernelSpelOrigin.myCoordinates;

        if(  total == 0 ) /// Computation on full kernel, we have no previous results
        {
            /// Computation for the cell inside the shape. Using full kernel.
            for(  KernelConstIterator itgcurrent = myItKernelBegin; itgcurrent != myItKernelEnd; ++itgcurrent )
            {
                shiftedPoint = ( *itgcurrent ).myCoordinates;
                shiftedPoint += shift;
                shiftedCell.myCoordinates = shiftedPoint;

                currentResult += myFFunctor( shiftedCell ) * myGFunctor( *itgcurrent );
            }

            /// Computation for the cell outside the shape. Using previous result and masks.
            diffWithCurrentCell = currentCell2.myCoordinates - currentCell.myCoordinates;

            x = diffWithCurrentCell[ 0 ];
            y = diffWithCurrentCell[ 1 ];
            x2 = x * x;
            y2 = y * y;
            x2y2 = x2 + y2;

            offset = (( x / 2) + 1 ) + ((( y / 2 ) + 1 ) * 3 ); /// x/2 because we are in a KSpace, and we want a digital offset

            if( x2y2 != 4 && x2y2 != 8 ) /// Inside and outside cells aren't adjacent, but should be. It's a honeypot.
            {
                trace.error() << "Error - Found that inside and outside cells aren't adjacent. That's not logic.\n";
            }
            else if( offset == 4 ) /// Full kernel in 2D. Never reached because case already considered before. It's a honeypot.
            {
                trace.error() << "Error - Ask to compute full kernel at the wrong moment. Maybe it's an offset computation bug ?\n";
            }
            else
            {
                maskQuantity = NumberTraits< Quantity >::ZERO;

                for(  KernelConstIterator itgcurrent = myMask[ offset ].first, itgend = myMask[ offset ].second; itgcurrent != itgend; ++itgcurrent )
                {
                    shiftedPoint = ( *itgcurrent ).myCoordinates - diffWithCurrentCell;
                    shiftedPoint += shift2;
                    shiftedCell.myCoordinates = shiftedPoint;

                    maskQuantity -= myFFunctor( shiftedCell ) * myGFunctor( *itgcurrent );
                }

                for(  KernelConstIterator itgcurrent = myMask[ 8 - offset ].first, itgend = myMask[ 8 - offset ].second; itgcurrent != itgend; ++itgcurrent ) /// 8 is the size of the array
                {
                    shiftedPoint = ( *itgcurrent ).myCoordinates;
                    shiftedPoint += shift2;
                    shiftedCell.myCoordinates = shiftedPoint;

                    maskQuantity += myFFunctor( shiftedCell ) * myGFunctor( *itgcurrent );
                }

                currentResult2 = currentResult + maskQuantity;
            }
        }
        else
        {
            /// Computation for the cell inside the shape
            if(  currentCell == lastCell )
            {
                currentResult = lastResult;
            }
            else if(  currentCell == lastCell2 )
            {
                currentResult = lastResult2;
            }
            else
            {
                diffLastCurrentCell = currentCell.myCoordinates - lastCell.myCoordinates;

                x = diffLastCurrentCell[ 0 ];
                y = diffLastCurrentCell[ 1 ];
                x2 = x * x;
                y2 = y * y;
                x2y2 = x2 + y2;

                offset = (( x / 2 ) + 1 ) + ((( y / 2 ) + 1 ) * 3 ); /// x/2 because we are in a KSpace, and we want a digital offset

                if( x2y2 != 4 && x2y2 != 8 ) /// Previous and current cells aren't adjacent. Compute on the full kernel
                {
#ifdef DEBUG_VERBOSE
                    ++recount;
#endif

                    for( KernelConstIterator itgcurrent = myItKernelBegin; itgcurrent != myItKernelEnd; ++itgcurrent )
                    {
                        shiftedPoint = ( *itgcurrent ).myCoordinates;
                        shiftedPoint += shift;
                        shiftedCell.myCoordinates = shiftedPoint;

                        currentResult += myFFunctor( shiftedCell ) * myGFunctor( *itgcurrent );
                    }
                }
                else if( offset == 4 ) /// Full kernel in 2D. Never reached because case already considered before. It's a honeypot.
                {
                    trace.error() << "Error - Ask to compute full kernel at the wrong moment. Maybe it's an offset computation bug ?\n";
                }
                else
                {
                    maskQuantity = NumberTraits< Quantity >::ZERO;

                    /// Part to substract from previous result.
                    for(  KernelConstIterator itgcurrent = myMask[ offset ].first, itgend = myMask[ offset ].second; itgcurrent != itgend; ++itgcurrent )
                    {
                        shiftedPoint = ( *itgcurrent ).myCoordinates - diffLastCurrentCell;
                        shiftedPoint += shift;
                        shiftedCell.myCoordinates = shiftedPoint;

                        maskQuantity -= myFFunctor( shiftedCell ) * myGFunctor( *itgcurrent );
                    }

                    /// Part to add from previous result.
                    for(  KernelConstIterator itgcurrent = myMask[ 8 - offset ].first, itgend = myMask[ 8 - offset ].second; itgcurrent != itgend; ++itgcurrent ) /// 8 is the size of the array
                    {
                        shiftedPoint = ( *itgcurrent ).myCoordinates;
                        shiftedPoint += shift;
                        shiftedCell.myCoordinates = shiftedPoint;

                        maskQuantity += myFFunctor( shiftedCell ) * myGFunctor( *itgcurrent );
                    }

                    currentResult = lastResult + maskQuantity;
                }
            }

            /// Computation for the cell outside the shape.
            if(  currentCell2 == lastCell )
            {
                currentResult2 = lastResult;
            }
            else if(  currentCell2 == lastCell2 )
            {
                currentResult2 = lastResult2;
            }
            else
            {
                diffWithCurrentCell = currentCell2.myCoordinates - currentCell.myCoordinates;

                x = diffWithCurrentCell[ 0 ];
                y = diffWithCurrentCell[ 1 ];
                x2 = x * x;
                y2 = y * y;
                x2y2 = x2 + y2;

                offset = (( x / 2) + 1 ) + ((( y / 2 ) + 1 ) * 3 ); /// x/2 because we are in a KSpace, and we want a digital offset

                if(  x2y2 != 4 && x2y2 != 8 ) /// Inside and outside cells aren't adjacent, but should be. It's a honeypot.
                {
                    trace.error() << "Error - Found that inside and outside cells aren't adjacent. That's not logic.\n";
                }
                else if(  offset == 4 ) /// Full kernel in 2D. Never reached because case already considered before. It's a honeypot.
                {
                    trace.error() << "Error - Ask to compute full kernel at the wrong moment. Maybe it's an offset computation bug ?\n";
                }
                else
                {
                    maskQuantity = NumberTraits< Quantity >::ZERO;

                    /// Part to substract from previous result.
                    for(  KernelConstIterator itgcurrent = myMask[ offset ].first, itgend = myMask[ offset ].second; itgcurrent != itgend; ++itgcurrent )
                    {
                        shiftedPoint = ( *itgcurrent ).myCoordinates - diffWithCurrentCell;
                        shiftedPoint += shift2;
                        shiftedCell.myCoordinates = shiftedPoint;

                        maskQuantity -= myFFunctor( shiftedCell ) * myGFunctor( *itgcurrent );
                    }

                    /// Part to add from previous result.
                    for(  KernelConstIterator itgcurrent = myMask[ 8 - offset ].first, itgend = myMask[ 8 - offset ].second; itgcurrent != itgend; ++itgcurrent ) /// 8 is the size of the array
                    {
                        shiftedPoint = ( *itgcurrent ).myCoordinates;
                        shiftedPoint += shift2;
                        shiftedCell.myCoordinates = shiftedPoint;

                        maskQuantity += myFFunctor( shiftedCell ) * myGFunctor( *itgcurrent );
                    }

                    currentResult2 = currentResult + maskQuantity;
                }
            }
        }

        /// In order to get better results, we compute the convolution kernel centered inside and outside the spel ins the shape border, and divide the result by 2.
        *result = ( currentResult + currentResult2 ) / Quantity( 2.0 ); /// Set the current cell result to the output iterator. (The result is the mean between inside's and outside's cell lying to the shape border).
        ++result;

        lastResult = currentResult;
        lastResult2 = currentResult2;
        lastCell = currentCell;
        lastCell2 = currentCell2;

        ++total;
    }

#ifdef DEBUG_VERBOSE
    std::cout << "#total cells = " << total << std::endl;
    std::cout << "#recount = " << recount << std::endl;
#endif
}

template< typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator >
template< typename ConstIteratorOnCells >
inline
typename DGtal::DigitalSurfaceConvolver<Functor, KernelFunctor, KSpace, KernelConstIterator, 2>::CovarianceMatrix
DGtal::DigitalSurfaceConvolver<Functor, KernelFunctor, KSpace, KernelConstIterator, 2>::evalCovarianceMatrix
( const ConstIteratorOnCells & it )
{
    ASSERT ( isInit == true );

    typedef typename KSpace::Point Point;
    typedef typename Functor::Quantity FQuantity;

    Spel currentCell = myKSpace.sIndirectIncident( *it, *myKSpace.sOrthDirs( *it  ));
    Point shiftedPoint, shift;
    Point currentPoint;

    shift = currentCell.myCoordinates - myKernelSpelOrigin.myCoordinates;

    Spel shiftedCell;

    FQuantity fShiftedCell;

    CovarianceMatrix Ja;
    MatrixQuantity XXT;
    XXT.constant( NumberTraits< Quantity >::ZERO );
    VectorQuantity Sa;
    Sa.reset();
    Quantity Va = NumberTraits< Quantity >::ZERO;

    SCellToMidPoint< KSpace > midpoint( myKSpace );

    for(  KernelConstIterator itgcurrent = myItKernelBegin; itgcurrent != myItKernelEnd; ++itgcurrent )
    {
        shiftedPoint = ( *itgcurrent ).myCoordinates;
        shiftedPoint += shift;
        shiftedCell.myCoordinates = shiftedPoint;

        fShiftedCell = myFFunctor( shiftedCell );

        if(  fShiftedCell != NumberTraits< FQuantity >::ZERO )
        {
            currentPoint = midpoint( shiftedCell );

            for( Dimension line = 0; line < dimension; ++line )
            {
                for( Dimension column = 0; column < dimension; ++column )
                {
                    XXT.setComponent( line, column, XXT( line, column ) + fShiftedCell * currentPoint[ line ] * currentPoint[ column ]);
                }

                Sa[ line ] += fShiftedCell * currentPoint[ line ];
            }

            Va += fShiftedCell * myGFunctor(*itgcurrent);
        }
    }

    double dVa = (double) NumberTraits< Quantity >::castToDouble( Va );
    double One_Va = 1.0 / dVa;

    for( Dimension line = 0; line < dimension; ++line )
    {
        for( Dimension column = 0; column < dimension; ++column )
        {
            Ja.setComponent( line, column, ((double) NumberTraits< Quantity >::castToDouble( XXT( line, column ))) - dVa * ( One_Va * ((double) NumberTraits< Quantity >::castToDouble( Sa[ line ] ))) * ( One_Va * ((double) NumberTraits< Quantity >::castToDouble( Sa[ column ] ))));
        }
    }

    return Ja;
}

template< typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator >
template< typename ConstIteratorOnCells, typename OutputIterator >
inline
void
DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, 2 >::evalCovarianceMatrix
( const ConstIteratorOnCells & itbegin,
  const ConstIteratorOnCells & itend,
  OutputIterator & result )
{
    Dimension total = 0;
#ifdef DEBUG_VERBOSE
    Dimension recount = 0;
#endif

    typedef typename KSpace::Point Point;
    typedef typename Functor::Quantity FQuantity;

    Dimension nbMoments = 6;
    Quantity m[ nbMoments ]; /// <! [ m00, m01, m10, m11, m02, m20 ]
    Quantity lastM1[ nbMoments ];
    Quantity lastM2[ nbMoments ];

    MatrixQuantity A1, A2;
    double B1, B2;
    MatrixQuantity C1, C2;
    CovarianceMatrix Ja1, Ja2;
    CovarianceMatrix lastJa1, lastJa2;

    Spel currentCell1, shiftedCell;
    Spel currentCell2;
    Point shift, shiftedPoint;
    Point diff;
    FQuantity fShiftedCell;
    Point currentPoint;

    Spel lastCell1;
    Spel lastCell2;

    SCellToMidPoint< KSpace > midpoint( myKSpace );

    bool bCanUseLastResults = false;
    bool bComputed = false; /// <! if the cell has already been computed, continue to the next

    int x, y;
    int offset;

    /// Iterate on all cells
    for( ConstIteratorOnCells it = itbegin; it != itend; ++it )
    {
        std::fill( m, m + nbMoments, NumberTraits< Quantity >::ZERO ); /// <! clear array

        /// Inner cell
        {
            currentCell1 = myKSpace.sIndirectIncident( *it, *myKSpace.sOrthDirs( *it )); /// Cell on the border, but inside the shape

            /// Check if we can use previous results
            if( total != 0 )
            {
                if(  currentCell1 == lastCell1 )
                {
                    memcpy( m, lastM1, nbMoments * sizeof( Quantity ));
                    Ja1 = lastJa1;
                    bComputed = true;
                }
                else if(  currentCell1 == lastCell2 )
                {
                    memcpy( m, lastM2, nbMoments * sizeof( Quantity ));
                    Ja1 = lastJa2;
                    bComputed = true;
                }

                diff = currentCell1.myCoordinates - lastCell1.myCoordinates;

                x = diff[ 0 ];
                y = diff[ 1 ];
                int x2 = x * x;
                int y2 = y * y;
                int x2y2 = x2 + y2;

                if( x2y2 != 4 && x2y2 != 8 ) /// Previous and current cells aren't adjacent. Compute on the full kernel
                {
                    bCanUseLastResults = false;
#ifdef DEBUG_VERBOSE
                    ++recount;
#endif
                }
                else
                {
                    offset = (( x / 2) + 1 ) + ((( y / 2 ) + 1 ) * 3 );
                    memcpy( m, lastM1, nbMoments * sizeof( Quantity ));
                }

                bComputed = false;
            }

            if( !bComputed )
            {
                if( !bCanUseLastResults ) /// Computation on full kernel, we have no previous results
                {
                    std::fill( m, m + nbMoments, NumberTraits< Quantity >::ZERO ); /// <! clear array

                    shift = currentCell1.myCoordinates - myKernelSpelOrigin.myCoordinates;

                    for( KernelConstIterator itgcurrent = myItKernelBegin; itgcurrent != myItKernelEnd; ++itgcurrent )
                    {
                        shiftedPoint = ( *itgcurrent ).myCoordinates;
                        shiftedPoint += shift;
                        shiftedCell.myCoordinates = shiftedPoint;

                        fShiftedCell = myFFunctor( shiftedCell );

                        if( fShiftedCell != NumberTraits< FQuantity >::ZERO )
                        {
                            currentPoint = midpoint( shiftedCell );
                            x = currentPoint[ 0 ];
                            y = currentPoint[ 1 ];

                            m[ 0 ] += 1;
                            m[ 1 ] += y;
                            m[ 2 ] += x;
                            m[ 3 ] += x * y;
                            m[ 4 ] += y * y;
                            m[ 5 ] += x * x;
                        }
                    }
                }
                else /// Using last1
                {
                    shift = currentCell1.myCoordinates - lastCell1.myCoordinates;

                    /// Part to substract from previous result.
                    for( KernelConstIterator itgcurrent = myMask[ offset ].first, itgend = myMask[ offset ].second; itgcurrent != itgend; ++itgcurrent )
                    {
                        shiftedPoint = ( *itgcurrent ).myCoordinates;
                        shiftedPoint += shift;
                        shiftedCell.myCoordinates = shiftedPoint;

                        fShiftedCell = myFFunctor( shiftedCell );

                        if( fShiftedCell != NumberTraits< FQuantity >::ZERO )
                        {
                            currentPoint = midpoint( shiftedCell );
                            x = currentPoint[ 0 ];
                            y = currentPoint[ 1 ];

                            m[ 0 ] -= 1;
                            m[ 1 ] -= y;
                            m[ 2 ] -= x;
                            m[ 3 ] -= x * y;
                            m[ 4 ] -= y * y;
                            m[ 5 ] -= x * x;
                        }
                    }

                    /// Part to add from previous result.
                    for( KernelConstIterator itgcurrent = myMask[ 8 - offset ].first, itgend = myMask[ 8 - offset ].second; itgcurrent != itgend; ++itgcurrent )
                    {
                        shiftedPoint = ( *itgcurrent ).myCoordinates;
                        shiftedPoint += shift;
                        shiftedCell.myCoordinates = shiftedPoint;

                        fShiftedCell = myFFunctor( shiftedCell );

                        if( fShiftedCell != NumberTraits< FQuantity >::ZERO )
                        {
                            currentPoint = midpoint( shiftedCell );
                            x = currentPoint[ 0 ];
                            y = currentPoint[ 1 ];

                            m[ 0 ] += 1;
                            m[ 1 ] += y;
                            m[ 2 ] += x;
                            m[ 3 ] += x * y;
                            m[ 4 ] += y * y;
                            m[ 5 ] += x * x;
                        }
                    }
                }

                /// Computation of covariance Matrix
                A1.setComponent( 0, 0, m[ 5 ] );
                A1.setComponent( 0, 1, m[ 3 ] );
                A1.setComponent( 1, 0, m[ 3 ] );
                A1.setComponent( 1, 1, m[ 4 ] );

                B1 = 1.0 / m[ 0 ];

                C1.setComponent( 0, 0, B1 * m[ 2 ] * m[ 2 ] );
                C1.setComponent( 0, 1, B1 * m[ 2 ] * m[ 1 ] );
                C1.setComponent( 0, 2, B1 * m[ 1 ] * m[ 2 ] );
                C1.setComponent( 1, 0, B1 * m[ 1 ] * m[ 1 ] );

                Ja1 = A1 - C1;

                memcpy( lastM1, m, nbMoments * sizeof( Quantity ));
                lastJa1 = Ja1;
            }
        }

        /// Outter cell
        {
            currentCell2 = myKSpace.sDirectIncident( *it, *myKSpace.sOrthDirs( *it ));
            shift = currentCell2.myCoordinates - currentCell1.myCoordinates;
            x = shift[ 0 ];
            y = shift[ 1 ];
            int x2 = x * x;
            int y2 = y * y;
            int x2y2 = x2 + y2;
            int offset = offset = (( x / 2) + 1 ) + ((( y / 2 ) + 1 ) * 3 ); /// x/2 because we are in a KSpace, and we want a digital offset

            if( x2y2 != 4 && x2y2 != 8 ) /// Inside and outside cells aren't adjacent, but should be. It's a honeypot.
            {
                trace.error() << "Error - Found that inside and outside cells aren't adjacent. That's not logic.\n";
            }
            else if( offset == 4 ) /// Full kernel in 3D. Never reached because case already considered before. It's a honeypot.
            {
                trace.error() << "Error - Ask to compute full kernel at the wrong moment. Maybe it's an offset computation bug ?\n";
            }
            else
            {
                shift = currentCell2.myCoordinates - myKernelSpelOrigin.myCoordinates;

                /// Part to substract from previous result.
                for( KernelConstIterator itgcurrent = myMask[ offset ].first, itgend = myMask[ offset ].second; itgcurrent != itgend; ++itgcurrent )
                {
                    shiftedPoint = ( *itgcurrent ).myCoordinates;
                    shiftedPoint += shift;
                    shiftedCell.myCoordinates = shiftedPoint;

                    fShiftedCell = myFFunctor( shiftedCell );

                    if( fShiftedCell != NumberTraits< FQuantity >::ZERO )
                    {
                        currentPoint = midpoint( shiftedCell );
                        x = currentPoint[ 0 ];
                        y = currentPoint[ 1 ];
                        m[ 0 ] -= 1;
                        m[ 1 ] -= y;
                        m[ 2 ] -= x;
                        m[ 3 ] -= x * y;
                        m[ 4 ] -= y * y;
                        m[ 5 ] -= x * x;
                    }
                }

                /// Part to add from previous result.
                for( KernelConstIterator itgcurrent = myMask[ 8 - offset ].first, itgend = myMask[ 8 - offset ].second; itgcurrent != itgend; ++itgcurrent )
                {
                    shiftedPoint = ( *itgcurrent ).myCoordinates;
                    shiftedPoint += shift;
                    shiftedCell.myCoordinates = shiftedPoint;

                    fShiftedCell = myFFunctor( shiftedCell );

                    if( fShiftedCell != NumberTraits< FQuantity >::ZERO )
                    {
                        currentPoint = midpoint( shiftedCell );
                        x = currentPoint[ 0 ];
                        y = currentPoint[ 1 ];

                        m[ 0 ] += 1;
                        m[ 1 ] += y;
                        m[ 2 ] += x;
                        m[ 3 ] += x * y;
                        m[ 4 ] += y * y;
                        m[ 5 ] += x * x;
                    }
                }
            }

            A2.setComponent( 0, 0, m[ 5 ] );
            A2.setComponent( 0, 1, m[ 3 ] );
            A2.setComponent( 1, 0, m[ 3 ] );
            A2.setComponent( 1, 1, m[ 4 ] );

            B2 = 1.0 / m[ 0 ];

            C2.setComponent( 0, 0, B1 * m[ 2 ] * m[ 2 ] );
            C2.setComponent( 0, 1, B1 * m[ 2 ] * m[ 1 ] );
            C2.setComponent( 0, 2, B1 * m[ 1 ] * m[ 2 ] );
            C2.setComponent( 1, 0, B1 * m[ 1 ] * m[ 1 ] );

            Ja2 = A2 - C2;

            memcpy( lastM1, m, nbMoments * sizeof( Quantity ));
            lastJa2 = Ja2;
        }

        /// Computation of result covariance matrix + moving
        *result = ( Ja1 + Ja2 ) / 2.0;
        ++result;

        lastCell1 = currentCell1;
        lastCell2 = currentCell2;

        ++total;
    }

#ifdef DEBUG_VERBOSE
    std::cout << "#total cells = " << total << std::endl;
    std::cout << "#recount = " << recount << std::endl;
#endif

}

template <typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator>
inline
bool
DGtal::DigitalSurfaceConvolver<Functor, KernelFunctor, KSpace, KernelConstIterator, 2>::isValid() const
{
    return true;
}

template< typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator >
void
DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, 2 >::fillMoments
( Quantity* aMomentMatrix,
  const Point & aPoint,
  double direction )
{
    int x = aPoint[ 0 ];
    int y = aPoint[ 1 ];

    aMomentMatrix[ 0 ] += direction * 1;
    aMomentMatrix[ 1 ] += direction * y;
    aMomentMatrix[ 2 ] += direction * x;
    aMomentMatrix[ 3 ] += direction * x * y;
    aMomentMatrix[ 4 ] += direction * y * y;
    aMomentMatrix[ 5 ] += direction * x * x;
}

template< typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator >
void
DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, 2 >::computeCovarianceMatrix
( const Quantity* aMomentMatrix,
  CovarianceMatrix & aCovarianceMatrix )
{
    MatrixQuantity A;
    double B;
    MatrixQuantity C;

    A.setComponent( 0, 0, aMomentMatrix[ 5 ] );
    A.setComponent( 0, 1, aMomentMatrix[ 3 ] );
    A.setComponent( 1, 0, aMomentMatrix[ 3 ] );
    A.setComponent( 1, 1, aMomentMatrix[ 4 ] );

    B = 1.0 / aMomentMatrix[ 0 ];

    C.setComponent( 0, 0, B * aMomentMatrix[ 2 ] * aMomentMatrix[ 2 ] );
    C.setComponent( 0, 1, B * aMomentMatrix[ 2 ] * aMomentMatrix[ 1 ] );
    C.setComponent( 1, 0, B * aMomentMatrix[ 1 ] * aMomentMatrix[ 2 ] );
    C.setComponent( 1, 1, B * aMomentMatrix[ 1 ] * aMomentMatrix[ 1 ] );

    aCovarianceMatrix = A - C;
}

template< typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator >
template< typename Shape >
double
DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, 2 >::computeShiftFromShape
( const Shape & shape,
  const double h,
  const Spel & aInnerSpel,
  const Spel & aOutterSpel )
{
    typedef typename Z2i::RealPoint RealPoint;

    double lambda = -1.0;
    //    CanonicSCellEmbedder< KSpace > SCellToRealPoint( myKSpace );

    RealPoint low = RealPoint( myKSpace.sCoords( aInnerSpel )) * h;
    RealPoint high = RealPoint( myKSpace.sCoords( aOutterSpel )) * h;
    //    RealPoint low = ( SCellToRealPoint( aInnerSpel )) * h;
    //    RealPoint high = ( SCellToRealPoint( aOutterSpel )) * h;

    unsigned int iter = 0;
    unsigned int nbIter = 10;


    if( shape.orientation( low ) == shape.orientation( high ) )
    {
        std::cout <<  "On the same orientation "<< low << " " << high << std::endl;
        std::cout << shape.orientation( low ) << std::endl;
    }

    RealPoint test;
    while ( iter <= nbIter )
    {
        test = ( low + high ) / 2.0;
        DGtal::Orientation inout = shape.orientation( test );

        ASSERT(( high != low ));

        if( inout == ON )
        {
            lambda = (( test - ( RealPoint( myKSpace.sCoords( aInnerSpel )) * h )).norm() / h );
            //            lambda = (( test - ( SCellToRealPoint( aInnerSpel ) * h )).norm() / h );
            break;
        }
        else if( inout == OUTSIDE )
        {
            high = test;
        }
        else
        {
            low = test;
        }

        ++iter;
    }

    if( lambda == -1.0 )
    {
        lambda = (( test - ( RealPoint( myKSpace.sCoords( aInnerSpel )) * h )).norm() / h );
        //        lambda = (( test - ( SCellToRealPoint( aInnerSpel ) * h )).norm() / h );
    }

    ASSERT (( lambda <= 1.0 ));
    ASSERT (( lambda >= 0.0 ));

    return lambda;
}








//////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////// 3D /////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

template< typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator >
inline
DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, 3 >
::DigitalSurfaceConvolver( ConstAlias< Functor > f,
                           ConstAlias< KernelFunctor > g,
                           ConstAlias< KSpace > space)
    :   dimension( 3 ),
      myFFunctor( f ),
      myGFunctor( g ),
      myKSpace( space ),
      isInit( false ),
      isInitMask( false )
{
}

template< typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator >
inline
void
DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, 3 >::init( Clone< KernelConstIterator > itgbegin,
                                                                                                Clone< KernelConstIterator > itgend,
                                                                                                Clone< Spel > kOrigin
                                                                                                )
{
    myItKernelBegin = itgbegin;
    myItKernelEnd = itgend;
    myKernelSpelOrigin = kOrigin;

    isInit = true;
    isInitMask = false;
}

template< typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator >
inline
void
DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, 3 >::init( Clone< KernelConstIterator > itgbegin,
                                                                                                Clone< KernelConstIterator > itgend,
                                                                                                Clone< Spel > kOrigin,
                                                                                                Alias< std::vector< PairIterators > > mask )
{
    myItKernelBegin = itgbegin;
    myItKernelEnd = itgend;
    myKernelSpelOrigin = kOrigin;
    myMask = mask;

    ASSERT ( myMask.size () == 27 );

    isInit = true;
    isInitMask = true;
}

template< typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator >
template< typename ConstIteratorOnCells >
inline
typename DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, 3 >::Quantity
DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, 3 >::eval
( const ConstIteratorOnCells & it )
{
    ASSERT ( isInitMask == true );

    typedef typename KSpace::Point Point;
    typedef typename Functor::Quantity FQuantity;

    double lambda = 0.5;

    DGtal::Dimension sizeMoments = 10;
    DGtal::Dimension sizeOfMasks = myMask.size() - 1;
    DGtal::Dimension positionOfFullKernel = 13;

    Quantity m1;
    Quantity m2;

    Spel currentSpel1, currentSpel2;
    Spel shiftedSpel;

    Point shiftSpel1, shiftSpel2;
    Point diffSpel;

    SCellToInnerPoint< KSpace > SCellToPoint( myKSpace );

    int x, y, z, x2, y2, z2, x2y2z2;
    int offset;

    m1 = NumberTraits< Quantity >::ZERO; /// <! clear m1
    /// Inner cell
    {
        DGtal::Dimension kDim = myKSpace.sOrthDir( *it );
        currentSpel1 = myKSpace.sDirectIncident( *it, kDim ); /// Spel on the border, but inside the shape
        shiftSpel1 = myKSpace.sKCoords( currentSpel1 ) - myKSpace.sKCoords( myKernelSpelOrigin );

        for( KernelConstIterator itgcurrent = myItKernelBegin; itgcurrent != myItKernelEnd; ++itgcurrent )
        {
            myKSpace.sSetKCoords( shiftedSpel, myKSpace.sKCoords( *itgcurrent ) + shiftSpel1 );

            ASSERT( myKSpace.sKCoords( shiftedSpel )[ 0 ] & 0x1 );
            ASSERT( myKSpace.sKCoords( shiftedSpel )[ 1 ] & 0x1 );
            ASSERT( myKSpace.sKCoords( shiftedSpel )[ 2 ] & 0x1 ); /// <! check if shiftedSpel is a spel.

            if( myFFunctor( shiftedSpel ) != NumberTraits< FQuantity >::ZERO )
            {
                ++m1;
            }
        }
    }

    m2 = m1;
    /// Outter cell
    {
        DGtal::Dimension kDim = myKSpace.sOrthDir( *it );
        currentSpel2 = myKSpace.sIndirectIncident( *it, kDim );
        shiftSpel2 = myKSpace.sKCoords( currentSpel2 ) - myKSpace.sKCoords( myKernelSpelOrigin );

        diffSpel = myKSpace.sKCoords( currentSpel2 ) - myKSpace.sKCoords( currentSpel1 );
        x = diffSpel[ 0 ];
        y = diffSpel[ 1 ];
        z = diffSpel[ 2 ];
        x2 = x * x;
        y2 = y * y;
        z2 = z * z;
        x2y2z2 = x2 + y2 + z2;


        if(  x2y2z2 != 4 && x2y2z2 != 8 && !( x2 == 4 && y2 == 4 && z2 == 4 )) /// Inside and outside cells aren't adjacent, but should be. It's a honeypot.
        {
            trace.error() << "Error - Found that inside and outside cells aren't adjacent. That's not logic.\n";
        }
        else if(  offset == positionOfFullKernel ) /// Full kernel in 3D. Never reached because case already considered before. It's a honeypot.
        {
            trace.error() << "Error - Ask to compute full kernel at the wrong moment. Maybe it's an offset computation bug ?\n";
        }
        else
        {
            offset = (( x / 2 ) + 1 ) + ((( y / 2 ) + 1 ) * 3 ) + ((( z / 2 ) + 1 ) * 9 ); /// x/2 because we are in a KSpace, and we want a digital offset

            /// Part to substract from previous result.
            for( KernelConstIterator itgcurrent = myMask[ offset ].first, itgend = myMask[ offset ].second; itgcurrent != itgend; ++itgcurrent )
            {
                myKSpace.sSetKCoords( shiftedSpel, myKSpace.sKCoords( *itgcurrent ) - diffSpel + shiftSpel2 );

                if( myFFunctor( shiftedSpel ) != NumberTraits< FQuantity >::ZERO )
                {
                    --m2;
                }
            }

            /// Part to add from previous result.
            for( KernelConstIterator itgcurrent = myMask[ sizeOfMasks - offset ].first, itgend = myMask[ sizeOfMasks - offset ].second; itgcurrent != itgend; ++itgcurrent )
            {
                myKSpace.sSetKCoords( shiftedSpel, myKSpace.sKCoords( *itgcurrent ) + shiftSpel2 );

                if( myFFunctor( shiftedSpel ) != NumberTraits< FQuantity >::ZERO )
                {
                    ++m2;
                }
            }
        }
    }

    /// Computation of result covariance matrix + moving
    return Quantity( m1 * lambda + m2 * ( 1.0 - lambda ));
}

template< typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator >
template< typename ConstIteratorOnCells, typename OutputIterator >
inline
void
DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, 3 >::eval
( const ConstIteratorOnCells & itbegin,
  const ConstIteratorOnCells & itend,
  OutputIterator & result )
{
    ASSERT ( isInitMask == true );

    Dimension total = 0;
#ifdef DEBUG_VERBOSE
    Dimension recount = 0;
#endif
    double lambda = 0.5;

    typedef typename KSpace::Point Point;
    typedef typename Functor::Quantity FQuantity;

    DGtal::Dimension sizeOfMasks = myMask.size() - 1;
    DGtal::Dimension positionOfFullKernel = 13;

    Quantity m1;
    Quantity m2;
    Quantity lastM1;
    Quantity lastM2;

    Spel currentSpel1, currentSpel2;
    Spel lastSpel1, lastSpel2;
    Spel shiftedSpel;

    Point shiftSpel1, shiftSpel2;
    Point diffSpel;

    bool bCanUseLastResults = false;
    bool bComputed = false; /// <! if the cell has already been computed, continue to the next

    int x, y, z, x2, y2, z2, x2y2z2;
    int offset;

    /// Iterate on all cells
    for( ConstIteratorOnCells it = itbegin; it != itend; ++it )
    {
        m1 = NumberTraits< Quantity >::ZERO; /// <! clear m1

        /// Inner cell
        {
            DGtal::Dimension kDim = myKSpace.sOrthDir( *it );
            currentSpel1 = myKSpace.sDirectIncident( *it, kDim ); /// Spel on the border, but inside the shape
            shiftSpel1 = myKSpace.sKCoords( currentSpel1 ) - myKSpace.sKCoords( myKernelSpelOrigin );

            /// Check if we can use previous results
            if( total != 0 )
            {
                bComputed = false;

                if( currentSpel1 == lastSpel1 )
                {
                    m1 = lastM1;
                    bComputed = true;
                }
                else if(  currentSpel1 == lastSpel2 )
                {
                    m1 = lastM2;
                    bComputed = true;
                }

                diffSpel = myKSpace.sKCoords( currentSpel1 ) - myKSpace.sKCoords( lastSpel1 );

                x = diffSpel[ 0 ];
                y = diffSpel[ 1 ];
                z = diffSpel[ 2 ];
                x2 = x * x;
                y2 = y * y;
                z2 = z * z;
                x2y2z2 = x2 + y2 + z2;

                if( x2y2z2 != 4 && x2y2z2 != 8 && !( x2 == 4 && y2 == 4 && z2 == 4 )) /// Previous and current cells aren't adjacent. Compute on the full kernel
                {
                    bCanUseLastResults = false;
#ifdef DEBUG_VERBOSE
                    ++recount;
#endif
                }
                else
                {
                    offset = (( x / 2 ) + 1 ) + ((( y / 2 ) + 1 ) * 3 ) + ((( z / 2 ) + 1) * 9 );
                    bCanUseLastResults = true;
                }
            }

            if( !bComputed )
            {
                if( !bCanUseLastResults ) /// Computation on full kernel, we have no previous results
                {
                    m1 = NumberTraits< Quantity >::ZERO; /// <! clear m1

                    for( KernelConstIterator itgcurrent = myItKernelBegin; itgcurrent != myItKernelEnd; ++itgcurrent )
                    {
                        myKSpace.sSetKCoords( shiftedSpel, myKSpace.sKCoords( *itgcurrent ) + shiftSpel1 );

                        ASSERT( myKSpace.sKCoords( shiftedSpel )[ 0 ] & 0x1 );
                        ASSERT( myKSpace.sKCoords( shiftedSpel )[ 1 ] & 0x1 );
                        ASSERT( myKSpace.sKCoords( shiftedSpel )[ 2 ] & 0x1 );

                        if( myFFunctor( shiftedSpel ) != NumberTraits< FQuantity >::ZERO )
                        {
                            ++m1;
                        }
                    }
                }
                else /// Using last1
                {
                    m1 = lastM1;

                    /// Part to substract from previous result.
                    for( KernelConstIterator itgcurrent = myMask[ offset ].first, itgend = myMask[ offset ].second; itgcurrent != itgend; ++itgcurrent )
                    {
                        myKSpace.sSetKCoords( shiftedSpel, myKSpace.sKCoords( *itgcurrent ) - diffSpel + shiftSpel1 );

                        if( myFFunctor( shiftedSpel ) != NumberTraits< FQuantity >::ZERO )
                        {
                            --m1;
                        }
                    }

                    /// Part to add from previous result.
                    for( KernelConstIterator itgcurrent = myMask[ sizeOfMasks - offset ].first, itgend = myMask[ sizeOfMasks - offset ].second; itgcurrent != itgend; ++itgcurrent )
                    {
                        myKSpace.sSetKCoords( shiftedSpel, myKSpace.sKCoords( *itgcurrent ) + shiftSpel1 );

                        if( myFFunctor( shiftedSpel ) != NumberTraits< FQuantity >::ZERO )
                        {
                            ++m1;
                        }
                    }
                }

                lastM1 = m1;
            }
        }

        m2 = m1;
        /// Outter cell
        {
            DGtal::Dimension kDim = myKSpace.sOrthDir( *it );
            currentSpel2 = myKSpace.sIndirectIncident( *it, kDim );
            shiftSpel2 = myKSpace.sKCoords( currentSpel2 ) - myKSpace.sKCoords( myKernelSpelOrigin );

            diffSpel = myKSpace.sKCoords( currentSpel2 ) - myKSpace.sKCoords( currentSpel1 );
            x = diffSpel[ 0 ];
            y = diffSpel[ 1 ];
            z = diffSpel[ 2 ];
            x2 = x * x;
            y2 = y * y;
            z2 = z * z;
            x2y2z2 = x2 + y2 + z2;

            if( x2y2z2 != 4 && x2y2z2 != 8 && !( x2 == 4 && y2 == 4 && z2 == 4 )) /// Inside and outside cells aren't adjacent, but should be. It's a honeypot.
            {
                trace.error() << "Error - Found that inside and outside cells aren't adjacent. That's not logic.\n";
            }
            else if( offset == positionOfFullKernel ) /// Full kernel in 3D. Never reached because case already considered before. It's a honeypot.
            {
                trace.error() << "Error - Ask to compute full kernel at the wrong moment. Maybe it's an offset computation bug ?\n";
            }
            else
            {
                offset = (( x / 2 ) + 1 ) + ((( y / 2 ) + 1 ) * 3 ) + ((( z / 2 ) + 1 ) * 9 ); /// x/2 because we are in a KSpace, and we want a digital offset

                /// Part to substract from previous result.
                for( KernelConstIterator itgcurrent = myMask[ offset ].first, itgend = myMask[ offset ].second; itgcurrent != itgend; ++itgcurrent )
                {
                    myKSpace.sSetKCoords( shiftedSpel, myKSpace.sKCoords( *itgcurrent ) - diffSpel + shiftSpel2 );

                    if( myFFunctor( shiftedSpel ) != NumberTraits< FQuantity >::ZERO )
                    {
                        --m2;
                    }
                }

                /// Part to add from previous result.
                for( KernelConstIterator itgcurrent = myMask[ sizeOfMasks - offset ].first, itgend = myMask[ sizeOfMasks - offset ].second; itgcurrent != itgend; ++itgcurrent )
                {
                    myKSpace.sSetKCoords( shiftedSpel, myKSpace.sKCoords( *itgcurrent ) + shiftSpel2 );

                    if( myFFunctor( shiftedSpel ) != NumberTraits< FQuantity >::ZERO )
                    {
                        ++m2;
                    }
                }
            }

            lastM2 = m2;
        }

        lastSpel1 = currentSpel1;
        lastSpel2 = currentSpel2;

        *result = m1 * lambda + m2 * ( 1.0 - lambda );
        ++result;

        ++total;
    }

#ifdef DEBUG_VERBOSE
    std::cout << "#total cells = " << total << std::endl;
    std::cout << "#recount = " << recount << std::endl;
#endif
}

template< typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator >
template< typename ConstIteratorOnCells, typename OutputIterator, typename Shape >
inline
void
DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, 3 >::eval
( const ConstIteratorOnCells & itbegin,
  const ConstIteratorOnCells & itend,
  OutputIterator & result,
  Shape & shape,
  const double h )
{
    ASSERT ( isInitMask == true );

    Dimension total = 0;
#ifdef DEBUG_VERBOSE
    Dimension recount = 0;
#endif

    typedef typename KSpace::Point Point;
    typedef typename Functor::Quantity FQuantity;

    DGtal::Dimension sizeOfMasks = myMask.size() - 1;
    DGtal::Dimension positionOfFullKernel = 13;

    Quantity m1;
    Quantity m2;
    Quantity lastM1;
    Quantity lastM2;

    Spel currentSpel1, currentSpel2;
    Spel lastSpel1, lastSpel2;
    Spel shiftedSpel;

    Point shiftSpel1, shiftSpel2;
    Point diffSpel;

    bool bCanUseLastResults = false;
    bool bComputed = false; /// <! if the cell has already been computed, continue to the next

    int x, y, z, x2, y2, z2, x2y2z2;
    int offset;

    /// Iterate on all cells
    for( ConstIteratorOnCells it = itbegin; it != itend; ++it )
    {
        m1 = NumberTraits< Quantity >::ZERO; /// <! clear m1

        /// Inner cell
        {
            DGtal::Dimension kDim = myKSpace.sOrthDir( *it );
            currentSpel1 = myKSpace.sDirectIncident( *it, kDim ); /// Spel on the border, but inside the shape
            shiftSpel1 = myKSpace.sKCoords( currentSpel1 ) - myKSpace.sKCoords( myKernelSpelOrigin );

            /// Check if we can use previous results
            if( total != 0 )
            {
                bComputed = false;

                if(  currentSpel1 == lastSpel1 )
                {
                    m1 = lastM1;
                    bComputed = true;
                }
                else if(  currentSpel1 == lastSpel2 )
                {
                    m1 = lastM2;
                    bComputed = true;
                }

                diffSpel = myKSpace.sKCoords( currentSpel1 ) - myKSpace.sKCoords( lastSpel1 );

                x = diffSpel[ 0 ];
                y = diffSpel[ 1 ];
                z = diffSpel[ 2 ];
                x2 = x * x;
                y2 = y * y;
                z2 = z * z;
                x2y2z2 = x2 + y2 + z2;

                if( x2y2z2 != 4 && x2y2z2 != 8 && !( x2 == 4 && y2 == 4 && z2 == 4 )) /// Previous and current cells aren't adjacent. Compute on the full kernel
                {
                    bCanUseLastResults = false;
#ifdef DEBUG_VERBOSE
                    ++recount;
#endif
                }
                else
                {
                    offset = (( x / 2 ) + 1 ) + ((( y / 2 ) + 1 ) * 3 ) + ((( z / 2 ) + 1) * 9 );
                    bCanUseLastResults = true;
                }
            }

            if( !bComputed )
            {
                if( !bCanUseLastResults ) /// Computation on full kernel, we have no previous results
                {
                    m1 = NumberTraits< Quantity >::ZERO; /// <! clear m1

                    for( KernelConstIterator itgcurrent = myItKernelBegin; itgcurrent != myItKernelEnd; ++itgcurrent )
                    {
                        myKSpace.sSetKCoords( shiftedSpel, myKSpace.sKCoords( *itgcurrent ) + shiftSpel1 );

                        ASSERT( myKSpace.sKCoords( shiftedSpel )[ 0 ] & 0x1 );
                        ASSERT( myKSpace.sKCoords( shiftedSpel )[ 1 ] & 0x1 );
                        ASSERT( myKSpace.sKCoords( shiftedSpel )[ 2 ] & 0x1 );

                        if( myFFunctor( shiftedSpel ) != NumberTraits< FQuantity >::ZERO )
                        {
                            ++m1;
                        }
                    }
                }
                else /// Using last1
                {
                    m1 = lastM1;

                    /// Part to substract from previous result.
                    for( KernelConstIterator itgcurrent = myMask[ offset ].first, itgend = myMask[ offset ].second; itgcurrent != itgend; ++itgcurrent )
                    {
                        myKSpace.sSetKCoords( shiftedSpel, myKSpace.sKCoords( *itgcurrent ) - diffSpel + shiftSpel1 );

                        if( myFFunctor( shiftedSpel ) != NumberTraits< FQuantity >::ZERO )
                        {
                            --m1;
                        }
                    }

                    /// Part to add from previous result.
                    for( KernelConstIterator itgcurrent = myMask[ sizeOfMasks - offset ].first, itgend = myMask[ sizeOfMasks - offset ].second; itgcurrent != itgend; ++itgcurrent )
                    {
                        myKSpace.sSetKCoords( shiftedSpel, myKSpace.sKCoords( *itgcurrent ) + shiftSpel1 );

                        if( myFFunctor( shiftedSpel ) != NumberTraits< FQuantity >::ZERO )
                        {
                            ++m1;
                        }
                    }
                }

                lastM1 = m1;
            }
        }

        m2 = m1;
        /// Outter cell
        {
            DGtal::Dimension kDim = myKSpace.sOrthDir( *it );
            currentSpel2 = myKSpace.sIndirectIncident( *it, kDim );
            shiftSpel2 = myKSpace.sKCoords( currentSpel2 ) - myKSpace.sKCoords( myKernelSpelOrigin );

            diffSpel = myKSpace.sKCoords( currentSpel2 ) - myKSpace.sKCoords( currentSpel1 );
            x = diffSpel[ 0 ];
            y = diffSpel[ 1 ];
            z = diffSpel[ 2 ];
            x2 = x * x;
            y2 = y * y;
            z2 = z * z;
            x2y2z2 = x2 + y2 + z2;

            if( x2y2z2 != 4 && x2y2z2 != 8 && !( x2 == 4 && y2 == 4 && z2 == 4 )) /// Inside and outside cells aren't adjacent, but should be. It's a honeypot.
            {
                trace.error() << "Error - Found that inside and outside cells aren't adjacent. That's not logic.\n";
            }
            else if( offset == positionOfFullKernel ) /// Full kernel in 3D. Never reached because case already considered before. It's a honeypot.
            {
                trace.error() << "Error - Ask to compute full kernel at the wrong moment. Maybe it's an offset computation bug ?\n";
            }
            else
            {
                offset = (( x / 2 ) + 1 ) + ((( y / 2 ) + 1 ) * 3 ) + ((( z / 2 ) + 1 ) * 9 ); /// x/2 because we are in a KSpace, and we want a digital offset

                /// Part to substract from previous result.
                for( KernelConstIterator itgcurrent = myMask[ offset ].first, itgend = myMask[ offset ].second; itgcurrent != itgend; ++itgcurrent )
                {
                    myKSpace.sSetKCoords( shiftedSpel, myKSpace.sKCoords( *itgcurrent ) - diffSpel + shiftSpel2 );

                    if( myFFunctor( shiftedSpel ) != NumberTraits< FQuantity >::ZERO )
                    {
                        --m2;
                    }
                }

                /// Part to add from previous result.
                for( KernelConstIterator itgcurrent = myMask[ sizeOfMasks - offset ].first, itgend = myMask[ sizeOfMasks - offset ].second; itgcurrent != itgend; ++itgcurrent )
                {
                    myKSpace.sSetKCoords( shiftedSpel, myKSpace.sKCoords( *itgcurrent ) + shiftSpel2 );

                    if( myFFunctor( shiftedSpel ) != NumberTraits< FQuantity >::ZERO )
                    {
                        ++m2;
                    }
                }
            }

            lastM2 = m2;
        }

        double lambda = computeShiftFromShape( shape, h, currentSpel1, currentSpel2 );

        lastSpel1 = currentSpel1;
        lastSpel2 = currentSpel2;

        *result = m1 * lambda + m2 * ( 1.0 - lambda );
        ++result;

        ++total;
    }

#ifdef DEBUG_VERBOSE
    std::cout << "#total cells = " << total << std::endl;
    std::cout << "#recount = " << recount << std::endl;
#endif
}

template< typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator >
template< typename ConstIteratorOnCells, typename OutputIterator >
inline
void
DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, 3 >::deprecated_eval
( const ConstIteratorOnCells & itbegin,
  const ConstIteratorOnCells & itend,
  OutputIterator & result )
{
    ASSERT ( isInitMask == true );

    typedef typename KSpace::Point Point;

    Spel lastCell, lastCell2, currentSpel1, currentSpel2, shiftedCell;

    Quantity lastResult = NumberTraits< Quantity >::ZERO;
    Quantity lastResult2 = NumberTraits< Quantity >::ZERO;
    Quantity currentResult1, currentResult2, maskQuantity;

    Point shiftSpel1, shiftSpel2, shiftedPoint, diffLastCurrentSpel, diffWithCurrentSpel;

    int x, y, z, x2, y2, z2, x2y2z2, offset;

    Dimension total = 0;
#ifdef DEBUG_VERBOSE
    Dimension recount = 0;
#endif

    for( ConstIteratorOnCells itcurrent = itbegin; itcurrent != itend; ++itcurrent )
    {
        currentResult1 = NumberTraits< Quantity >::ZERO;
        currentResult2 = NumberTraits< Quantity >::ZERO;

        currentSpel1 = myKSpace.sIndirectIncident( *itcurrent, *myKSpace.sOrthDirs( *itcurrent )); /// Cell on the border, but inside the shape
        currentSpel2 = myKSpace.sDirectIncident( *itcurrent, *myKSpace.sOrthDirs( *itcurrent )); /// Cell on the border, but outside the shape

        shiftSpel1 = myKSpace.sKCoords( currentSpel1 ) - myKSpace.sKCoords( myKernelSpelOrigin );
        shiftSpel2 = myKSpace.sKCoords( currentSpel2 ) - myKSpace.sKCoords( myKernelSpelOrigin );

        if(  total == 0 ) /// Computation on full kernel, we have no previous results
        {
            /// Computation for the cell inside the shape. Using full kernel.
            for(  KernelConstIterator itgcurrent = myItKernelBegin; itgcurrent != myItKernelEnd; ++itgcurrent )
            {
                myKSpace.sSetKCoords( shiftedCell, myKSpace.sKCoords( *itgcurrent ) + shiftSpel1 );

                //        DGtal::Dimension k = myKSpace->sOrthDir( aSurfel );
                //        // checks if the surfel is on the space boundary.
                //        if ( myKSpace->sIsMax( aSurfel, k ) || myKSpace->sIsMin( aSurfel, k ) )
                //        {
                //            return NumberTraits< Value >::ZERO;
                //        }

                //        typedef typename KSpace::SCell SCell;
                //        typedef typename KSpace::Point Point;

                //        SCell currentSpel = myKSpace->sDirectIncident( aSurfel, k );

                currentResult1 += myFFunctor( shiftedCell ) * myGFunctor( *itgcurrent );
            }

            /// Computation for the cell outside the shape. Using previous result and masks.
            diffWithCurrentSpel = currentSpel2.myCoordinates - currentSpel1.myCoordinates;

            x = diffWithCurrentSpel[ 0 ];
            y = diffWithCurrentSpel[ 1 ];
            z = diffWithCurrentSpel[ 2 ];
            x2 = x * x;
            y2 = y * y;
            z2 = z * z;
            x2y2z2 = x2 + y2 + z2;

            offset = (( x / 2 ) + 1 ) + ((( y / 2 ) + 1 ) * 3 ) + ((( z / 2 ) + 1 ) * 9 ); /// x/2 because we are in a KSpace, and we want a digital offset

            if(  x2y2z2 != 4 && x2y2z2 != 8 && !( x2 == 4 && y2 == 4 && z2 == 4 )) /// Inside and outside cells aren't adjacent, but should be. It's a honeypot.
            {
                trace.error() << "Error - Found that inside and outside cells aren't adjacent. That's not logic.\n";
            }
            else if(  offset == 13 ) /// Full kernel in 3D. Never reached because case already considered before. It's a honeypot.
            {
                trace.error() << "Error - Ask to compute full kernel at the wrong moment. Maybe it's an offset computation bug ?\n";
            }
            else
            {
                maskQuantity = NumberTraits< Quantity >::ZERO;

                for( KernelConstIterator itgcurrent = myMask[ offset ].first, itgend = myMask[ offset ].second; itgcurrent != itgend; ++itgcurrent )
                {
                    myKSpace.sSetKCoords( shiftedCell, myKSpace.sKCoords( *itgcurrent ) - diffWithCurrentSpel + shiftSpel2 );
                    //                    shiftedPoint = ( *itgcurrent ).myCoordinates - diffWithCurrentSpel;
                    //                    shiftedPoint += shiftSpel2;
                    //                    shiftedCell.myCoordinates = shiftedPoint;

                    maskQuantity -= myFFunctor( shiftedCell ) * myGFunctor( *itgcurrent );
                }

                for( KernelConstIterator itgcurrent = myMask[ 26 - offset ].first, itgend = myMask[ 26 - offset ].second; itgcurrent != itgend; ++itgcurrent ) /// 26 is the size of the array
                {
                    myKSpace.sSetKCoords( shiftedCell, myKSpace.sKCoords( *itgcurrent ) + shiftSpel2 );
                    //                    shiftedPoint = ( *itgcurrent ).myCoordinates;
                    //                    shiftedPoint += shiftSpel2;
                    //                    shiftedCell.myCoordinates = shiftedPoint;

                    maskQuantity += myFFunctor( shiftedCell ) * myGFunctor( *itgcurrent );
                }

                currentResult2 = currentResult1 + maskQuantity;
            }
        }
        else
        {
            /// Computation for the cell inside the shape
            if(  currentSpel1 == lastCell )
            {
                currentResult1 = lastResult;
            }
            else if(  currentSpel1 == lastCell2 )
            {
                currentResult1 = lastResult2;
            }
            else
            {
                diffLastCurrentSpel = currentSpel1.myCoordinates - lastCell.myCoordinates;

                x = diffLastCurrentSpel[ 0 ];
                y = diffLastCurrentSpel[ 1 ];
                z = diffLastCurrentSpel[ 2 ];
                x2 = x * x;
                y2 = y * y;
                z2 = z * z;
                x2y2z2 = x2 + y2 + z2;

                offset = (( x / 2 ) + 1 ) + ((( y / 2 ) + 1 ) * 3 ) + ((( z / 2 ) + 1 ) * 9 ); /// x/2 because we are in a KSpace, and we want a digital offset

                if( x2y2z2 != 4 && x2y2z2 != 8 && !( x2 == 4 && y2 == 4 && z2 == 4 )) /// Previous and current cells aren't adjacent. Compute on the full kernel
                {
#ifdef DEBUG_VERBOSE
                    ++recount;
#endif

                    for( KernelConstIterator itgcurrent = myItKernelBegin; itgcurrent != myItKernelEnd; ++itgcurrent )
                    {
                        myKSpace.sSetKCoords( shiftedCell, myKSpace.sKCoords( *itgcurrent ) + shiftSpel1 );
                        //                        shiftedPoint = ( *itgcurrent ).myCoordinates;
                        //                        shiftedPoint += shiftSpel1;
                        //                        shiftedCell.myCoordinates = shiftedPoint;

                        currentResult1 += myFFunctor( shiftedCell ) * myGFunctor( *itgcurrent );
                    }
                }
                else if( offset == 13 ) /// Full kernel in 3D. Never reached because case already considered before. It's a honeypot.
                {
                    trace.error() << "Error - Ask to compute full kernel at the wrong moment. Maybe it's an offset computation bug ?\n";
                }
                else
                {
                    maskQuantity = NumberTraits< Quantity >::ZERO;

                    /// Part to substract from previous result.
                    for(  KernelConstIterator itgcurrent = myMask[ offset ].first, itgend = myMask[ offset ].second; itgcurrent != itgend; ++itgcurrent )
                    {
                        myKSpace.sSetKCoords( shiftedCell, myKSpace.sKCoords( *itgcurrent ) - diffLastCurrentSpel + shiftSpel1 );
                        //                        shiftedPoint = ( *itgcurrent ).myCoordinates - diffLastCurrentSpel;
                        //                        shiftedPoint += shiftSpel1;
                        //                        shiftedCell.myCoordinates = shiftedPoint;

                        maskQuantity -= myFFunctor( shiftedCell ) * myGFunctor( *itgcurrent );
                    }

                    /// Part to add from previous result.
                    for(  KernelConstIterator itgcurrent = myMask[ 26 - offset ].first, itgend = myMask[ 26 - offset ].second; itgcurrent != itgend; ++itgcurrent ) /// 26 is the size of the array
                    {
                        myKSpace.sSetKCoords( shiftedCell, myKSpace.sKCoords( *itgcurrent ) + shiftSpel1 );
                        //                        shiftedPoint = ( *itgcurrent ).myCoordinates;
                        //                        shiftedPoint += shiftSpel1;
                        //                        shiftedCell.myCoordinates = shiftedPoint;

                        maskQuantity += myFFunctor( shiftedCell ) * myGFunctor( *itgcurrent );
                    }

                    currentResult1 = lastResult + maskQuantity;
                }
            }

            /// Computation for the cell outside the shape.
            if(  currentSpel2 == lastCell )
            {
                currentResult2 = lastResult;
            }
            else if(  currentSpel2 == lastCell2 )
            {
                currentResult2 = lastResult2;
            }
            else
            {
                diffWithCurrentSpel = currentSpel2.myCoordinates - currentSpel1.myCoordinates;

                x = diffWithCurrentSpel[ 0 ];
                y = diffWithCurrentSpel[ 1 ];
                z = diffWithCurrentSpel[ 2 ];
                x2 = x * x;
                y2 = y * y;
                z2 = z * z;
                x2y2z2 = x2 + y2 + z2;

                offset = (( x / 2 ) + 1 ) + ((( y / 2 ) + 1 ) * 3 ) + ((( z / 2 ) + 1 ) * 9 ); /// x/2 because we are in a KSpace, and we want a digital offset

                if(  x2y2z2 != 4 && x2y2z2 != 8 && !( x2 == 4 && y2 == 4 && z2 == 4 ))/// Inside and outside cells aren't adjacent, but should be. It's a honeypot.
                {
                    trace.error() << "Error - Found that inside and outside cells aren't adjacent. That's not logic.\n";
                }
                else if(  offset == 13 ) /// Full kernel in 2D. Never reached because case already considered before. It's a honeypot.
                {
                    trace.error() << "Error - Ask to compute full kernel at the wrong moment. Maybe it's an offset computation bug ?\n";
                }
                else
                {
                    maskQuantity = NumberTraits< Quantity >::ZERO;

                    /// Part to substract from previous result.
                    for(  KernelConstIterator itgcurrent = myMask[ offset ].first, itgend = myMask[ offset ].second; itgcurrent != itgend; ++itgcurrent )
                    {
                        myKSpace.sSetKCoords( shiftedCell, myKSpace.sKCoords( *itgcurrent ) - diffWithCurrentSpel + shiftSpel2 );
                        //                        shiftedPoint = ( *itgcurrent ).myCoordinates - diffWithCurrentSpel;
                        //                        shiftedPoint += shiftSpel2;
                        //                        shiftedCell.myCoordinates = shiftedPoint;

                        maskQuantity -= myFFunctor( shiftedCell ) * myGFunctor( *itgcurrent );
                    }

                    /// Part to add from previous result.
                    for(  KernelConstIterator itgcurrent = myMask[ 26 - offset ].first, itgend = myMask[ 26 - offset ].second; itgcurrent != itgend; ++itgcurrent ) /// 26 is the size of the array
                    {
                        myKSpace.sSetKCoords( shiftedCell, myKSpace.sKCoords( *itgcurrent ) + shiftSpel2 );
                        //                        shiftedPoint = ( *itgcurrent ).myCoordinates;
                        //                        shiftedPoint += shiftSpel2;
                        //                        shiftedCell.myCoordinates = shiftedPoint;

                        maskQuantity += myFFunctor( shiftedCell ) * myGFunctor( *itgcurrent );
                    }

                    currentResult2 = currentResult1 + maskQuantity;
                }
            }
        }

        ///////////////////////////////
        double lambda = 0.5;

        /// In order to get better results, we compute the convolution kernel centered inside and outside the spel ins the shape border, and divide the result by 2.
        *result = currentResult1 * lambda + currentResult2 * ( 1.0 - lambda );
        //        *result = ( currentResult + currentResult2 ) / Quantity( 2.0 ); /// Set the current cell result to the output iterator. (The result is the mean between inside's and outside's cell lying to the shape border).
        ++result;

        lastResult = currentResult1;
        lastResult2 = currentResult2;
        lastCell = currentSpel1;
        lastCell2 = currentSpel2;

        ++total;
    }

#ifdef DEBUG_VERBOSE
    std::cout << "#total cells = " << total << std::endl;
    std::cout << "#recount = " << recount << std::endl;
#endif
}

template< typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator >
template< typename ConstIteratorOnCells >
inline
typename DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, 3 >::CovarianceMatrix
DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, 3 >::evalCovarianceMatrix
( const ConstIteratorOnCells & it )
{
    ASSERT ( isInitMask == true );

    CovarianceMatrix innerCovarianceMatrix, outerCovarianceMatrix;

    core_evalCovarianceMatrix( it, innerCovarianceMatrix, outerCovarianceMatrix, false );

    /// Computation of result covariance matrix + moving
    double lambda = 0.5;
    return ( innerCovarianceMatrix * lambda + outerCovarianceMatrix * ( 1.0 - lambda ));
}

template< typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator >
template< typename ConstIteratorOnCells, typename Shape >
inline
typename DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, 3 >::CovarianceMatrix
DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, 3 >::evalCovarianceMatrix
( const ConstIteratorOnCells & it,
  const Shape & shape,
  const double h )
{
    ASSERT ( isInitMask == true );

    CovarianceMatrix innerCovarianceMatrix, outerCovarianceMatrix;
    Spel lastInnerSpel, lastOuterSpel;

    core_evalCovarianceMatrix( it, innerCovarianceMatrix, outerCovarianceMatrix, false, lastInnerSpel, lastOuterSpel );

    /// Computation of result covariance matrix + moving
    double lambda = computeShiftFromShape( shape, h, lastInnerSpel, lastOuterSpel );
    return ( innerCovarianceMatrix * lambda + outerCovarianceMatrix * ( 1.0 - lambda ));
}


template< typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator >
template< typename ConstIteratorOnCells, typename OutputIterator >
inline
void
DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, 3 >::evalCovarianceMatrix
( const ConstIteratorOnCells & itbegin,
  const ConstIteratorOnCells & itend,
  OutputIterator & result )
{
    ASSERT ( isInitMask == true );

    Dimension total = 0;
#ifdef DEBUG_VERBOSE
    Dimension recount = 0;
#endif

    Quantity lastInnerMoments[ nbMoments ];
    Quantity lastOuterMoments[ nbMoments ];

    CovarianceMatrix innerCovarianceMatrix, outerCovarianceMatrix;

    Spel lastInnerSpel, lastOuterSpel;

    /// Iterate on all cells
    for( ConstIteratorOnCells it = itbegin; it != itend; ++it )
    {
        if( total != 0 )
        {
#ifdef DEBUG_VERBOSE
            bool hasJumped = core_evalCovarianceMatrix( it, innerCovarianceMatrix, outerCovarianceMatrix, true, lastInnerSpel, lastOuterSpel, lastInnerMoments, lastOuterMoments );
            recount = ( hasJumped ) ? recount + 1 : recount;
#else
            core_evalCovarianceMatrix( it, innerCovarianceMatrix, outerCovarianceMatrix, true, lastInnerSpel, lastOuterSpel, lastInnerMoments, lastOuterMoments );
#endif
        }
        else
        {
            core_evalCovarianceMatrix( it, innerCovarianceMatrix, outerCovarianceMatrix, false, lastInnerSpel, lastOuterSpel, lastInnerMoments, lastOuterMoments );
        }

        /// Computation of result covariance matrix + moving
        double lambda = 0.5;
        *result = innerCovarianceMatrix * lambda + outerCovarianceMatrix * ( 1.0 - lambda );
        ++result;

        ++total;
    }

#ifdef DEBUG_VERBOSE
    std::cout << "#total cells = " << total << std::endl;
    std::cout << "#recount = " << recount << std::endl;
#endif
}

template< typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator >
template< typename ConstIteratorOnCells, typename OutputIterator, typename Shape >
inline
void
DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, 3 >::evalCovarianceMatrix
( const ConstIteratorOnCells & itbegin,
  const ConstIteratorOnCells & itend,
  OutputIterator & result,
  const Shape & shape,
  const double h )
{
    ASSERT ( isInitMask == true );

    Dimension total = 0;
#ifdef DEBUG_VERBOSE
    Dimension recount = 0;
#endif

    Quantity lastInnerMoments[ nbMoments ];
    Quantity lastOuterMoments[ nbMoments ];

    CovarianceMatrix innerCovarianceMatrix, outerCovarianceMatrix;

    Spel lastInnerSpel, lastOuterSpel;

    /// Iterate on all cells
    for( ConstIteratorOnCells it = itbegin; it != itend; ++it )
    {
        if( total != 0 )
        {
#ifdef DEBUG_VERBOSE
            bool hasJumped = core_evalCovarianceMatrix( it, innerCovarianceMatrix, outerCovarianceMatrix, true, lastInnerSpel, lastOuterSpel, lastInnerMoments, lastOuterMoments );
            recount = ( hasJumped ) ? recount + 1 : recount;
#else
            core_evalCovarianceMatrix( it, innerCovarianceMatrix, outerCovarianceMatrix, true, lastInnerSpel, lastOuterSpel, lastInnerMoments, lastOuterMoments );
#endif
        }
        else
        {
            core_evalCovarianceMatrix( it, innerCovarianceMatrix, outerCovarianceMatrix, false, lastInnerSpel, lastOuterSpel, lastInnerMoments, lastOuterMoments );
        }

        /// Computation of result covariance matrix + moving
        double lambda = computeShiftFromShape( shape, h, lastInnerSpel, lastOuterSpel );
        *result = innerCovarianceMatrix * lambda + outerCovarianceMatrix * ( 1.0 - lambda );
        ++result;

        ++total;
    }

#ifdef DEBUG_VERBOSE
    std::cout << "#total cells = " << total << std::endl;
    std::cout << "#recount = " << recount << std::endl;
#endif
}

/*
template< typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator >
template< typename ConstIteratorOnCells >
inline
typename DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, 3 >::CovarianceMatrix
DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, 3 >::evalCovarianceMatrix
( const ConstIteratorOnCells & it )
{
    ASSERT ( isInitMask == true );

    typedef typename KSpace::Point Point;
    typedef typename Functor::Quantity FQuantity;

    double lambda = 0.5;

    DGtal::Dimension sizeMoments = 10;
    DGtal::Dimension sizeOfMasks = myMask.size() - 1;
    DGtal::Dimension positionOfFullKernel = 13;

    Quantity m[ sizeMoments ]; /// <! [ m000, m001, m010, m100, m011, m101, m110, m002, m020, m200 ]
    CovarianceMatrix Ja1, Ja2;

    Spel currentSpel1, currentSpel2;
    Spel shiftedSpel;

    Point shiftSpel1, shiftSpel2;
    Point diffSpel;

    SCellToInnerPoint< KSpace > SCellToPoint( myKSpace );

    int x, y, z, x2, y2, z2, x2y2z2;
    int offset;

    std::fill( m, m + sizeMoments, NumberTraits< Quantity >::ZERO ); /// <! clear array

    /// Inner cell
    {
        DGtal::Dimension kDim = myKSpace.sOrthDir( *it );
        currentSpel1 = myKSpace.sDirectIncident( *it, kDim ); /// Spel on the border, but inside the shape
        shiftSpel1 = myKSpace.sKCoords( currentSpel1 ) - myKSpace.sKCoords( myKernelSpelOrigin );

        std::fill( m, m + sizeMoments, NumberTraits< Quantity >::ZERO ); /// <! clear array

        for( KernelConstIterator itgcurrent = myItKernelBegin; itgcurrent != myItKernelEnd; ++itgcurrent )
        {
            myKSpace.sSetKCoords( shiftedSpel, myKSpace.sKCoords( *itgcurrent ) + shiftSpel1 );

            ASSERT( myKSpace.sKCoords( shiftedSpel )[ 0 ] & 0x1 );
            ASSERT( myKSpace.sKCoords( shiftedSpel )[ 1 ] & 0x1 );
            ASSERT( myKSpace.sKCoords( shiftedSpel )[ 2 ] & 0x1 );

            if( myFFunctor( shiftedSpel ) != NumberTraits< FQuantity >::ZERO )
            {
                fillMoments( m, SCellToPoint( shiftedSpel ), 1.0 );
            }
        }

        /// Computation of covariance Matrix
        computeCovarianceMatrix( m, Ja1 );
    }

    /// Outter cell
    {
        DGtal::Dimension kDim = myKSpace.sOrthDir( *it );
        currentSpel2 = myKSpace.sIndirectIncident( *it, kDim );
        shiftSpel2 = myKSpace.sKCoords( currentSpel2 ) - myKSpace.sKCoords( myKernelSpelOrigin );

        diffSpel = myKSpace.sKCoords( currentSpel2 ) - myKSpace.sKCoords( currentSpel1 );
        x = diffSpel[ 0 ];
        y = diffSpel[ 1 ];
        z = diffSpel[ 2 ];
        x2 = x * x;
        y2 = y * y;
        z2 = z * z;
        x2y2z2 = x2 + y2 + z2;


        if(  x2y2z2 != 4 && x2y2z2 != 8 && !( x2 == 4 && y2 == 4 && z2 == 4 )) /// Inside and outside cells aren't adjacent, but should be. It's a honeypot.
        {
            trace.error() << "Error - Found that inside and outside cells aren't adjacent. That's not logic.\n";
        }
        else if(  offset == positionOfFullKernel ) /// Full kernel in 3D. Never reached because case already considered before. It's a honeypot.
        {
            trace.error() << "Error - Ask to compute full kernel at the wrong moment. Maybe it's an offset computation bug ?\n";
        }
        else
        {
            offset = (( x / 2 ) + 1 ) + ((( y / 2 ) + 1 ) * 3 ) + ((( z / 2 ) + 1 ) * 9 ); /// x/2 because we are in a KSpace, and we want a digital offset

            /// Part to substract from previous result.
            for( KernelConstIterator itgcurrent = myMask[ offset ].first, itgend = myMask[ offset ].second; itgcurrent != itgend; ++itgcurrent )
            {
                myKSpace.sSetKCoords( shiftedSpel, myKSpace.sKCoords( *itgcurrent ) - diffSpel + shiftSpel2 );

                if( myFFunctor( shiftedSpel ) != NumberTraits< FQuantity >::ZERO )
                {
                    fillMoments( m, SCellToPoint( shiftedSpel ), -1.0 );
                }
            }

            /// Part to add from previous result.
            for( KernelConstIterator itgcurrent = myMask[ sizeOfMasks - offset ].first, itgend = myMask[ sizeOfMasks - offset ].second; itgcurrent != itgend; ++itgcurrent )
            {
                myKSpace.sSetKCoords( shiftedSpel, myKSpace.sKCoords( *itgcurrent ) + shiftSpel2 );

                if( myFFunctor( shiftedSpel ) != NumberTraits< FQuantity >::ZERO )
                {
                    fillMoments( m, SCellToPoint( shiftedSpel ), 1.0 );
                }
            }
        }

        computeCovarianceMatrix( m, Ja2 );
    }

    /// Computation of result covariance matrix + moving
    return CovarianceMatrix( Ja1 * lambda + Ja2 * ( 1.0 - lambda ));
}

template< typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator >
template< typename ConstIteratorOnCells, typename OutputIterator >
inline
void
DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, 3 >::evalCovarianceMatrix
( const ConstIteratorOnCells & itbegin,
  const ConstIteratorOnCells & itend,
  OutputIterator & result )
{
    ASSERT ( isInitMask == true );

    Dimension total = 0;
#ifdef DEBUG_VERBOSE
    Dimension recount = 0;
#endif

    typedef typename KSpace::Point Point;
    typedef typename Functor::Quantity FQuantity;

    DGtal::Dimension sizeMoments = 10;
    DGtal::Dimension sizeOfMasks = myMask.size() - 1;
    DGtal::Dimension positionOfFullKernel = 13;

    Quantity m[ sizeMoments ]; /// <! [ m000, m001, m010, m100, m011, m101, m110, m002, m020, m200 ]
    Quantity lastM1[ sizeMoments ];
    Quantity lastM2[ sizeMoments ];

    Quantity tempM1[ sizeMoments ];
    Quantity tempM2[ sizeMoments ];

    CovarianceMatrix Ja1, Ja2;
    CovarianceMatrix lastJa1, lastJa2;

    Spel currentSpel1, currentSpel2;
    Spel lastSpel1, lastSpel2;
    Spel shiftedSpel;

    Point shiftSpel1, shiftSpel2;
    Point diffSpel;

//    CanonicSCellEmbedder< KSpace > SCellToPoint( myKSpace );
//    SCellToInnerPoint< KSpace > SCellToPoint( myKSpace );

    bool bCanUseLastResults = false;
    bool bComputed = false; /// <! if the cell has already been computed, continue to the next

    int x, y, z, x2, y2, z2, x2y2z2;
    int offset;

    /// Iterate on all cells
    for( ConstIteratorOnCells it = itbegin; it != itend; ++it )
    {
        std::fill( m, m + sizeMoments, NumberTraits< Quantity >::ZERO ); /// <! clear array

        /// Inner cell
        {
            DGtal::Dimension kDim = myKSpace.sOrthDir( *it );
            currentSpel1 = myKSpace.sDirectIncident( *it, kDim ); /// Spel on the border, but inside the shape
            shiftSpel1 = myKSpace.sKCoords( currentSpel1 ) - myKSpace.sKCoords( myKernelSpelOrigin );

            /// Check if we can use previous results
            if( total != 0 )
            {
                bComputed = false;

                if(  currentSpel1 == lastSpel1 )
                {
                    memcpy( m, lastM1, sizeMoments * sizeof( Quantity ));
                    Ja1 = lastJa1;
                    bComputed = true;
                }
                else if(  currentSpel1 == lastSpel2 )
                {
                    memcpy( m, lastM2, sizeMoments * sizeof( Quantity ));
                    Ja1 = lastJa2;
                    bComputed = true;
                }

                diffSpel = myKSpace.sKCoords( currentSpel1 ) - myKSpace.sKCoords( lastSpel1 );

                x = diffSpel[ 0 ];
                y = diffSpel[ 1 ];
                z = diffSpel[ 2 ];
                x2 = x * x;
                y2 = y * y;
                z2 = z * z;
                x2y2z2 = x2 + y2 + z2;

                if( x2y2z2 != 4 && x2y2z2 != 8 && !( x2 == 4 && y2 == 4 && z2 == 4 )) /// Previous and current cells aren't adjacent. Compute on the full kernel
                {
                    bCanUseLastResults = false;
#ifdef DEBUG_VERBOSE
                    ++recount;
#endif
                }
                else
                {
                    offset = (( x / 2 ) + 1 ) + ((( y / 2 ) + 1 ) * 3 ) + ((( z / 2 ) + 1) * 9 );
                    bCanUseLastResults = true;
                }
            }

            if( !bComputed )
            {
                if( !bCanUseLastResults ) /// Computation on full kernel, we have no previous results
                {
                    std::fill( m, m + sizeMoments, NumberTraits< Quantity >::ZERO ); /// <! clear array

                    for( KernelConstIterator itgcurrent = myItKernelBegin; itgcurrent != myItKernelEnd; ++itgcurrent )
                    {
                        myKSpace.sSetKCoords( shiftedSpel, myKSpace.sKCoords( *itgcurrent ) + shiftSpel1 );

                        ASSERT( myKSpace.sKCoords( shiftedSpel )[ 0 ] & 0x1 );
                        ASSERT( myKSpace.sKCoords( shiftedSpel )[ 1 ] & 0x1 );
                        ASSERT( myKSpace.sKCoords( shiftedSpel )[ 2 ] & 0x1 );

                        if( myFFunctor( shiftedSpel ) != NumberTraits< FQuantity >::ZERO )
                        {
                            fillMoments( m, myKSpace.sCoords( shiftedSpel ), 1.0 );
                        }
                    }
                }
                else /// Using last1
                {
                    memcpy( m, lastM1, sizeMoments * sizeof( Quantity ));

                    /// Part to substract from previous result.
                    for( KernelConstIterator itgcurrent = myMask[ offset ].first, itgend = myMask[ offset ].second; itgcurrent != itgend; ++itgcurrent )
                    {
                        myKSpace.sSetKCoords( shiftedSpel, myKSpace.sKCoords( *itgcurrent ) - diffSpel + shiftSpel1 );

                        if( myFFunctor( shiftedSpel ) != NumberTraits< FQuantity >::ZERO )
                        {
                            fillMoments( m, myKSpace.sCoords( shiftedSpel ), -1.0 );
                        }
                    }

                    /// Part to add from previous result.
                    for( KernelConstIterator itgcurrent = myMask[ sizeOfMasks - offset ].first, itgend = myMask[ sizeOfMasks - offset ].second; itgcurrent != itgend; ++itgcurrent )
                    {
                        myKSpace.sSetKCoords( shiftedSpel, myKSpace.sKCoords( *itgcurrent ) + shiftSpel1 );

                        if( myFFunctor( shiftedSpel ) != NumberTraits< FQuantity >::ZERO )
                        {
                            fillMoments( m, myKSpace.sCoords( shiftedSpel ), 1.0 );
                        }
                    }
                }

                /// Computation of covariance Matrix
                computeCovarianceMatrix( m, Ja1 );

                memcpy( lastM1, m, sizeMoments * sizeof( Quantity ));
                memcpy( tempM1, m, sizeMoments * sizeof( Quantity ));
                lastJa1 = Ja1;
            }
        }

        /// Outter cell
        {
            DGtal::Dimension kDim = myKSpace.sOrthDir( *it );
            currentSpel2 = myKSpace.sIndirectIncident( *it, kDim );
            shiftSpel2 = myKSpace.sKCoords( currentSpel2 ) - myKSpace.sKCoords( myKernelSpelOrigin );

            diffSpel = myKSpace.sKCoords( currentSpel2 ) - myKSpace.sKCoords( currentSpel1 );
            x = diffSpel[ 0 ];
            y = diffSpel[ 1 ];
            z = diffSpel[ 2 ];
            x2 = x * x;
            y2 = y * y;
            z2 = z * z;
            x2y2z2 = x2 + y2 + z2;


            if(  x2y2z2 != 4 && x2y2z2 != 8 && !( x2 == 4 && y2 == 4 && z2 == 4 )) /// Inside and outside cells aren't adjacent, but should be. It's a honeypot.
            {
                trace.error() << "Error - Found that inside and outside cells aren't adjacent. That's not logic.\n";
            }
            else if(  offset == positionOfFullKernel ) /// Full kernel in 3D. Never reached because case already considered before. It's a honeypot.
            {
                trace.error() << "Error - Ask to compute full kernel at the wrong moment. Maybe it's an offset computation bug ?\n";
            }
            else
            {
                offset = (( x / 2 ) + 1 ) + ((( y / 2 ) + 1 ) * 3 ) + ((( z / 2 ) + 1 ) * 9 ); /// x/2 because we are in a KSpace, and we want a digital offset

                /// Part to substract from previous result.
                for( KernelConstIterator itgcurrent = myMask[ offset ].first, itgend = myMask[ offset ].second; itgcurrent != itgend; ++itgcurrent )
                {
                    myKSpace.sSetKCoords( shiftedSpel, myKSpace.sKCoords( *itgcurrent ) - diffSpel + shiftSpel2 );

                    if( myFFunctor( shiftedSpel ) != NumberTraits< FQuantity >::ZERO )
                    {
                        fillMoments( m, myKSpace.sCoords( shiftedSpel ), -1.0 );
                    }
                }

                /// Part to add from previous result.
                for( KernelConstIterator itgcurrent = myMask[ sizeOfMasks - offset ].first, itgend = myMask[ sizeOfMasks - offset ].second; itgcurrent != itgend; ++itgcurrent )
                {
                    myKSpace.sSetKCoords( shiftedSpel, myKSpace.sKCoords( *itgcurrent ) + shiftSpel2 );

                    if( myFFunctor( shiftedSpel ) != NumberTraits< FQuantity >::ZERO )
                    {
                        fillMoments( m, myKSpace.sCoords( shiftedSpel ), 1.0 );
                    }
                }
            }

            computeCovarianceMatrix( m, Ja2 );

            memcpy( lastM2, m, sizeMoments * sizeof( Quantity ));
            memcpy( tempM2, m, sizeMoments * sizeof( Quantity ));
            lastJa2 = Ja2;
        }

        double lambda = 0.5;

        lastSpel1 = currentSpel1;
        lastSpel2 = currentSpel2;

        ASSERT (( lastM1[ 0 ] != lastM2[ 0 ] )); // Maybe a problem here. Can be normal ... but needs to check twice.

        /// Computation of result covariance matrix + moving
        *result = Ja1 * lambda + Ja2 * ( 1.0 - lambda );
        ++result;

        ++total;
    }

#ifdef DEBUG_VERBOSE
    std::cout << "#total cells = " << total << std::endl;
    std::cout << "#recount = " << recount << std::endl;
#endif
}

template< typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator >
template< typename ConstIteratorOnCells, typename OutputIterator, typename Shape >
inline
void
DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, 3 >::evalCovarianceMatrix
( const ConstIteratorOnCells & itbegin,
  const ConstIteratorOnCells & itend,
  OutputIterator & result,
  const Shape & shape,
  const double h )
{
    ASSERT ( isInitMask == true );

    Dimension total = 0;
#ifdef DEBUG_VERBOSE
    Dimension recount = 0;
#endif

    typedef typename KSpace::Point Point;
    typedef typename Functor::Quantity FQuantity;

    DGtal::Dimension sizeMoments = 10;
    DGtal::Dimension sizeOfMasks = myMask.size() - 1;
    DGtal::Dimension positionOfFullKernel = 13;

    Quantity m[ sizeMoments ]; /// <! [ m000, m001, m010, m100, m011, m101, m110, m002, m020, m200 ]
    Quantity lastM1[ sizeMoments ];
    Quantity lastM2[ sizeMoments ];

    CovarianceMatrix Ja1, Ja2;
    CovarianceMatrix lastJa1, lastJa2;

    Spel currentSpel1, currentSpel2;
    Spel lastSpel1, lastSpel2;
    Spel shiftedSpel;

    Point shiftSpel1, shiftSpel2;
    Point diffSpel;

//    CanonicSCellEmbedder< KSpace > SCellToPoint( myKSpace );
//    SCellToInnerPoint< KSpace > SCellToPoint( myKSpace );

    bool bCanUseLastResults = false;
    bool bComputed = false; /// <! if the cell has already been computed, continue to the next

    int x, y, z, x2, y2, z2, x2y2z2;
    int offset;

    CovarianceMatrix _Ja1, _Ja2;
    Spel _lastSpel1, _lastSpel2;
    Quantity _lastM1[ sizeMoments ];
    Quantity _lastM2[ sizeMoments ];

    /// Iterate on all cells
    for( ConstIteratorOnCells it = itbegin; it != itend; ++it )
    {
//        core_evalCovarianceMatrix( it, Ja1, Ja2);

        if( total != 0 )
            core_evalCovarianceMatrix( it, _Ja1, _Ja2, true, _lastSpel1, _lastSpel2, _lastM1, _lastM2 );
        else
            core_evalCovarianceMatrix( it, _Ja1, _Ja2, false, _lastSpel1, _lastSpel2, _lastM1, _lastM2 );

        std::fill( m, m + sizeMoments, NumberTraits< Quantity >::ZERO ); /// <! clear array

        /// Inner cell
        {
            DGtal::Dimension kDim = myKSpace.sOrthDir( *it );
            currentSpel1 = myKSpace.sDirectIncident( *it, kDim ); /// Spel on the border, but inside the shape
            shiftSpel1 = myKSpace.sKCoords( currentSpel1 ) - myKSpace.sKCoords( myKernelSpelOrigin );

            /// Check if we can use previous results
            if( total != 0 )
            {
                bComputed = false;

                if(  currentSpel1 == lastSpel1 )
                {
                    memcpy( m, lastM1, sizeMoments * sizeof( Quantity ));
                    Ja1 = lastJa1;
                    bComputed = true;
                }
                else if(  currentSpel1 == lastSpel2 )
                {
                    memcpy( m, lastM2, sizeMoments * sizeof( Quantity ));
                    Ja1 = lastJa2;
                    bComputed = true;
                }

                diffSpel = myKSpace.sKCoords( currentSpel1 ) - myKSpace.sKCoords( lastSpel1 );

                x = diffSpel[ 0 ];
                y = diffSpel[ 1 ];
                z = diffSpel[ 2 ];
                x2 = x * x;
                y2 = y * y;
                z2 = z * z;
                x2y2z2 = x2 + y2 + z2;

                if( x2y2z2 != 4 && x2y2z2 != 8 && !( x2 == 4 && y2 == 4 && z2 == 4 )) /// Previous and current cells aren't adjacent. Compute on the full kernel
                {
                    bCanUseLastResults = false;
#ifdef DEBUG_VERBOSE
                    ++recount;
#endif
                }
                else
                {
                    offset = (( x / 2 ) + 1 ) + ((( y / 2 ) + 1 ) * 3 ) + ((( z / 2 ) + 1) * 9 );
                    bCanUseLastResults = true;
                }
            }

            if( !bComputed )
            {
                if( !bCanUseLastResults ) /// Computation on full kernel, we have no previous results
                {
                    std::fill( m, m + sizeMoments, NumberTraits< Quantity >::ZERO ); /// <! clear array

                    for( KernelConstIterator itgcurrent = myItKernelBegin; itgcurrent != myItKernelEnd; ++itgcurrent )
                    {
                        myKSpace.sSetKCoords( shiftedSpel, myKSpace.sKCoords( *itgcurrent ) + shiftSpel1 );

                        ASSERT( myKSpace.sKCoords( shiftedSpel )[ 0 ] & 0x1 );
                        ASSERT( myKSpace.sKCoords( shiftedSpel )[ 1 ] & 0x1 );
                        ASSERT( myKSpace.sKCoords( shiftedSpel )[ 2 ] & 0x1 );

                        if( myFFunctor( shiftedSpel ) != NumberTraits< FQuantity >::ZERO )
                        {
                            fillMoments( m, myKSpace.sCoords( shiftedSpel ), 1.0 );
                        }
                    }
                }
                else /// Using last1
                {
                    memcpy( m, lastM1, sizeMoments * sizeof( Quantity ));

                    /// Part to substract from previous result.
                    for( KernelConstIterator itgcurrent = myMask[ offset ].first, itgend = myMask[ offset ].second; itgcurrent != itgend; ++itgcurrent )
                    {
                        myKSpace.sSetKCoords( shiftedSpel, myKSpace.sKCoords( *itgcurrent ) - diffSpel + shiftSpel1 );

                        if( myFFunctor( shiftedSpel ) != NumberTraits< FQuantity >::ZERO )
                        {
                            fillMoments( m, myKSpace.sCoords( shiftedSpel ), -1.0 );
                        }
                    }

                    /// Part to add from previous result.
                    for( KernelConstIterator itgcurrent = myMask[ sizeOfMasks - offset ].first, itgend = myMask[ sizeOfMasks - offset ].second; itgcurrent != itgend; ++itgcurrent )
                    {
                        myKSpace.sSetKCoords( shiftedSpel, myKSpace.sKCoords( *itgcurrent ) + shiftSpel1 );

                        if( myFFunctor( shiftedSpel ) != NumberTraits< FQuantity >::ZERO )
                        {
                            fillMoments( m, myKSpace.sCoords( shiftedSpel ), 1.0 );
                        }
                    }
                }

                /// Computation of covariance Matrix
                computeCovarianceMatrix( m, Ja1 );

                memcpy( lastM1, m, sizeMoments * sizeof( Quantity ));

                lastJa1 = Ja1;
            }
        }

        /// Outter cell
        {
            DGtal::Dimension kDim = myKSpace.sOrthDir( *it );
            currentSpel2 = myKSpace.sIndirectIncident( *it, kDim );
            shiftSpel2 = myKSpace.sKCoords( currentSpel2 ) - myKSpace.sKCoords( myKernelSpelOrigin );

            diffSpel = myKSpace.sKCoords( currentSpel2 ) - myKSpace.sKCoords( currentSpel1 );
            x = diffSpel[ 0 ];
            y = diffSpel[ 1 ];
            z = diffSpel[ 2 ];
            x2 = x * x;
            y2 = y * y;
            z2 = z * z;
            x2y2z2 = x2 + y2 + z2;


            if(  x2y2z2 != 4 && x2y2z2 != 8 && !( x2 == 4 && y2 == 4 && z2 == 4 )) /// Inside and outside cells aren't adjacent, but should be. It's a honeypot.
            {
                trace.error() << "Error - Found that inside and outside cells aren't adjacent. That's not logic.\n";
            }
            else if(  offset == positionOfFullKernel ) /// Full kernel in 3D. Never reached because case already considered before. It's a honeypot.
            {
                trace.error() << "Error - Ask to compute full kernel at the wrong moment. Maybe it's an offset computation bug ?\n";
            }
            else
            {
                offset = (( x / 2 ) + 1 ) + ((( y / 2 ) + 1 ) * 3 ) + ((( z / 2 ) + 1 ) * 9 ); /// x/2 because we are in a KSpace, and we want a digital offset

                /// Part to substract from previous result.
                for( KernelConstIterator itgcurrent = myMask[ offset ].first, itgend = myMask[ offset ].second; itgcurrent != itgend; ++itgcurrent )
                {
                    myKSpace.sSetKCoords( shiftedSpel, myKSpace.sKCoords( *itgcurrent ) - diffSpel + shiftSpel2 );

                    if( myFFunctor( shiftedSpel ) != NumberTraits< FQuantity >::ZERO )
                    {
                        fillMoments( m, myKSpace.sCoords( shiftedSpel ), -1.0 );
                    }
                }

                /// Part to add from previous result.
                for( KernelConstIterator itgcurrent = myMask[ sizeOfMasks - offset ].first, itgend = myMask[ sizeOfMasks - offset ].second; itgcurrent != itgend; ++itgcurrent )
                {
                    myKSpace.sSetKCoords( shiftedSpel, myKSpace.sKCoords( *itgcurrent ) + shiftSpel2 );

                    if( myFFunctor( shiftedSpel ) != NumberTraits< FQuantity >::ZERO )
                    {
                        fillMoments( m, myKSpace.sCoords( shiftedSpel ), 1.0 );
                    }
                }
            }

            computeCovarianceMatrix( m, Ja2 );

            memcpy( lastM2, m, sizeMoments * sizeof( Quantity ));

            lastJa2 = Ja2;
        }

        double lambda = computeShiftFromShape( shape, h, currentSpel1, currentSpel2 );

        lastSpel1 = currentSpel1;
        lastSpel2 = currentSpel2;

        ASSERT (( lastM1[ 0 ] != lastM2[ 0 ] )); // Maybe a problem here. Can be normal ... but needs to check twice.

        /// Computation of result covariance matrix + moving
        *result = _Ja1 * lambda + _Ja2 * ( 1.0 - lambda );
        ++result;

        ++total;

        if( Ja1 == _Ja1 )
            continue;
        else
            std::cout << "error" << std::endl;
        if( Ja2 == _Ja2 )
            continue;
        else
            std::cout << "error" << std::endl;
    }

#ifdef DEBUG_VERBOSE
    std::cout << "#total cells = " << total << std::endl;
    std::cout << "#recount = " << recount << std::endl;
#endif

}

*/

template< typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator >
template< typename ConstIteratorOnCells, typename OutputIterator >
inline
void
DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, 3 >::deprecated_evalCovarianceMatrix
( const ConstIteratorOnCells & itbegin,
  const ConstIteratorOnCells & itend,
  OutputIterator & result )
{
    ASSERT ( isInitMask == true );

    typedef typename KSpace::Point Point;
    typedef typename Functor::Quantity FQuantity;

    Spel lastCell, currentCell, shiftedCell;
    Spel lastCell2, currentCell2;

    Quantity lastVa, currentVa, maskVa;
    Quantity lastVa2, currentVa2;

    double dcurrentVa, currentOne_Va, dcurrentJa;
    double dcurrentVa2, currentOne_Va2, dcurrentJa2;

    CovarianceMatrix Ja;

    MatrixQuantity lastXXT, currentXXT, maskXXT;
    MatrixQuantity lastXXT2, currentXXT2;

    VectorQuantity lastSa, currentSa, maskSa;
    VectorQuantity lastSa2, currentSa2;

    Point shift, shiftedPoint, diffLastCurrentCell; /// @todo change to Cell
    Point shift2, diffWithCurrentCell;
    Point currentPoint;

    FQuantity fShiftedCell;

    int x, y, z, x2, y2, z2, x2y2z2, offset;

    SCellToMidPoint< KSpace > midpoint( myKSpace );

    Dimension total = 0;
#ifdef DEBUG_VERBOSE
    Dimension recount = 0;
#endif

    for( ConstIteratorOnCells itcurrent = itbegin; itcurrent != itend; ++itcurrent )
    {
        Ja.constant( NumberTraits< Quantity >::ZERO );
        currentXXT.constant( NumberTraits< Quantity >::ZERO );
        currentXXT2.constant( NumberTraits< Quantity >::ZERO );
        currentSa.reset();
        currentSa2.reset();
        currentVa = NumberTraits< Quantity >::ZERO;
        currentVa2 = NumberTraits< Quantity >::ZERO;

        currentCell = myKSpace.sIndirectIncident( *itcurrent, *myKSpace.sOrthDirs( *itcurrent )); /// Cell on the border, but inside the shape
        currentCell2 = myKSpace.sDirectIncident( *itcurrent, *myKSpace.sOrthDirs( *itcurrent )); /// Cell on the border, but outside the shape

        shift = currentCell.myCoordinates - myKernelSpelOrigin.myCoordinates;
        shift2 = currentCell2.myCoordinates - myKernelSpelOrigin.myCoordinates;

        if( total == 0 ) /// Computation on full kernel, we have no previous results
        {
            /// Computation for the cell inside the shape. Using full kernel.
            for( KernelConstIterator itgcurrent = myItKernelBegin; itgcurrent != myItKernelEnd; ++itgcurrent )
            {
                shiftedPoint = ( *itgcurrent ).myCoordinates;
                shiftedPoint += shift;
                shiftedCell.myCoordinates = shiftedPoint;

                fShiftedCell = myFFunctor( shiftedCell );

                if( fShiftedCell != NumberTraits< FQuantity >::ZERO )
                {
                    currentPoint = midpoint( shiftedCell );

                    for( Dimension line = 0; line < dimension; ++line )
                    {
                        for( Dimension column = 0; column < dimension; ++column )
                        {
                            currentXXT.setComponent( line, column, currentXXT( line, column ) + fShiftedCell * currentPoint[ line ] * currentPoint[ column ]);
                        }
                        currentSa[ line ] += fShiftedCell * currentPoint[ line ];
                    }
                    currentVa += fShiftedCell * myGFunctor( *itgcurrent );
                }
            }

            /// Computation for the cell outside the shape. Using previous result and masks.
            diffWithCurrentCell = currentCell2.myCoordinates - currentCell.myCoordinates;

            x = diffWithCurrentCell[ 0 ];
            y = diffWithCurrentCell[ 1 ];
            z = diffWithCurrentCell[ 2 ];
            x2 = x * x;
            y2 = y * y;
            z2 = z * z;
            x2y2z2 = x2 + y2 + z2;

            offset = (( x / 2 ) + 1 ) + ((( y / 2 ) + 1 ) * 3 ) + ((( z / 2 ) + 1 ) * 9 ); /// x/2 because we are in a KSpace, and we want a digital offset

            if( x2y2z2 != 4 && x2y2z2 != 8 && !( x2 == 4 && y2 == 4 && z2 == 4 )) /// Inside and outside cells aren't adjacent, but should be. It's a honeypot.
            {
                trace.error() << "Error - Found that inside and outside cells aren't adjacent. That's not logic.\n";
            }
            else if( offset == 13 ) /// Full kernel in 3D. Never reached because case already considered before. It's a honeypot.
            {
                trace.error() << "Error - Ask to compute full kernel at the wrong moment. Maybe it's an offset computation bug ?\n";
            }
            else
            {
                maskVa = NumberTraits< Quantity >::ZERO;
                maskXXT.constant( NumberTraits< Quantity >::ZERO );
                maskSa.reset();

                /// Part to substract from previous result.
                for( KernelConstIterator itgcurrent = myMask[ offset ].first, itgend = myMask[ offset ].second; itgcurrent != itgend; ++itgcurrent )
                {
                    shiftedPoint = ( *itgcurrent ).myCoordinates - diffWithCurrentCell;
                    shiftedPoint += shift2;
                    shiftedCell.myCoordinates = shiftedPoint;

                    fShiftedCell = myFFunctor( shiftedCell );

                    if( fShiftedCell != NumberTraits< FQuantity >::ZERO )
                    {
                        currentPoint = midpoint( shiftedCell );

                        for( Dimension line = 0; line < dimension; ++line )
                        {
                            for( Dimension column = 0; column < dimension; ++column )
                            {
                                maskXXT.setComponent( line, column, maskXXT( line, column ) - fShiftedCell * currentPoint[ line ] * currentPoint[ column ]);
                            }
                            maskSa[ line ] -= fShiftedCell * currentPoint[ line ];
                        }
                        maskVa -= fShiftedCell * myGFunctor( *itgcurrent );
                    }
                }

                /// Part to add from previous result.
                for( KernelConstIterator itgcurrent = myMask[ 26 - offset ].first, itgend = myMask[ 26 - offset ].second; itgcurrent != itgend; ++itgcurrent )
                {
                    shiftedPoint = ( *itgcurrent ).myCoordinates;
                    shiftedPoint += shift2;
                    shiftedCell.myCoordinates = shiftedPoint;

                    fShiftedCell = myFFunctor( shiftedCell );

                    if( fShiftedCell != NumberTraits< FQuantity >::ZERO )
                    {
                        currentPoint = midpoint( shiftedCell );

                        for( Dimension line = 0; line < dimension; ++line )
                        {
                            for( Dimension column = 0; column < dimension; ++column )
                            {
                                maskXXT.setComponent( line, column, maskXXT( line, column ) + fShiftedCell * currentPoint[ line ] * currentPoint[ column ]);
                            }
                            maskSa[ line ] += fShiftedCell * currentPoint[ line ];
                        }
                        maskVa += fShiftedCell * myGFunctor( *itgcurrent );
                    }
                }

                for( Dimension line = 0; line < dimension; ++line )
                {
                    for( Dimension column = 0; column < dimension; ++column )
                    {
                        currentXXT2.setComponent( line, column, currentXXT( line, column ) + maskXXT( line, column ));
                    }
                    currentSa2[ line ] = currentSa[ line ] + maskSa[ line ];
                }
                currentVa2 = currentVa + maskVa;
            }
        }
        else
        {
            /// Computation for the cell inside the shape
            if( currentCell == lastCell )
            {
                currentVa = lastVa;
                currentSa = lastSa;
                currentXXT = lastXXT;
            }
            else if( currentCell == lastCell2 )
            {
                currentVa = lastVa2;
                currentSa = lastSa2;
                currentXXT = lastXXT2;
            }
            else
            {
                diffLastCurrentCell = currentCell.myCoordinates - lastCell.myCoordinates;

                x = diffLastCurrentCell[ 0 ];
                y = diffLastCurrentCell[ 1 ];
                z = diffLastCurrentCell[ 2 ];
                x2 = x * x;
                y2 = y * y;
                z2 = z * z;
                x2y2z2 = x2 + y2 + z2;

                offset = (( x / 2 ) + 1 ) + ((( y / 2 ) + 1 ) * 3 ) + ((( z / 2 ) + 1) * 9 ); /// x/2 because we are in a KSpace, and we want a digital offset

                if( x2y2z2 != 4 && x2y2z2 != 8 && !( x2 == 4 && y2 == 4 && z2 == 4 )) /// Previous and current cells aren't adjacent. Compute on the full kernel
                {
#ifdef DEBUG_VERBOSE
                    ++recount;
#endif

                    for( KernelConstIterator itgcurrent = myItKernelBegin; itgcurrent != myItKernelEnd; ++itgcurrent )
                    {
                        shiftedPoint = ( *itgcurrent ).myCoordinates;
                        shiftedPoint += shift;
                        shiftedCell.myCoordinates = shiftedPoint;

                        fShiftedCell = myFFunctor( shiftedCell );

                        if( fShiftedCell != NumberTraits< FQuantity >::ZERO )
                        {
                            currentPoint = midpoint( shiftedCell );

                            for( Dimension line = 0; line < dimension; ++line )
                            {
                                for( Dimension column = 0; column < dimension; ++column )
                                {
                                    currentXXT.setComponent( line, column, currentXXT( line, column ) + fShiftedCell * currentPoint[ line ] * currentPoint[ column ]);
                                }
                                currentSa[ line ] += fShiftedCell * currentPoint[ line ];
                            }
                            currentVa += fShiftedCell * myGFunctor( *itgcurrent );
                        }
                    }
                }
                else if( offset == 13 ) /// Full kernel in 3D. Never reached because case already considered before. It's a honeypot.
                {
                    trace.error() << "Error - Ask to compute full kernel at the wrong moment. Maybe it's an offset computation bug ?\n";
                }
                else
                {
                    maskVa = NumberTraits< Quantity >::ZERO;
                    maskXXT.constant( NumberTraits< Quantity >::ZERO );
                    maskSa.reset();

                    /// Part to substract from previous result.
                    for( KernelConstIterator itgcurrent = myMask[ offset ].first, itgend = myMask[ offset ].second; itgcurrent != itgend; ++itgcurrent )
                    {
                        shiftedPoint = ( *itgcurrent ).myCoordinates - diffLastCurrentCell;
                        shiftedPoint += shift;
                        shiftedCell.myCoordinates = shiftedPoint;

                        fShiftedCell = myFFunctor( shiftedCell );

                        if( fShiftedCell != NumberTraits< FQuantity >::ZERO )
                        {
                            currentPoint = midpoint( shiftedCell );

                            for( Dimension line = 0; line < dimension; ++line )
                            {
                                for( Dimension column = 0; column < dimension; ++column )
                                {
                                    maskXXT.setComponent( line, column, maskXXT( line, column ) - fShiftedCell * currentPoint[ line ] * currentPoint[ column ]);
                                }
                                maskSa[ line ] -= fShiftedCell * currentPoint[ line ];
                            }
                            maskVa -= fShiftedCell * myGFunctor( *itgcurrent );
                        }
                    }

                    /// Part to add from previous result.
                    for( KernelConstIterator itgcurrent = myMask[ 26 - offset ].first, itgend = myMask[ 26 - offset ].second; itgcurrent != itgend; ++itgcurrent )
                    {
                        shiftedPoint = ( *itgcurrent ).myCoordinates;
                        shiftedPoint += shift;
                        shiftedCell.myCoordinates = shiftedPoint;

                        fShiftedCell = myFFunctor( shiftedCell );

                        if( fShiftedCell != NumberTraits< FQuantity >::ZERO )
                        {
                            currentPoint = midpoint( shiftedCell );

                            for( Dimension line = 0; line < dimension; ++line )
                            {
                                for( Dimension column = 0; column < dimension; ++column )
                                {
                                    maskXXT.setComponent( line, column, maskXXT( line, column ) + fShiftedCell * currentPoint[ line ] * currentPoint[ column ]);
                                }
                                maskSa[ line ] += fShiftedCell * currentPoint[ line ];
                            }
                            maskVa += fShiftedCell * myGFunctor( *itgcurrent );
                        }

                    }

                    for( Dimension line = 0; line < dimension; ++line )
                    {
                        for( Dimension column = 0; column < dimension; ++column )
                        {
                            currentXXT.setComponent( line, column, lastXXT( line, column ) + maskXXT( line, column )); /// @todo check lastXXT
                        }
                        currentSa[ line ] = lastSa[ line ] + maskSa[ line ];
                    }
                    currentVa = lastVa + maskVa;
                }
            }

            /// Computation for the cell outside the shape.
            if( currentCell2 == lastCell )
            {
                currentVa2 = lastVa;
                currentSa2 = lastSa;
                currentXXT2 = lastXXT;
            }
            else if( currentCell2 == lastCell2 )
            {
                currentVa2 = lastVa2;
                currentSa2 = lastSa2;
                currentXXT2 = lastXXT2;
            }
            else
            {
                diffWithCurrentCell = currentCell2.myCoordinates - currentCell.myCoordinates;

                x = diffWithCurrentCell[ 0 ];
                y = diffWithCurrentCell[ 1 ];
                z = diffWithCurrentCell[ 2 ];
                x2 = x * x;
                y2 = y * y;
                z2 = z * z;
                x2y2z2 = x2 + y2 + z2;

                offset = (( x / 2 ) + 1 ) + ((( y / 2 ) + 1 ) * 3 ) + ((( z / 2 ) + 1 ) * 9 ); /// x/2 because we are in a KSpace, and we want a digital offset

                if( x2y2z2 != 4 && x2y2z2 != 8 && !( x2 == 4 && y2 == 4 && z2 == 4 )) /// Inside and outside cells aren't adjacent, but should be. It's a honeypot.
                {
                    trace.error() << "Error - Found that inside and outside cells aren't adjacent. That's not logic.\n";
                }
                else if( offset == 13 ) /// Full kernel in 3D. Never reached because case already considered before. It's a honeypot.
                {
                    trace.error() << "Error - Ask to compute full kernel at the wrong moment. Maybe it's an offset computation bug ?\n";
                }
                else
                {
                    maskVa = NumberTraits< Quantity >::ZERO;
                    maskXXT.constant( NumberTraits< Quantity >::ZERO );
                    maskSa.reset();

                    /// Part to substract from previous result.
                    for( KernelConstIterator itgcurrent = myMask[ offset ].first, itgend = myMask[ offset ].second; itgcurrent != itgend; ++itgcurrent )
                    {
                        shiftedPoint = ( *itgcurrent ).myCoordinates - diffWithCurrentCell;
                        shiftedPoint += shift2;
                        shiftedCell.myCoordinates = shiftedPoint;

                        fShiftedCell = myFFunctor( shiftedCell );

                        if( fShiftedCell != NumberTraits< FQuantity >::ZERO )
                        {
                            currentPoint = midpoint( shiftedCell );

                            for( Dimension line = 0; line < dimension; ++line )
                            {
                                for( Dimension column = 0; column < dimension; ++column )
                                {
                                    maskXXT.setComponent( line, column, maskXXT( line, column ) - fShiftedCell * currentPoint[ line ] * currentPoint[ column ]);
                                }
                                maskSa[ line ] -= fShiftedCell * currentPoint[ line ];
                            }
                            maskVa -= fShiftedCell * myGFunctor( *itgcurrent );
                        }

                    }

                    /// Part to add from previous result.
                    for( KernelConstIterator itgcurrent = myMask[ 26 - offset ].first, itgend = myMask[ 26 - offset ].second; itgcurrent != itgend; ++itgcurrent )
                    {
                        shiftedPoint = ( *itgcurrent ).myCoordinates;
                        shiftedPoint += shift2;
                        shiftedCell.myCoordinates = shiftedPoint;

                        fShiftedCell = myFFunctor( shiftedCell );

                        if( fShiftedCell != NumberTraits< FQuantity >::ZERO )
                        {
                            currentPoint = midpoint( shiftedCell );

                            for( Dimension line = 0; line < dimension; ++line )
                            {
                                for( Dimension column = 0; column < dimension; ++column )
                                {
                                    maskXXT.setComponent( line, column, maskXXT( line, column ) + fShiftedCell * currentPoint[ line ] * currentPoint[ column ]);
                                }
                                maskSa[ line ] += fShiftedCell * currentPoint[ line ];
                            }
                            maskVa += fShiftedCell * myGFunctor( *itgcurrent );
                        }
                    }

                    for( Dimension line = 0; line < dimension; ++line )
                    {
                        for( Dimension column = 0; column < dimension; ++column )
                        {
                            currentXXT2.setComponent( line, column, currentXXT( line, column ) + maskXXT( line, column ));
                        }
                        currentSa2[ line ] = currentSa[ line ] + maskSa[ line ];
                    }
                    currentVa2 = currentVa + maskVa;
                }
            }
        }


        dcurrentVa = (double) NumberTraits< Quantity >::castToDouble( currentVa );
        ASSERT (dcurrentVa != 0.0 ); // Maybe the input shape is too small, check your grid step ?
        currentOne_Va = 1.0 / dcurrentVa;
        dcurrentVa2 = (double) NumberTraits< Quantity >::castToDouble( currentVa2 );
        currentOne_Va2 = 1.0 / dcurrentVa2;
        for( Dimension line = 0; line < dimension; ++line )
        {
            for( Dimension column = 0; column < dimension; ++column )
            {
                dcurrentJa = ((double) NumberTraits< Quantity >::castToDouble( currentXXT( line, column ))) - dcurrentVa * ( currentOne_Va * ((double) NumberTraits< Quantity >::castToDouble( currentSa[ line ] ) )) * ( currentOne_Va * ((double) NumberTraits< Quantity >::castToDouble( currentSa[ column ] ) ));
                dcurrentJa2 = ((double) NumberTraits< Quantity >::castToDouble( currentXXT2( line, column ))) - dcurrentVa2 * ( currentOne_Va2 * ((double) NumberTraits< Quantity >::castToDouble( currentSa2[ line ] ) )) * ( currentOne_Va2 * ((double) NumberTraits< Quantity >::castToDouble( currentSa2[ column ] ) ));

                Ja.setComponent( line, column, ( dcurrentJa + dcurrentJa2 ) / 2.0 ); /// The result is the mean between inside's and outside's cell lying to the shape border.
            }
        }

        *result = Ja; /// Set the current cell result to the output iterator.
        ++result;

        lastVa = currentVa;
        lastVa2 = currentVa2;
        lastSa = currentSa;
        lastSa2 = currentSa2;
        lastXXT = currentXXT;
        lastXXT2 = currentXXT2;
        lastCell = currentCell;
        lastCell2 = currentCell2;

        ++total;
    }

#ifdef DEBUG_VERBOSE
    std::cout << "#total cells = " << total << std::endl;
    std::cout << "#recount = " << recount << std::endl;
#endif
}

template <typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator>
inline
bool
DGtal::DigitalSurfaceConvolver<Functor, KernelFunctor, KSpace, KernelConstIterator, 3>::isValid() const
{
    return true;
}

template< typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator >
void
DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, 3 >::fillMoments
( Quantity* aMomentMatrix,
  const Point & aPoint,
  double direction )
{
    int x = aPoint[ 0 ];
    int y = aPoint[ 1 ];
    int z = aPoint[ 2 ];

    aMomentMatrix[ 0 ] += direction * 1;
    aMomentMatrix[ 1 ] += direction * z;
    aMomentMatrix[ 2 ] += direction * y;
    aMomentMatrix[ 3 ] += direction * x;
    aMomentMatrix[ 4 ] += direction * y * z;
    aMomentMatrix[ 5 ] += direction * x * z;
    aMomentMatrix[ 6 ] += direction * x * y;
    aMomentMatrix[ 7 ] += direction * z * z;
    aMomentMatrix[ 8 ] += direction * y * y;
    aMomentMatrix[ 9 ] += direction * x * x;
}

template< typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator >
void
DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, 3 >::computeCovarianceMatrix
( const Quantity* aMomentMatrix,
  CovarianceMatrix & aCovarianceMatrix )
{
    MatrixQuantity A;
    double B;
    MatrixQuantity C;

    A.setComponent( 0, 0, aMomentMatrix[ 9 ] );
    A.setComponent( 0, 1, aMomentMatrix[ 6 ] );
    A.setComponent( 0, 2, aMomentMatrix[ 5 ] );
    A.setComponent( 1, 0, aMomentMatrix[ 6 ] );
    A.setComponent( 1, 1, aMomentMatrix[ 8 ] );
    A.setComponent( 1, 2, aMomentMatrix[ 4 ] );
    A.setComponent( 2, 0, aMomentMatrix[ 5 ] );
    A.setComponent( 2, 1, aMomentMatrix[ 4 ] );
    A.setComponent( 2, 2, aMomentMatrix[ 7 ] );

    B = 1.0 / aMomentMatrix[ 0 ];

    C.setComponent( 0, 0, aMomentMatrix[ 3 ] * aMomentMatrix[ 3 ] );
    C.setComponent( 0, 1, aMomentMatrix[ 3 ] * aMomentMatrix[ 2 ] );
    C.setComponent( 0, 2, aMomentMatrix[ 3 ] * aMomentMatrix[ 1 ] );
    C.setComponent( 1, 0, aMomentMatrix[ 2 ] * aMomentMatrix[ 3 ] );
    C.setComponent( 1, 1, aMomentMatrix[ 2 ] * aMomentMatrix[ 2 ] );
    C.setComponent( 1, 2, aMomentMatrix[ 2 ] * aMomentMatrix[ 1 ] );
    C.setComponent( 2, 0, aMomentMatrix[ 1 ] * aMomentMatrix[ 3 ] );
    C.setComponent( 2, 1, aMomentMatrix[ 1 ] * aMomentMatrix[ 2 ] );
    C.setComponent( 2, 2, aMomentMatrix[ 1 ] * aMomentMatrix[ 1 ] );

    aCovarianceMatrix = A - C * B;
}

template< typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator >
template< typename Shape >
double
DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, 3 >::computeShiftFromShape
( const Shape & shape,
  const double h,
  const Spel & aInnerSpel,
  const Spel & aOuterSpel )
{
    typedef typename Z3i::RealPoint RealPoint;

    double lambda = -1.0;
    //    CanonicSCellEmbedder< KSpace > SCellToRealPoint( myKSpace );
    //    SCellToMidPoint< KSpace > SCellToRealPoint( myKSpace );

    RealPoint low = RealPoint( myKSpace.sCoords( aInnerSpel )) * h;
    RealPoint high = RealPoint( myKSpace.sCoords( aOuterSpel )) * h;
    //    RealPoint low = RealPoint( SCellToRealPoint( aInnerSpel )) * h;
    //    RealPoint high = RealPoint( SCellToRealPoint( aOuterSpel )) * h;

    unsigned int iter = 0;
    unsigned int nbIter = 10;


    ASSERT(( shape.orientation( low ) != shape.orientation( high ) )); // They can't be on the same side of the shape.
    if( shape.orientation( low ) == shape.orientation( high ) )
    {
        std::cout <<  "On the same orientation "<< low << " " << high << std::endl;
    }

    Z3i::RealPoint test;
    while ( iter <= nbIter )
    {
        test = ( low + high ) / 2.0;
        DGtal::Orientation inout = shape.orientation( test );

        ASSERT(( high != low ));

        if( inout == ON )
        {
            lambda = (( test - ( RealPoint( myKSpace.sCoords( aInnerSpel )) * h )).norm() / h );
            //            lambda = (( test - ( SCellToRealPoint( aInnerSpel ) * h )).norm() / h );
            break;
        }
        else if( inout == OUTSIDE )
        {
            high = test;
        }
        else
        {
            low = test;
        }

        ++iter;
    }

    if( lambda == -1.0 )
    {
        lambda = (( test - ( RealPoint( myKSpace.sCoords( aInnerSpel )) * h )).norm() / h );
        //        lambda = (( test - ( SCellToRealPoint( aInnerSpel ) * h )).norm() / h );
    }

    ASSERT (( lambda <= 1.0 ));
    ASSERT (( lambda >= 0.0 ));

    //    std::cout << lambda << std::endl;

    return lambda;
}


template< typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator >
const int
DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, 3 >::nbMoments = 10;

template< typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator >
typename DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, 3 >::Spel
DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, 3 >::defaultInnerSpel = Spel();

template< typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator >
typename DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, 3 >::Spel
DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, 3 >::defaultOuterSpel = Spel();

template< typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator >
typename DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, 3 >::Quantity
DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, 3 >::defaultInnerMoments[ nbMoments ] = {Quantity(0)};

template< typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator >
typename DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, 3 >::Quantity
DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, 3 >::defaultOuterMoments[ nbMoments ] = {Quantity(0)};

template< typename Functor, typename KernelFunctor, typename KSpace, typename KernelConstIterator >
template< typename SurfelIterator >
void
DGtal::DigitalSurfaceConvolver< Functor, KernelFunctor, KSpace, KernelConstIterator, 3 >::core_evalCovarianceMatrix
( const SurfelIterator & it,
  CovarianceMatrix & innerMatrix,
  CovarianceMatrix & outerMatrix,
  bool useLastResults,
  Spel & lastInnerSpel,
  Spel & lastOuterSpel,
  Quantity * lastInnerMoments,
  Quantity * lastOuterMoments )
{
    ASSERT ( isInitMask == true );
//    ASSERT ( useLastResults == true && lastInnerMoments != NULL && lastOuterMoments != NULL && lastInnerSpel != lastOuterSpel );

    typedef typename Functor::Quantity FQuantity;
    DGtal::Dimension nbMasks = myMask.size() - 1;
    DGtal::Dimension positionOfFullKernel = 13;

    Quantity m[ nbMoments ]; /// <! [ m000, m001, m010, m100, m011, m101, m110, m002, m020, m200 ]
    std::fill( m, m + nbMoments, NumberTraits< Quantity >::ZERO ); /// <! clear array

    Spel currentInnerSpel, currentOuterSpel;
    Spel shiftedSpel;
    Point shiftInnerSpel, shiftOuterSpel;
    Point diffSpel;

    bool bComputed = false; /// <! if the cell has already been computed, continue to the next

    int x, y, z, x2, y2, z2, x2y2z2;
    int offset;

    /// Inner cell
    {
        DGtal::Dimension kDim = myKSpace.sOrthDir( *it );
        currentInnerSpel = myKSpace.sDirectIncident( *it, kDim ); /// Spel on the border, but inside the shape
        shiftInnerSpel = myKSpace.sKCoords( currentInnerSpel ) - myKSpace.sKCoords( myKernelSpelOrigin );

        /// Check if we can use previous results
        if( useLastResults )
        {
            bComputed = false;

            if(  currentInnerSpel == lastInnerSpel )
            {
                memcpy( m, lastInnerMoments, nbMoments * sizeof( Quantity ));
                computeCovarianceMatrix( m, innerMatrix );

                bComputed = true;
            }
            else if(  currentInnerSpel == lastOuterSpel )
            {
                memcpy( m, lastOuterMoments, nbMoments * sizeof( Quantity ));
                computeCovarianceMatrix( m, outerMatrix );

                bComputed = true;
            }
            else
            {
                diffSpel = myKSpace.sKCoords( currentInnerSpel ) - myKSpace.sKCoords( lastInnerSpel );

                x = diffSpel[ 0 ];
                y = diffSpel[ 1 ];
                z = diffSpel[ 2 ];
                x2 = x * x;
                y2 = y * y;
                z2 = z * z;
                x2y2z2 = x2 + y2 + z2;

                offset = (( x / 2 ) + 1 ) + ((( y / 2 ) + 1 ) * 3 ) + ((( z / 2 ) + 1 ) * 9 );

                if( x2y2z2 != 4 && x2y2z2 != 8 && !( x2 == 4 && y2 == 4 && z2 == 4 )) /// Previous and current cells aren't adjacent. Compute on the full kernel
                {
                    useLastResults = false;
    #ifdef DEBUG_VERBOSE
                    ++recount;
    #endif
                }
                else if( offset == positionOfFullKernel ) /// Full kernel in 3D. Never reached because case already considered before. It's a honeypot.
                {
                    trace.error() << "Error - Ask to compute full kernel at the wrong moment. Maybe it's an offset computation bug ?\n";
                }
                else
                {
                    useLastResults = true;
                }
            }
        }

        if( !bComputed )
        {
            if( !useLastResults ) /// Computation on full kernel, we have no previous results
            {
                std::fill( m, m + nbMoments, NumberTraits< Quantity >::ZERO ); /// <! clear array

                for( KernelConstIterator itgcurrent = myItKernelBegin; itgcurrent != myItKernelEnd; ++itgcurrent )
                {
                    myKSpace.sSetKCoords( shiftedSpel, myKSpace.sKCoords( *itgcurrent ) + shiftInnerSpel );

                    ASSERT( myKSpace.sKCoords( shiftedSpel )[ 0 ] & 0x1 );
                    ASSERT( myKSpace.sKCoords( shiftedSpel )[ 1 ] & 0x1 );
                    ASSERT( myKSpace.sKCoords( shiftedSpel )[ 2 ] & 0x1 );

                    if( myFFunctor( shiftedSpel ) != NumberTraits< FQuantity >::ZERO )
                    {
                        fillMoments( m, myKSpace.sCoords( shiftedSpel ), 1.0 );
                    }
                }
            }
            else /// Using lastInnerMoments
            {
                memcpy( m, lastInnerMoments, nbMoments * sizeof( Quantity ));

                /// Part to substract from previous result.
                for( KernelConstIterator itgcurrent = myMask[ offset ].first, itgend = myMask[ offset ].second; itgcurrent != itgend; ++itgcurrent )
                {
                    myKSpace.sSetKCoords( shiftedSpel, myKSpace.sKCoords( *itgcurrent ) - diffSpel + shiftInnerSpel );

                    if( myFFunctor( shiftedSpel ) != NumberTraits< FQuantity >::ZERO )
                    {
                        fillMoments( m, myKSpace.sCoords( shiftedSpel ), -1.0 );
                    }
                }

                /// Part to add from previous result.
                for( KernelConstIterator itgcurrent = myMask[ nbMasks - offset ].first, itgend = myMask[ nbMasks - offset ].second; itgcurrent != itgend; ++itgcurrent )
                {
                    myKSpace.sSetKCoords( shiftedSpel, myKSpace.sKCoords( *itgcurrent ) + shiftInnerSpel );

                    if( myFFunctor( shiftedSpel ) != NumberTraits< FQuantity >::ZERO )
                    {
                        fillMoments( m, myKSpace.sCoords( shiftedSpel ), 1.0 );
                    }
                }
            }

            /// Computation of covariance Matrix
            computeCovarianceMatrix( m, innerMatrix );
            memcpy( lastInnerMoments, m, nbMoments * sizeof( Quantity ));
        }
    }

    /// Outter cell
    {
        DGtal::Dimension kDim = myKSpace.sOrthDir( *it );
        currentOuterSpel = myKSpace.sIndirectIncident( *it, kDim );
        shiftOuterSpel = myKSpace.sKCoords( currentOuterSpel ) - myKSpace.sKCoords( myKernelSpelOrigin );

        ASSERT( currentInnerSpel != currentOuterSpel );

        diffSpel = myKSpace.sKCoords( currentOuterSpel ) - myKSpace.sKCoords( currentInnerSpel );

        x = diffSpel[ 0 ];
        y = diffSpel[ 1 ];
        z = diffSpel[ 2 ];
        x2 = x * x;
        y2 = y * y;
        z2 = z * z;
        x2y2z2 = x2 + y2 + z2;

        offset = (( x / 2 ) + 1 ) + ((( y / 2 ) + 1 ) * 3 ) + ((( z / 2 ) + 1) * 9 );

        if(  x2y2z2 != 4 && x2y2z2 != 8 && !( x2 == 4 && y2 == 4 && z2 == 4 )) /// Inside and outside cells aren't adjacent, but should be. It's a honeypot.
        {
            trace.error() << "Error - Found that inside and outside cells aren't adjacent. That's not logic.\n";
        }
        else if(  offset == positionOfFullKernel ) /// Full kernel in 3D. Never reached because case already considered before. It's a honeypot.
        {
            trace.error() << "Error - Ask to compute full kernel at the wrong moment. Maybe it's an offset computation bug ?\n";
        }
        else
        {
            /// Part to substract from previous result.
            for( KernelConstIterator itgcurrent = myMask[ offset ].first, itgend = myMask[ offset ].second; itgcurrent != itgend; ++itgcurrent )
            {
                myKSpace.sSetKCoords( shiftedSpel, myKSpace.sKCoords( *itgcurrent ) - diffSpel + shiftOuterSpel );

                if( myFFunctor( shiftedSpel ) != NumberTraits< FQuantity >::ZERO )
                {
                    fillMoments( m, myKSpace.sCoords( shiftedSpel ), -1.0 );
                }
            }

            /// Part to add from previous result.
            for( KernelConstIterator itgcurrent = myMask[ nbMasks - offset ].first, itgend = myMask[ nbMasks - offset ].second; itgcurrent != itgend; ++itgcurrent )
            {
                myKSpace.sSetKCoords( shiftedSpel, myKSpace.sKCoords( *itgcurrent ) + shiftOuterSpel );

                if( myFFunctor( shiftedSpel ) != NumberTraits< FQuantity >::ZERO )
                {
                    fillMoments( m, myKSpace.sCoords( shiftedSpel ), 1.0 );
                }
            }
        }

        /// Computation of covariance Matrix
        computeCovarianceMatrix( m, outerMatrix );
        memcpy( lastOuterMoments, m, nbMoments * sizeof( Quantity ));
    }

    ASSERT (( lastInnerMoments[ 0 ] != lastOuterMoments[ 0 ] )); // Maybe a problem here. Can be normal ... but needs to check twice.

    lastInnerSpel = currentInnerSpel;
    lastOuterSpel = currentOuterSpel;
}
