/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file KhalimskySpaceND.ih
 * @author Jacques-Olivier Lachaud (\c jacques-olivier.lachaud@univ-savoie.fr )
 * Laboratory of Mathematics (CNRS, UMR 5807), University of Savoie, France
 *
 * @date 2011/02/08
 *
 * Implementation of inline methods defined in KhalimskySpaceND.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include "DGtal/io/Color.h"
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of static constants
///////////////////////////////////////////////////////////////////////////////

#if (!defined(WIN32))
/*template < Dimension dim, typename TInteger >
const Dimension 
DGtal::KhalimskySpaceND< dim, TInteger >::dimension = dim;
*/
template < DGtal::Dimension dim, typename TInteger >
const DGtal::Dimension 
DGtal::KhalimskySpaceND< dim, TInteger >::DIM = dim;

template < DGtal::Dimension dim, typename TInteger >
const typename DGtal::KhalimskySpaceND< dim, TInteger >::Sign
DGtal::KhalimskySpaceND< dim, TInteger >::POS = true;

template < DGtal::Dimension dim, typename TInteger >
const typename DGtal::KhalimskySpaceND< dim, TInteger >::Sign
DGtal::KhalimskySpaceND< dim, TInteger >::NEG = false;
#endif

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// KhalimskyCell
///////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger >
inline
DGtal::KhalimskyCell< dim, TInteger >::
KhalimskyCell( Integer )
{
  myCoordinates.reset();
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger >
inline
DGtal::KhalimskyCell< dim, TInteger >::
KhalimskyCell( const KhalimskyCell & other )
  : myCoordinates( other.myCoordinates )
{
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger >
inline
DGtal::KhalimskyCell< dim, TInteger >::
KhalimskyCell( const Point & p )
  : myCoordinates( p )
{
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger >
inline
DGtal::KhalimskyCell< dim, TInteger > &
DGtal::KhalimskyCell< dim, TInteger >::
operator=( const KhalimskyCell & other )
{
  if ( this != &other )
    myCoordinates = other.myCoordinates;
  return *this;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger >
inline
bool
DGtal::KhalimskyCell< dim, TInteger >::
operator==( const KhalimskyCell & other ) const
{
  return myCoordinates == other.myCoordinates;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger >
inline
bool
DGtal::KhalimskyCell< dim, TInteger >::
operator!=( const KhalimskyCell & other ) const
{
  return myCoordinates != other.myCoordinates;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger >
inline
bool
DGtal::KhalimskyCell< dim, TInteger >::
operator<( const KhalimskyCell & other ) const
{
  return myCoordinates < other.myCoordinates;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger >
inline
std::ostream & 
DGtal::operator<<( std::ostream & out, 
       const KhalimskyCell< dim, TInteger > & object )
{
  out << "(" << object.myCoordinates[ 0 ];
  for ( DGtal::Dimension i = 1; i < dim; ++i )
    out << "," << object.myCoordinates[ i ];
  out << ")";
  return out;
}

//------------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger >
inline
std::string
DGtal::KhalimskyCell<dim, TInteger>::
className() const
{
  return "KhalimskyCell";
}

///////////////////////////////////////////////////////////////////////////////
// SignedKhalimskyCell
///////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger >
inline
DGtal::SignedKhalimskyCell< dim, TInteger >::
SignedKhalimskyCell( Integer )
  : myPositive( true )
{
  myCoordinates.reset();
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger >
inline
DGtal::SignedKhalimskyCell< dim, TInteger >::
SignedKhalimskyCell( const SignedKhalimskyCell & other )
  : myCoordinates( other.myCoordinates), myPositive( other.myPositive )
{
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger >
inline
DGtal::SignedKhalimskyCell< dim, TInteger >::
SignedKhalimskyCell( const Point & p, bool positive )
  : myCoordinates( p ), myPositive( positive )
{
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger >
inline
DGtal::SignedKhalimskyCell< dim, TInteger > &
DGtal::SignedKhalimskyCell< dim, TInteger >::
operator=( const SignedKhalimskyCell & other )
{
  if ( this != &other )
    {
      myCoordinates = other.myCoordinates;
      myPositive = other.myPositive;
    }
  return *this;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger >
inline
bool
DGtal::SignedKhalimskyCell< dim, TInteger >::
operator==( const SignedKhalimskyCell & other ) const
{
  return ( myPositive == other.myPositive )
    && ( myCoordinates == other.myCoordinates );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger >
inline
bool
DGtal::SignedKhalimskyCell< dim, TInteger >::
operator!=( const SignedKhalimskyCell & other ) const
{
  return ( myPositive != other.myPositive )
    || ( myCoordinates != other.myCoordinates );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger >
inline
bool
DGtal::SignedKhalimskyCell< dim, TInteger >::
operator<( const SignedKhalimskyCell & other ) const
{
  return ( myPositive < other.myPositive )
    || ( ( myPositive == other.myPositive )
   && ( myCoordinates < other.myCoordinates ) );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim,
     typename TInteger >
inline
std::ostream & 
DGtal::operator<<( std::ostream & out, 
       const SignedKhalimskyCell< dim, TInteger > & object )
{
  out << "(" << object.myCoordinates[ 0 ];
  for ( DGtal::Dimension i = 1; i < dim; ++i )
    out << "," << object.myCoordinates[ i ];
  out << "," << ( object.myPositive ? '+' : '-' );
  out << ")";
  return out;
}

//------------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger >
inline
std::string
DGtal::SignedKhalimskyCell<dim, TInteger>::
className() const
{
  return "SignedKhalimskyCell";
}

///////////////////////////////////////////////////////////////////////////////
// CellDirectionIterator
///////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger >
inline
DGtal::CellDirectionIterator< dim, TInteger >::
CellDirectionIterator( Cell cell, bool open )
  : myDir( 0 ), myCell( cell ), myOpen( open )
{
  find();
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger >
inline
DGtal::CellDirectionIterator< dim, TInteger >::
CellDirectionIterator( SCell scell, bool open )
  : myDir( 0 ), myCell( scell.myCoordinates ), myOpen( open )
{
  find();
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger >
inline
DGtal::Dimension 
DGtal::CellDirectionIterator< dim, TInteger >::
operator*() const
{
  return myDir;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger >
inline
DGtal::CellDirectionIterator< dim, TInteger > & 
DGtal::CellDirectionIterator< dim, TInteger >::
operator++()
{
  ++myDir;
  find();
  return *this;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger >
inline
bool
DGtal::CellDirectionIterator< dim, TInteger >::
operator!=( const Integer ) const
{
  return myDir < dim;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger >
inline
bool
DGtal::CellDirectionIterator< dim, TInteger >::
end() const
{
  return myDir >= dim;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger >
inline
bool
DGtal::CellDirectionIterator< dim, TInteger >::
operator!=( const CellDirectionIterator & other ) const
{
  return myDir != other.myDir;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger >
inline
bool
DGtal::CellDirectionIterator< dim, TInteger >::
operator==( const CellDirectionIterator & other ) const
{
  return myDir == other.myDir;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger >
inline
void
DGtal::CellDirectionIterator< dim, TInteger >::
find()
{
  if ( myOpen ) // loop on open coordinates
    while ( ( myDir != dim ) 
      && ( ( myCell.myCoordinates[ myDir ] & 0x1 ) == 0 ) )
      ++myDir;
  else // myOpen is false, loop on closed coordinates
    while ( ( myDir != dim ) 
      && ( myCell.myCoordinates[ myDir ] & 0x1 ) )
      ++myDir;
}


///////////////////////////////////////////////////////////////////////////////
// KhalimskySpaceND
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
DGtal::KhalimskySpaceND< dim, TInteger>::
~KhalimskySpaceND()
{
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
DGtal::KhalimskySpaceND< dim, TInteger>::
KhalimskySpaceND()
{
  Point low, high;
  for ( DGtal::Dimension i = 0; i < dimension; ++i )
    {
      low[ i ] = NumberTraits< Integer >::min() / 2 + 1;
      high[ i ] = NumberTraits< Integer >::max() / 2 - 1;
    }
  init( low, high, true );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
DGtal::KhalimskySpaceND< dim, TInteger>::
KhalimskySpaceND( const KhalimskySpaceND & other )
 : myLower(other.myLower), myUpper(other.myUpper),
   myCellLower(other.myCellLower), myCellUpper(other.myCellUpper),
   myIsClosed(other.myIsClosed) { }
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
DGtal::KhalimskySpaceND< dim, TInteger> &
DGtal::KhalimskySpaceND< dim, TInteger>::
operator= ( const KhalimskySpaceND & other ) 
{
  if ( this != &other )
    {
      myLower = other.myLower;
      myUpper = other.myUpper;
      myCellLower = other.myCellLower;
      myCellUpper = other.myCellUpper;
      myIsClosed = other.myIsClosed;
    }
  return *this;  
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
bool 
DGtal::KhalimskySpaceND< dim, TInteger>::
init( const Point & lower,
      const Point & upper,
      bool closed )
{
  myIsClosed = closed;
  myLower = lower;
  myUpper = upper;
  if ( NumberTraits< Integer >::isBounded() == BOUNDED )
    {
      for ( DGtal::Dimension i = 0; i < dimension; ++i )
  {
    if ( ( lower[ i ] 
     <= ( NumberTraits< Integer >::min() / 2 ) )
         || ( upper[ i ] 
        >= ( NumberTraits< Integer >::max() / 2 ) ) )
      return false;
  }
    }
  for ( DGtal::Dimension i = 0; i < dimension; ++i )
    {
      myCellLower.myCoordinates[ i ] = ( lower[ i ] * 2 )
  + ( closed ? 0 : 1 );
      myCellUpper.myCoordinates[ i ] = ( upper[ i ] * 2 )
  + ( closed ? 2 : 1 );
    }
  return true;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger>::Size
DGtal::KhalimskySpaceND< dim, TInteger>::
size( DGtal::Dimension k ) const
{
  ASSERT( k < dimension );
  return myUpper[ k ] + NumberTraits<Integer>::ONE - myLower[ k ];
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
TInteger 
DGtal::KhalimskySpaceND< dim, TInteger>::
min( DGtal::Dimension k ) const
{
  return myLower[ k ];
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
TInteger 
DGtal::KhalimskySpaceND< dim, TInteger>::
max( DGtal::Dimension k ) const
{
  return myUpper[ k ];
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
const typename DGtal::KhalimskySpaceND< dim, TInteger>::Point &
DGtal::KhalimskySpaceND< dim, TInteger>::
lowerBound() const
{
  return myLower;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
const typename DGtal::KhalimskySpaceND< dim, TInteger>::Point &
DGtal::KhalimskySpaceND< dim, TInteger>::
upperBound() const
{
  return myUpper;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
const typename DGtal::KhalimskySpaceND< dim, TInteger>::Cell &
DGtal::KhalimskySpaceND< dim, TInteger>::
lowerCell() const
{
  return myCellLower;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
const typename DGtal::KhalimskySpaceND< dim, TInteger>::Cell &
DGtal::KhalimskySpaceND< dim, TInteger>::
upperCell() const
{
  return myCellUpper;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
bool
DGtal::KhalimskySpaceND< dim, TInteger>::
isSpaceClosed() const
{
  return myIsClosed;
}

//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger>::Cell
DGtal::KhalimskySpaceND< dim, TInteger>::
uCell( const Point & kp ) const
{
  return Cell( kp );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger>::Cell
DGtal::KhalimskySpaceND< dim, TInteger>::
uCell( const Point & p, const Cell & c ) const
{
  Cell nc( p );
  for ( DGtal::Dimension i = 0; i < DIM; ++i )
    nc.myCoordinates[ i ] += p[ i ] + ( c.myCoordinates[ i ] & 0x1 );
  return nc;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger>::SCell
DGtal::KhalimskySpaceND< dim, TInteger>::
sCell( const Point & kp, Sign sign ) const
{
  return SCell( kp, sign == POS );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger>::SCell
DGtal::KhalimskySpaceND< dim, TInteger>::
sCell( const Point & p, const SCell & c ) const
{
  SCell nc( p, c.myPositive );
  for ( DGtal::Dimension i = 0; i < DIM; ++i )
    nc.myCoordinates[ i ] += p[ i ] + ( c.myCoordinates[ i ] & 0x1 );
  return nc;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger>::Cell
DGtal::KhalimskySpaceND< dim, TInteger>::
uSpel( const Point & p ) const
{
  Cell nc( p );
  for ( DGtal::Dimension i = 0; i < DIM; ++i )
    nc.myCoordinates[ i ] += p[ i ] + 1;
  return nc;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger>::SCell
DGtal::KhalimskySpaceND< dim, TInteger>::
sSpel( const Point & p, Sign sign ) const
{
  SCell nc( p, sign );
  for ( DGtal::Dimension i = 0; i < DIM; ++i )
    nc.myCoordinates[ i ] += p[ i ] + 1;
  return nc;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger>::Cell
DGtal::KhalimskySpaceND< dim, TInteger>::
uPointel( const Point & p ) const
{
  Cell nc( p );
  for ( DGtal::Dimension i = 0; i < DIM; ++i )
    nc.myCoordinates[ i ] += p[ i ];
  return nc;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger>::SCell
DGtal::KhalimskySpaceND< dim, TInteger>::
sPointel( const Point & p, Sign sign ) const
{
  SCell nc( p, sign );
  for ( DGtal::Dimension i = 0; i < DIM; ++i )
    nc.myCoordinates[ i ] += p[ i ];
  return nc;
}
//-----------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger>::Integer
DGtal::KhalimskySpaceND< dim, TInteger>::
uKCoord( const Cell & c, DGtal::Dimension k ) const
{
  ASSERT( k < DIM );
  return c.myCoordinates[ k ];
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger>::Integer 
DGtal::KhalimskySpaceND< dim, TInteger>::
uCoord( const Cell & c, DGtal::Dimension k ) const
{
  ASSERT( k < DIM );
  return c.myCoordinates[ k ] >> 1;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger>::Point
DGtal::KhalimskySpaceND< dim, TInteger>::
uKCoords( const Cell & c ) const
{
  return c.myCoordinates;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger>::Point
DGtal::KhalimskySpaceND< dim, TInteger>::
uCoords( const Cell & c ) const
{
  Point dp;
  for ( DGtal::Dimension i = 0; i < DIM; ++i )
    dp[ i ] = c.myCoordinates[ i ] >> 1;
  return dp;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger>::Integer
DGtal::KhalimskySpaceND< dim, TInteger>::
sKCoord( const SCell & c, DGtal::Dimension k ) const
{
  ASSERT( k < DIM );
  return c.myCoordinates[ k ];
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger>::Integer 
DGtal::KhalimskySpaceND< dim, TInteger>::
sCoord( const SCell & c, DGtal::Dimension k ) const
{
  ASSERT( k < DIM );
  return c.myCoordinates[ k ] >> 1;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger>::Point
DGtal::KhalimskySpaceND< dim, TInteger>::
sKCoords( const SCell & c ) const
{
  return c.myCoordinates;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger>::Point
DGtal::KhalimskySpaceND< dim, TInteger>::
sCoords( const SCell & c ) const
{
  Point dp;
  for ( DGtal::Dimension i = 0; i < DIM; ++i )
    dp[ i ] = c.myCoordinates[ i ] >> 1;
  return dp;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger>::Sign
DGtal::KhalimskySpaceND< dim, TInteger>::
sSign( const SCell & c ) const
{
  return c.myPositive ? POS : NEG;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger>::SCell 
DGtal::KhalimskySpaceND< dim, TInteger>::
signs( const Cell & p, Sign s ) const
{
  return sCell( p.myCoordinates, s );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger>::Cell 
DGtal::KhalimskySpaceND< dim, TInteger>::
unsigns( const SCell & p ) const
{
  return uCell( p.myCoordinates );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger>::SCell 
DGtal::KhalimskySpaceND< dim, TInteger>::
sOpp( const SCell & p ) const
{
  return sCell( p.myCoordinates, ! p.myPositive );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
void
DGtal::KhalimskySpaceND< dim, TInteger>::
uSetKCoord( Cell & c, DGtal::Dimension k, const Integer & i ) const
{
  ASSERT( k < DIM 
    && myCellLower.myCoordinates[ k ] <= i 
    && i <= myCellUpper.myCoordinates[ k ] );
  c.myCoordinates[ k ] = i;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
void
DGtal::KhalimskySpaceND< dim, TInteger>::
sSetKCoord( SCell & c, DGtal::Dimension k, const Integer & i ) const
{
  ASSERT( k < DIM 
    && myCellLower.myCoordinates[ k ] <= i 
    && i <= myCellUpper.myCoordinates[ k ] );
  c.myCoordinates[ k ] = i;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
void
DGtal::KhalimskySpaceND< dim, TInteger>::
uSetCoord( Cell & c, DGtal::Dimension k, Integer i ) const
{
  ASSERT( k < DIM );
  i = ( i << 1 ) + ( c.myCoordinates[ k ] & 1 );
  ASSERT( myCellLower.myCoordinates[ k ] <= i 
    && i <= myCellUpper.myCoordinates[ k ] );
  c.myCoordinates[ k ] = i;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
void
DGtal::KhalimskySpaceND< dim, TInteger>::
sSetCoord( SCell & c, DGtal::Dimension k, Integer i ) const
{
  ASSERT( k < DIM );
  i = ( i << 1 ) + ( c.myCoordinates[ k ] & 1 );
  ASSERT( myCellLower.myCoordinates[ k ] <= i 
    && i <= myCellUpper.myCoordinates[ k ] );
  c.myCoordinates[ k ] = i;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
void
DGtal::KhalimskySpaceND< dim, TInteger>::
uSetKCoords( Cell & c, const Point & kp ) const
{
  c.myCoordinates = kp;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
void
DGtal::KhalimskySpaceND< dim, TInteger>::
sSetKCoords( SCell & c, const Point & kp ) const
{
  c.myCoordinates = kp;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
void
DGtal::KhalimskySpaceND< dim, TInteger>::
uSetCoords( Cell & c, const Point & p ) const
{
  Integer i;
  for ( DGtal::Dimension k = 0; k < DIM; ++k )
    {
      i = ( p[ k ] << 1 ) + ( c.myCoordinates[ k ] & 1 );
      ASSERT( myCellLower.myCoordinates[ k ] <= i 
        && i <= myCellUpper.myCoordinates[ k ] );
      c.myCoordinates[ k ] = i;
    }
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
void
DGtal::KhalimskySpaceND< dim, TInteger>::
sSetCoords( SCell & c, const Point & p ) const
{
  Integer i;
  for ( DGtal::Dimension k = 0; k < DIM; ++k )
    {
      i = ( p[ k ] << 1 ) + ( c.myCoordinates[ k ] & 1 );
      ASSERT( myCellLower.myCoordinates[ k ] <= i 
        && i <= myCellUpper.myCoordinates[ k ] );
      c.myCoordinates[ k ] = i;
    }
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
void
DGtal::KhalimskySpaceND< dim, TInteger>::
sSetSign( SCell & c, Sign s ) const
{
  c.myPositive = ( s == POS );
}
//-----------------------------------------------------------------------------
// ------------------------- Cell topology services -----------------------
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
TInteger
DGtal::KhalimskySpaceND< dim, TInteger>::
uTopology( const Cell & p ) const
{
  Integer i = NumberTraits<Integer>::ZERO;
  Integer j = NumberTraits<Integer>::ONE;
  for ( DGtal::Dimension k = 0; k < DIM; ++k )
    {
      if ( p.myCoordinates[ k ] & NumberTraits<Integer>::ONE )
  i |= j;
      j <<= 1;
    }
  return i;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
TInteger
DGtal::KhalimskySpaceND< dim, TInteger>::
sTopology( const SCell & p ) const
{
  Integer i = NumberTraits<Integer>::ZERO;
  Integer j = NumberTraits<Integer>::ONE;
  for ( DGtal::Dimension k = 0; k < DIM; ++k )
    {
      if ( p.myCoordinates[ k ] & NumberTraits<Integer>::ONE )
  i |= j;
      j <<= 1;
    }
  return i;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
DGtal::Dimension
DGtal::KhalimskySpaceND< dim, TInteger>::
uDim( const Cell & p ) const
{
  Integer i = NumberTraits<Integer>::ZERO;
  for ( DGtal::Dimension k = 0; k < DIM; ++k )
    if ( p.myCoordinates[ k ] & NumberTraits<Integer>::ONE )
      ++i;
  return i;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
DGtal::Dimension
DGtal::KhalimskySpaceND< dim, TInteger>::
sDim( const SCell & p ) const
{
  Integer i = NumberTraits<Integer>::ZERO;
  for ( DGtal::Dimension k = 0; k < DIM; ++k )
    if ( p.myCoordinates[ k ] & NumberTraits<Integer>::ONE )
      ++i;
  return i;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
bool
DGtal::KhalimskySpaceND< dim, TInteger>::
uIsSurfel( const Cell & b ) const
{
  return uDim( b ) == ( DIM - 1 );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
bool
DGtal::KhalimskySpaceND< dim, TInteger>::
sIsSurfel( const SCell & b ) const
{
 return sDim( b ) == ( DIM - 1 );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
bool
DGtal::KhalimskySpaceND< dim, TInteger>::
uIsOpen( const Cell & p, DGtal::Dimension k ) const
{
  return p.myCoordinates[ k ] & NumberTraits<Integer>::ONE;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
bool
DGtal::KhalimskySpaceND< dim, TInteger>::
sIsOpen( const SCell & p, DGtal::Dimension k ) const
{
  return p.myCoordinates[ k ] & NumberTraits<Integer>::ONE;
}

//-----------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger>::DirIterator
DGtal::KhalimskySpaceND< dim, TInteger>::
uDirs( const Cell & p ) const
{
  return DirIterator( p, true );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger>::DirIterator
DGtal::KhalimskySpaceND< dim, TInteger>::
sDirs( const SCell & p ) const
{
  return DirIterator( p, true );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger>::DirIterator
DGtal::KhalimskySpaceND< dim, TInteger>::
uOrthDirs( const Cell & p ) const
{
  return DirIterator( p, false );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger>::DirIterator
DGtal::KhalimskySpaceND< dim, TInteger>::
sOrthDirs( const SCell & p ) const
{
  return DirIterator( p, false );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
DGtal::Dimension 
DGtal::KhalimskySpaceND< dim, TInteger>::
uOrthDir( const Cell & s ) const
{
  DirIterator it( s, false );
  ASSERT( ! it.end() );
  return *it;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
DGtal::Dimension 
DGtal::KhalimskySpaceND< dim, TInteger>::
sOrthDir( const SCell & s ) const
{
  DirIterator it( s, false );
  ASSERT( ! it.end() );
  return *it;
}
//-----------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger>::Cell
DGtal::KhalimskySpaceND< dim, TInteger>::
uFirst( const Cell & p ) const
{
  return uCell( myLower, p );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger>::Cell
DGtal::KhalimskySpaceND< dim, TInteger>::
uLast( const Cell & p ) const
{
  return uCell( myUpper, p );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger>::Cell
DGtal::KhalimskySpaceND< dim, TInteger>::
uGetIncr( const Cell & p, DGtal::Dimension k ) const
{
  Cell q = p;
  q.myCoordinates[ k ] += 2;
  return q;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
bool 
DGtal::KhalimskySpaceND< dim, TInteger>::
uIsMax( const Cell & p, DGtal::Dimension k ) const
{
  return p.myCoordinates[ k ] >= myCellUpper.myCoordinates[ k ];
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
bool 
DGtal::KhalimskySpaceND< dim, TInteger>::
uIsInside( const Cell & p, DGtal::Dimension k ) const
{
  return (p.myCoordinates[ k ] <= uLast(p).myCoordinates[ k ]) &&
    (p.myCoordinates[ k ] >= uFirst(p).myCoordinates[ k ]);
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger>::Cell
DGtal::KhalimskySpaceND< dim, TInteger>::
uGetMax( const Cell & p, DGtal::Dimension k ) const
{
  return uProjection( p, uLast(p), k );
  // return uProjection( p, myCellUpper, k );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger>::Cell
DGtal::KhalimskySpaceND< dim, TInteger>::
uGetDecr( const Cell & p, DGtal::Dimension k ) const
{
  Cell q = p;
  q.myCoordinates[ k ] -= 2;
  return q;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
bool
DGtal::KhalimskySpaceND< dim, TInteger>::
uIsMin( const Cell & p, DGtal::Dimension k ) const
{
  return p.myCoordinates[ k ] <= myCellLower.myCoordinates[ k ];
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger>::Cell
DGtal::KhalimskySpaceND< dim, TInteger>::
uGetMin( const Cell & p, DGtal::Dimension k ) const
{
  return uProjection( p, uFirst(p), k );
  //return uProjection( p, myCellLower, k );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger>::Cell
DGtal::KhalimskySpaceND< dim, TInteger>::
uGetAdd( const Cell & p, DGtal::Dimension k, const Integer & x ) const
{
  Cell q = p;
  q.myCoordinates[ k ] += 2*x;
  return q;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger>::Cell
DGtal::KhalimskySpaceND< dim, TInteger>::
uGetSub( const Cell & p, DGtal::Dimension k, const Integer & x ) const
{
  Cell q = p;
  q.myCoordinates[ k ] -= 2*x;
  return q;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
TInteger
DGtal::KhalimskySpaceND< dim, TInteger>::
uDistanceToMax( const Cell & p, DGtal::Dimension k ) const
{
  return ( myCellUpper.myCoordinates[ k ] - p.myCoordinates[ k ] ) >> 1;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
TInteger
DGtal::KhalimskySpaceND< dim, TInteger>::
uDistanceToMin( const Cell & p, DGtal::Dimension k ) const
{
  return ( p.myCoordinates[ k ] - myCellLower.myCoordinates[ k ] ) >> 1;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger>::Cell
DGtal::KhalimskySpaceND< dim, TInteger>::
uTranslation( const Cell & p, const Vector & vec ) const
{
  Cell q = p;
  for ( DGtal::Dimension k = 0; k < DIM; ++k )
    q.myCoordinates[ k ] += ( vec[ k ] << 1 );
  return q;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger>::Cell
DGtal::KhalimskySpaceND< dim, TInteger>::
uProjection( const Cell & p, const Cell & bound, DGtal::Dimension k ) const
{
  Cell q = p;
  q.myCoordinates[ k ] = bound.myCoordinates[ k ];
  return q;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
void
DGtal::KhalimskySpaceND< dim, TInteger>::
uProject( Cell & p, const Cell & bound, DGtal::Dimension k ) const
{
  p.myCoordinates[ k ] = bound.myCoordinates[ k ];
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
bool
DGtal::KhalimskySpaceND< dim, TInteger>::
uNext( Cell & p, const Cell & lower, const Cell & upper ) const
{
  DGtal::Dimension k = NumberTraits<Dimension>::ZERO;
  if ( uCoord( p, k ) == uCoord( upper, k ) )
    {
      if ( p == upper ) return false;
      uProject( p, lower, k );
      for ( k = 1; k < DIM; ++k )
  {
    if ( uCoord( p, k ) == uCoord( upper, k ) )
      uProject( p, lower, k );
    else  
      {
        p.myCoordinates[ k ] += 2;
        break;
      }
  }
      return true;
    }
  p.myCoordinates[ k ] += 2;
  return true;
}

//-----------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger >::SCell
DGtal::KhalimskySpaceND< dim, TInteger >::
sFirst( const SCell & p ) const
{
  return sCell( myLower, p );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger >::SCell
DGtal::KhalimskySpaceND< dim, TInteger >::
sLast( const SCell & p ) const
{
  return sCell( myUpper, p );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger >::SCell
DGtal::KhalimskySpaceND< dim, TInteger >::
sGetIncr( const SCell & p, DGtal::Dimension k ) const
{
  SCell q = p;
  q.myCoordinates[ k ] += 2;
  return q;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
bool 
DGtal::KhalimskySpaceND< dim, TInteger >::
sIsMax( const SCell & p, DGtal::Dimension k ) const
{
  return p.myCoordinates[ k ] >= myCellUpper.myCoordinates[ k ];
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
bool 
DGtal::KhalimskySpaceND< dim, TInteger>::
sIsInside( const SCell & p, DGtal::Dimension k ) const
{
  return (p.myCoordinates[ k ] <= sLast(p).myCoordinates[ k ]) &&
    (p.myCoordinates[ k ] >= sFirst(p).myCoordinates[ k ]);
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger >::SCell
DGtal::KhalimskySpaceND< dim, TInteger >::
sGetMax( const SCell & p, DGtal::Dimension k ) const
{
  return sProjection( p, sLast(p), k );
  //  return sProjection( p, myCellUpper, k );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger >::SCell
DGtal::KhalimskySpaceND< dim, TInteger >::
sGetDecr( const SCell & p, DGtal::Dimension k ) const
{
  SCell q = p;
  q.myCoordinates[ k ] -= 2;
  return q;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
bool
DGtal::KhalimskySpaceND< dim, TInteger >::
sIsMin( const SCell & p, DGtal::Dimension k ) const
{
  return p.myCoordinates[ k ] <= myCellLower.myCoordinates[ k ];
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger >::SCell
DGtal::KhalimskySpaceND< dim, TInteger >::
sGetMin( const SCell & p, DGtal::Dimension k ) const
{
  return sProjection( p, sFirst(p), k );
  //  return sProjection( p, myCellLower, k );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger >::SCell
DGtal::KhalimskySpaceND< dim, TInteger >::
sGetAdd( const SCell & p, DGtal::Dimension k, const Integer & x ) const
{
  SCell q = p;
  q.myCoordinates[ k ] += 2*x;
  return q;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger >::SCell
DGtal::KhalimskySpaceND< dim, TInteger >::
sGetSub( const SCell & p, DGtal::Dimension k, const Integer & x ) const
{
  SCell q = p;
  q.myCoordinates[ k ] -= 2*x;
  return q;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
TInteger
DGtal::KhalimskySpaceND< dim, TInteger >::
sDistanceToMax( const SCell & p, DGtal::Dimension k ) const
{
  return ( myCellUpper.myCoordinates[ k ] - p.myCoordinates[ k ] ) >> 1;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
TInteger
DGtal::KhalimskySpaceND< dim, TInteger >::
sDistanceToMin( const SCell & p, DGtal::Dimension k ) const
{
  return ( p.myCoordinates[ k ] - myCellLower.myCoordinates[ k ] ) >> 1;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger >::SCell
DGtal::KhalimskySpaceND< dim, TInteger >::
sTranslation( const SCell & p, const Vector & vec ) const
{
  SCell q = p;
  for ( DGtal::Dimension k = 0; k < DIM; ++k )
    q.myCoordinates[ k ] += ( vec[ k ] << 1 );
  return q;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger >::SCell
DGtal::KhalimskySpaceND< dim, TInteger >::
sProjection( const SCell & p, const SCell & bound, DGtal::Dimension k ) const
{
  SCell q = p;
  q.myCoordinates[ k ] = bound.myCoordinates[ k ];
  return q;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
void
DGtal::KhalimskySpaceND< dim, TInteger >::
sProject( SCell & p, const SCell & bound, DGtal::Dimension k ) const
{
  p.myCoordinates[ k ] = bound.myCoordinates[ k ];
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
bool
DGtal::KhalimskySpaceND< dim, TInteger >::
sNext( SCell & p, const SCell & lower, const SCell & upper ) const
{
  DGtal::Dimension k = NumberTraits<Dimension>::ZERO;
  if ( sCoord( p, k ) == sCoord( upper, k ) )
    {
      if ( p == upper ) return false;
      sProject( p, lower, k );
      for ( k = 1; k < DIM; ++k )
  {
    if ( sCoord( p, k ) == sCoord( upper, k ) )
      sProject( p, lower, k );
    else  
      {
        p.myCoordinates[ k ] += 2;
        break;
      }
  }
      return true;
    }
  p.myCoordinates[ k ] += 2;
  return true;
}

//-----------------------------------------------------------------------------
// ----------------------- Neighborhood services --------------------------
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger >::Cells 
DGtal::KhalimskySpaceND< dim, TInteger >::
uNeighborhood( const Cell & c ) const
{
  Cells N;
  N.push_back( c );
  for ( DGtal::Dimension k = 0; k < DIM; ++k )
    {
      if ( ! uIsMin( c, k ) )
  N.push_back( uGetDecr( c, k ) );
      if ( ! uIsMax( c, k ) )
  N.push_back( uGetIncr( c, k ) );
    }
  return N;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger >::SCells 
DGtal::KhalimskySpaceND< dim, TInteger >::
sNeighborhood( const SCell & c ) const
{
  SCells N;
  N.push_back( c );
  for ( DGtal::Dimension k = 0; k < DIM; ++k )
    {
      if ( ! sIsMin( c, k ) )
  N.push_back( sGetDecr( c, k ) );
      if ( ! sIsMax( c, k ) )
  N.push_back( sGetIncr( c, k ) );
    }
  return N;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger >::Cells 
DGtal::KhalimskySpaceND< dim, TInteger >::
uProperNeighborhood( const Cell & c ) const
{
  Cells N;
  for ( DGtal::Dimension k = 0; k < DIM; ++k )
    {
      if ( ! uIsMin( c, k ) )
  N.push_back( uGetDecr( c, k ) );
      if ( ! uIsMax( c, k ) )
  N.push_back( uGetIncr( c, k ) );
    }
  return N;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger >::SCells 
DGtal::KhalimskySpaceND< dim, TInteger >::
sProperNeighborhood( const SCell & c ) const
{
  SCells N;
  for ( DGtal::Dimension k = 0; k < DIM; ++k )
    {
      if ( ! sIsMin( c, k ) )
  N.push_back( sGetDecr( c, k ) );
      if ( ! sIsMax( c, k ) )
  N.push_back( sGetIncr( c, k ) );
    }
  return N;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger >::Cell 
DGtal::KhalimskySpaceND< dim, TInteger >::
uAdjacent( const Cell & p, DGtal::Dimension k, bool up ) const
{
  return up ? uGetIncr( p, k ) : uGetDecr( p, k );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger >::SCell 
DGtal::KhalimskySpaceND< dim, TInteger >::
sAdjacent( const SCell & p, DGtal::Dimension k, bool up ) const
{
  return up ? sGetIncr( p, k ) : sGetDecr( p, k );
}

// ----------------------- Incidence services --------------------------
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger >::Cell
DGtal::KhalimskySpaceND< dim, TInteger >::
uIncident( const Cell & c, DGtal::Dimension k, bool up ) const
{
  ASSERT( k < dim );
  ASSERT( ( ! up ) || ( uKCoord( c, k ) < uKCoord( myCellUpper, k ) ) ); 
  ASSERT( (   up ) || ( uKCoord( myCellLower, k ) < uKCoord( c, k ) ) ); 
  Cell d( c );
  if ( up ) ++d.myCoordinates[ k ];
  else      --d.myCoordinates[ k ];
  return d;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger >::SCell
DGtal::KhalimskySpaceND< dim, TInteger >::
sIncident( const SCell & c, DGtal::Dimension k, bool up ) const
{
  ASSERT( k < dim );
  ASSERT( ( ! up ) || ( sKCoord( c, k ) < uKCoord( myCellUpper, k ) ) ); 
  ASSERT( (   up ) || ( uKCoord( myCellLower, k ) < sKCoord( c, k ) ) ); 
  SCell d( c );
  bool sign = up ? d.myPositive : ! d.myPositive;
  for ( DGtal::Dimension i = 0; i <= k; ++i )
    if ( sIsOpen( d, i ) ) 
      sign = ! sign;
  d.myPositive = sign;
  if ( up ) ++d.myCoordinates[ k ];
  else      --d.myCoordinates[ k ];
  return d;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger >::Cells
DGtal::KhalimskySpaceND< dim, TInteger >::
uLowerIncident( const Cell & c ) const
{
  Cells N;
  for ( DirIterator q = uDirs( c ); q != 0; ++q )
    {
      DGtal::Dimension k = *q;
      Integer x = uKCoord( c, k );
      if ( uKCoord( myCellLower, k ) < x )
  N.push_back( uIncident( c, k, false ) );
      if ( x < uKCoord( myCellUpper, k ) )
  N.push_back( uIncident( c, k, true ) );
    }
  return N;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger >::Cells
DGtal::KhalimskySpaceND< dim, TInteger >::
uUpperIncident( const Cell & c ) const
{
  Cells N;
  for ( DirIterator q = uOrthDirs( c ); q != 0; ++q )
    {
      DGtal::Dimension k = *q;
      Integer x = uKCoord( c, k );
      if ( uKCoord( myCellLower, k ) < x )
  N.push_back( uIncident( c, k, false ) );
      if ( x < uKCoord( myCellUpper, k ) )
  N.push_back( uIncident( c, k, true ) );
    }
  return N;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger >::SCells
DGtal::KhalimskySpaceND< dim, TInteger >::
sLowerIncident( const SCell & c ) const
{
  SCells N;
  for ( DirIterator q = sDirs( c ); q != 0; ++q )
    {
      DGtal::Dimension k = *q;
      Integer x = sKCoord( c, k );
      if ( uKCoord( myCellLower, k ) < x )
  N.push_back( sIncident( c, k, false ) );
      if ( x < uKCoord( myCellUpper, k ) )
  N.push_back( sIncident( c, k, true ) );
    }
  return N;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger >::SCells
DGtal::KhalimskySpaceND< dim, TInteger >::
sUpperIncident( const SCell & c ) const
{
  SCells N;
  for ( DirIterator q = sOrthDirs( c ); q != 0; ++q )
    {
      DGtal::Dimension k = *q;
      Integer x = sKCoord( c, k );
      if ( uKCoord( myCellLower, k ) < x )
  N.push_back( sIncident( c, k, false ) );
      if ( x < uKCoord( myCellUpper, k ) )
  N.push_back( sIncident( c, k, true ) );
    }
  return N;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
void
DGtal::KhalimskySpaceND< dim, TInteger >::
uAddFaces( Cells& faces, const Cell& c, Dimension axis ) const
{
  // std::cerr << c << std::endl;
  DGtal::Dimension dim_of_c = uDim( c );
  if ( axis >= dim_of_c ) return;
  DirIterator q = uDirs( c );
  for ( Dimension i = 0; i < axis; ++i ) ++q;
  Cell f1 = uIncident( c, *q, false );
  Cell f2 = uIncident( c, *q, true );
  faces.push_back( f1 );
  faces.push_back( f2 );
  uAddFaces( faces, f1, axis );
  uAddFaces( faces, f2, axis );
  uAddFaces( faces, c, axis+1 );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
void
DGtal::KhalimskySpaceND< dim, TInteger >::
uAddCoFaces( Cells& cofaces, const Cell& c, Dimension axis ) const
{
  // std::cerr << c << std::endl;
  DGtal::Dimension dim_of_c = uDim( c );
  if ( axis >= dimension - dim_of_c ) return;
  DirIterator q = uOrthDirs( c );
  for ( Dimension i = 0; i < axis; ++i ) ++q;
  Cell f1 = uIncident( c, *q, false );
  Cell f2 = uIncident( c, *q, true );
  cofaces.push_back( f1 );
  cofaces.push_back( f2 );
  uAddCoFaces( cofaces, f1, axis );
  uAddCoFaces( cofaces, f2, axis );
  uAddCoFaces( cofaces, c, axis+1 );
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger >::Cells
DGtal::KhalimskySpaceND< dim, TInteger >::
uFaces( const Cell & c ) const
{
  Cells N;
  uAddFaces( N, c, 0 );
  return N;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger >::Cells
DGtal::KhalimskySpaceND< dim, TInteger >::
uCoFaces( const Cell & c ) const
{
  Cells N;
  uAddCoFaces( N, c, 0 );
  return N;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
bool
DGtal::KhalimskySpaceND< dim, TInteger >::
sDirect( const SCell & p, DGtal::Dimension k ) const
{
  ASSERT( k < dim );
  bool sign = p.myPositive;
  for ( DGtal::Dimension i = 0; i <= k; ++i )
    if ( sIsOpen( p, i ) ) 
      sign = ! sign;
  return sign;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger >::SCell
DGtal::KhalimskySpaceND< dim, TInteger >::
sDirectIncident( const SCell & p, DGtal::Dimension k ) const
{
  ASSERT( k < dim );
  SCell d( p );
  bool sign = d.myPositive;
  for ( DGtal::Dimension i = 0; i <= k; ++i )
    if ( sIsOpen( d, i ) ) 
      sign = ! sign;

  bool up = sign;
  d.myPositive = POS;
  ASSERT( ( ! up ) || ( sKCoord( d, k ) < uKCoord( myCellUpper, k ) ) ); 
  ASSERT( (   up ) || ( uKCoord( myCellLower, k ) < sKCoord( d, k ) ) ); 
  if ( up )  ++d.myCoordinates[ k ];
  else  --d.myCoordinates[ k ];
  
  return d;
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
typename DGtal::KhalimskySpaceND< dim, TInteger >::SCell
DGtal::KhalimskySpaceND< dim, TInteger >::
sIndirectIncident( const SCell & p, DGtal::Dimension k ) const
{
  ASSERT( k < dim );
  SCell d( p );
  bool sign = d.myPositive;
  for ( DGtal::Dimension i = 0; i <= k; ++i )
    if ( sIsOpen( d, i ) ) 
      sign = ! sign;

  bool up = ! sign;
  d.myPositive = NEG;
  ASSERT( ( ! up ) || ( sKCoord( d, k ) < uKCoord( myCellUpper, k ) ) ); 
  ASSERT( (   up ) || ( uKCoord( myCellLower, k ) < sKCoord( d, k ) ) ); 

  if ( up ) ++d.myCoordinates[ k ];
  else --d.myCoordinates[ k ];
  
  return d;
}




//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
void
DGtal::KhalimskySpaceND< dim, TInteger>::
selfDisplay ( std::ostream & out ) const
{
  out << "[KhalimskySpaceND]";
}
//-----------------------------------------------------------------------------
template < DGtal::Dimension dim, typename TInteger>
inline
bool
DGtal::KhalimskySpaceND< dim, TInteger>::
isValid() const
{
  return true;
}



///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions                                        //
template < DGtal::Dimension dim, typename TInteger>
inline
std::ostream&
DGtal::operator<< ( std::ostream & out, 
      const KhalimskySpaceND< dim, TInteger> & object )
{
  object.selfDisplay( out );
  return out;
}

//                                                                           //
///////////////////////////////////////////////////////////////////////////////


