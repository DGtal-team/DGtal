/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file TriangularMeshFrom2DPoints.ih
 * @author Bertrand Kerautret (\c kerautre@loria.fr )
 * LORIA (CNRS, UMR 7503), University of Nancy, France
 *
 * @date 2012/06/29
 *
 * Implementation of inline methods defined in TriangularMeshFrom2DPoints.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////

#include <cstdlib>
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------

/**
 * Constructor.
 */
template <typename TPoint>
inline
DGtal::TriangularMeshFrom2DPoints<TPoint>::TriangularMeshFrom2DPoints()
{
  MeshTriangle emptyTriangle;
  emptyTriangle.indexesPt[0]=0; emptyTriangle.indexesPt[1]=0; emptyTriangle.indexesPt[2]=0;
  emptyTriangle.indexAdjTriangles[0]=0; emptyTriangle.indexAdjTriangles[1]=0; emptyTriangle.indexAdjTriangles[2]=0;
  myTrianglesList.push_back(emptyTriangle);
  // pushing empty point
  myVertexList.push_back(TPoint(0,0));
}


/**
 * Constructor.
 */
template <typename TPoint>
inline
DGtal::TriangularMeshFrom2DPoints<TPoint>::TriangularMeshFrom2DPoints(const TPoint &ptLower, const TPoint &ptUpper)
{
  MeshTriangle emptyTriangle;
  emptyTriangle.indexesPt[0]=0; emptyTriangle.indexesPt[1]=0; emptyTriangle.indexesPt[2]=0;
  emptyTriangle.indexAdjTriangles[0]=0; emptyTriangle.indexAdjTriangles[1]=0; emptyTriangle.indexAdjTriangles[2]=0;
  myTrianglesList.push_back(emptyTriangle);  

  // pushing empty point
  myVertexList.push_back(TPoint(0,0));
  
  // We define two triangles of the bounding box points
  TPoint ptLowerU (ptLower[0], ptUpper[1]);
  TPoint ptUpperL (ptUpper[0], ptLower[1]);
  
  myVertexList.push_back(ptLowerU);
  myVertexList.push_back(ptUpper);
  myVertexList.push_back(ptUpperL);
  myVertexList.push_back(ptLower);
  
  // Upper and lower triangles
  MeshTriangle tr1;
  MeshTriangle tr2;
  tr1.indexesPt[0]=1;  tr1.indexesPt[1]=2;   tr1.indexesPt[2]=3;
  tr2.indexesPt[0]=3;  tr2.indexesPt[1]=4;   tr2.indexesPt[2]=1;
  myTrianglesList.push_back(tr1);
  myTrianglesList.push_back(tr2);
  
  myTrianglesList.at(1).indexAdjTriangles[0] = 0;
  myTrianglesList.at(1).indexAdjTriangles[1] = 0;
  myTrianglesList.at(1).indexAdjTriangles[2] = 2;
  myTrianglesList.at(2).indexAdjTriangles[0] = 0;
  myTrianglesList.at(2).indexAdjTriangles[1] = 0;
  myTrianglesList.at(2).indexAdjTriangles[2] = 1;

  myTrianglesList.at(0).isActive=false;
  myTrianglesList.at(1).isActive=true;
  myTrianglesList.at(2).isActive=true;
  
}



/**
 * Destructor.
 */
template <typename TPoint>
inline
DGtal::TriangularMeshFrom2DPoints<TPoint>::~TriangularMeshFrom2DPoints()
{
}

///////////////////////////////////////////////////////////////////////////////
// Interface - public :

/**
 * Writes/Displays the object on an output stream.
 * @param out the output stream where the object is written.
 */
template <typename TPoint>
inline
void
DGtal::TriangularMeshFrom2DPoints<TPoint>::selfDisplay ( std::ostream & out ) const
{
  out << "[TriangularMeshFrom2DPoints]";
}

/**
 * Checks the validity/consistency of the object.
 * @return 'true' if the object is valid, 'false' otherwise.
 */
template <typename TPoint>
inline
bool
DGtal::TriangularMeshFrom2DPoints<TPoint>::isValid() const
{
    return true;
}




///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions                                        //

    




template<typename TPoint> 
inline
typename DGtal::TriangularMeshFrom2DPoints<TPoint>::IndexOfCreatedTriangle 
DGtal::TriangularMeshFrom2DPoints<TPoint>::addPointInsideMesh(const TPoint & vertex ){
  
  typename DGtal::TriangularMeshFrom2DPoints<TPoint>::IndexOfCreatedTriangle resultingIndex;
  
  int indexTrIn = getTriangleIndexInclosingPoint(vertex);
  if(indexTrIn==0){
    trace.info() << "Vertex " << vertex << " outside current mesh or along existing edge,";
    trace.info() << " point ignored (not yet implemented)!  " << std::endl;
    return resultingIndex;
  }

  
  MeshTriangle tr = myTrianglesList.at(indexTrIn);
  myTrianglesList.at(indexTrIn).isActive=false;
  myVertexList.push_back(vertex);
    
  MeshTriangle newTr1;
  newTr1.indexesPt[0] = tr.indexesPt[0];
  newTr1.indexesPt[1] = tr.indexesPt[1];  
  newTr1.indexesPt[2] = myVertexList.size()-1;
  newTr1.isActive=true;
  myTrianglesList.push_back(newTr1);
  
  resultingIndex.indexTr1=myTrianglesList.size()-1;
  
  MeshTriangle newTr2;
  newTr2.indexesPt[0] = tr.indexesPt[1];
  newTr2.indexesPt[1] = tr.indexesPt[2];
  newTr2.indexesPt[2] = myVertexList.size()-1;
  newTr2.isActive=true;
  myTrianglesList.push_back(newTr2);
  resultingIndex.indexTr2=myTrianglesList.size()-1;
  
  
  MeshTriangle newTr3;
  newTr3.indexesPt[0] = tr.indexesPt[2];
  newTr3.indexesPt[1] = tr.indexesPt[0];
  newTr3.indexesPt[2] = myVertexList.size()-1;
  newTr3.isActive=true;
  myTrianglesList.push_back(newTr3);
  resultingIndex.indexTr3=myTrianglesList.size()-1;
 


  //Setting Adjacency for new faces.
  myTrianglesList.at(myTrianglesList.size()-3).indexAdjTriangles[0] = tr.indexAdjTriangles[0];
  myTrianglesList.at(myTrianglesList.size()-3).indexAdjTriangles[1] = myTrianglesList.size()-2; //&newTr2;
  myTrianglesList.at(myTrianglesList.size()-3).indexAdjTriangles[2] = myTrianglesList.size()-1; //newTr3;

  myTrianglesList.at(myTrianglesList.size()-2).indexAdjTriangles[0] = tr.indexAdjTriangles[1];
  myTrianglesList.at(myTrianglesList.size()-2).indexAdjTriangles[1] = myTrianglesList.size()-1;//&newTr3; 
  myTrianglesList.at(myTrianglesList.size()-2).indexAdjTriangles[2] = myTrianglesList.size()-3;//newTr3;

  myTrianglesList.at(myTrianglesList.size()-1).indexAdjTriangles[0] = tr.indexAdjTriangles[2];
  myTrianglesList.at(myTrianglesList.size()-1).indexAdjTriangles[1] = myTrianglesList.size()-3; //&newTr1;
  myTrianglesList.at(myTrianglesList.size()-1).indexAdjTriangles[2] = myTrianglesList.size()-2; //&newTr2;
  
  //Updating Adjacency towards  new faces.
  MeshTriangle &tr1AdjacentNotNew = myTrianglesList.at(myTrianglesList.at(myTrianglesList.size()-3).indexAdjTriangles[0]);
  if(tr1AdjacentNotNew.indexAdjTriangles[0]==indexTrIn){ 
    tr1AdjacentNotNew.indexAdjTriangles[0]  = myTrianglesList.size()-3;
  }else if(tr1AdjacentNotNew.indexAdjTriangles[1]==indexTrIn){ 
    tr1AdjacentNotNew.indexAdjTriangles[1]  = myTrianglesList.size()-3;
  }else if(tr1AdjacentNotNew.indexAdjTriangles[2]==indexTrIn){ 
    tr1AdjacentNotNew.indexAdjTriangles[2]  = myTrianglesList.size()-3;
  }

  MeshTriangle &tr2AdjacentNotNew = myTrianglesList.at(myTrianglesList.at(myTrianglesList.size()-2).indexAdjTriangles[0]);
  if(tr2AdjacentNotNew.indexAdjTriangles[0]==indexTrIn){ 
    tr2AdjacentNotNew.indexAdjTriangles[0]  = myTrianglesList.size()-2;
  }else if(tr2AdjacentNotNew.indexAdjTriangles[1]==indexTrIn){ 
    tr2AdjacentNotNew.indexAdjTriangles[1]  = myTrianglesList.size()-2;
  }else if(tr2AdjacentNotNew.indexAdjTriangles[2]==indexTrIn){ 
    tr2AdjacentNotNew.indexAdjTriangles[2]  = myTrianglesList.size()-2;
  }
  
  MeshTriangle &tr3AdjacentNotNew = myTrianglesList.at(myTrianglesList.at(myTrianglesList.size()-1).indexAdjTriangles[0]);
  if(tr3AdjacentNotNew.indexAdjTriangles[0]==indexTrIn){ 
    tr3AdjacentNotNew.indexAdjTriangles[0]  = myTrianglesList.size()-1;
  }else if(tr3AdjacentNotNew.indexAdjTriangles[1]==indexTrIn){ 
    tr3AdjacentNotNew.indexAdjTriangles[1]  = myTrianglesList.size()-1;
  }else if(tr3AdjacentNotNew.indexAdjTriangles[2]==indexTrIn){ 
    tr3AdjacentNotNew.indexAdjTriangles[2]  = myTrianglesList.size()-1;
  }
  
  return resultingIndex;
}




template<typename TPoint> 
inline
typename DGtal::TriangularMeshFrom2DPoints<TPoint>::IndexOfCreatedTriangle
DGtal::TriangularMeshFrom2DPoints<TPoint>::addPointInsideDelaunayMesh(const TPoint & vertex ){
  typename DGtal::TriangularMeshFrom2DPoints<TPoint>::IndexOfCreatedTriangle resultingIndex;
  typename DGtal::TriangularMeshFrom2DPoints<TPoint>::IndexOfCreatedTriangle tmpIndex;
  int indexTrIn = getTriangleIndexInclosingPoint(vertex);
  if(indexTrIn==0 ){
    trace.info() << "Vertex " << vertex << " outside current mesh or along existing edge,";
    trace.info() << " point ignored (not yet implemented)!  " << std::endl;
    return resultingIndex;
  }
  
  tmpIndex = addPointInsideMesh(vertex);
  // Swap test on each new created triangle on face 1 since all new
  // triangles are created with the new point at the last position.
  swapTest(tmpIndex.indexTr1, 1);
  swapTest(tmpIndex.indexTr2, 1);
  swapTest(tmpIndex.indexTr3, 1);
  
  return resultingIndex;

}




template<typename TPoint> 
inline
unsigned int 
DGtal::TriangularMeshFrom2DPoints<TPoint>::getTriangleIndexInclosingPoint(const TPoint & aPoint) const{
  for(unsigned int i=1; i< myTrianglesList.size(); i++){
    if(myTrianglesList.at(i).isActive && isInTriangle(i, aPoint))
      return i;
  }
  return 0;
}




template<typename TPoint> 
inline
unsigned int
DGtal::TriangularMeshFrom2DPoints<TPoint>::getIndexAdjacentVertex(unsigned int indexTriangle, 
								  unsigned int numEdge) const {
  assert(indexTriangle>0);
  MeshTriangle tr = myTrianglesList.at(indexTriangle);
  MeshTriangle trAdj;
  bool isPresent=false;
  if( tr.indexAdjTriangles[numEdge-1] !=0){
    // First and second points of the num th vertex 
    unsigned int  indPt1, indPt2;
    indPt1 = tr.indexesPt[numEdge-1];
    indPt2 = tr.indexesPt[numEdge%3];
    trAdj= myTrianglesList.at(tr.indexAdjTriangles[numEdge-1]);
    if(trAdj.indexesPt[2]!=indPt1 && trAdj.indexesPt[2]!=indPt2){
      return trAdj.indexesPt[2];
    }else if(trAdj.indexesPt[1]!=indPt1 && trAdj.indexesPt[1]!=indPt2){
      return trAdj.indexesPt[1];
    }else if(trAdj.indexesPt[0]!=indPt1 && trAdj.indexesPt[0]!=indPt2){
      return trAdj.indexesPt[0];
    }else{
      return 0;
    }
  }else{
    return 0;
  }
}




template<typename TPoint> 
inline
unsigned int 
DGtal::TriangularMeshFrom2DPoints<TPoint>::getIndexAdjacentTriangle(unsigned int indexTriangle, 
								    unsigned int num) const{
  assert(indexTriangle>0);
  MeshTriangle tr = myTrianglesList.at(indexTriangle);
  return tr.indexAdjTriangles[num-1]; 
}



template<typename TPoint> 
inline
unsigned int 
DGtal::TriangularMeshFrom2DPoints<TPoint>::getNumEdgeFromIndexVertex(unsigned int indexTriangle, unsigned int indPt1, unsigned int indPt2) const {
  assert(indexTriangle>0);
  MeshTriangle tr = myTrianglesList.at(indexTriangle);
  if((tr.indexesPt[0]==indPt1 && tr.indexesPt[1]==indPt2)|| (tr.indexesPt[1]==indPt1 && tr.indexesPt[0]==indPt2)){
    return 1;
  }else if ((tr.indexesPt[1]==indPt1 && tr.indexesPt[2]==indPt2)|| (tr.indexesPt[2]==indPt1 && tr.indexesPt[1]==indPt2)){
    return 2;
  }else if ((tr.indexesPt[2]==indPt1 && tr.indexesPt[0]==indPt2)|| (tr.indexesPt[0]==indPt1 && tr.indexesPt[2]==indPt2)){
    return 3;
  }
  return 0;
}



template<typename TPoint> 
inline
TPoint
DGtal::TriangularMeshFrom2DPoints<TPoint>::getAdjacentVertex(unsigned int indexTriangle, 
							     unsigned int numEdge) const {  
  assert(indexTriangle>0);
  unsigned int indexPt = getIndexAdjacentVertex(indexTriangle, numEdge);
  if(numEdge!=0){
    return myVertexList.at(indexPt);
  }
  else{
    return myVertexList.at(0);
  }
}



template<typename TPoint> 
inline
std::vector<TPoint> 
DGtal::TriangularMeshFrom2DPoints<TPoint>::getTrianglePoints(unsigned int indexTriangle) const {
  assert(indexTriangle>0);
  MeshTriangle tr = myTrianglesList.at(indexTriangle);
  return getTrianglePoints(tr);
}



template<typename TPoint> 
inline
std::vector<TPoint> 
DGtal::TriangularMeshFrom2DPoints<TPoint>::getTrianglePoints(const MeshTriangle &tr) const {
  std::vector<TPoint> result;
  result.push_back(myVertexList.at(tr.indexesPt[0]));
  result.push_back(myVertexList.at(tr.indexesPt[1]));
  result.push_back(myVertexList.at(tr.indexesPt[2]));
  return result;
}





///############


template<typename TPoint>
inline
void 
DGtal::TriangularMeshFrom2DPoints<TPoint>::swapTest(unsigned int indexTriangle, unsigned int numFace){
  unsigned int indexAdjacentVertex = getIndexAdjacentVertex(indexTriangle, numFace);
  if(indexAdjacentVertex == 0){
    return;
  }
  
  MeshTriangle tr = myTrianglesList.at(indexTriangle);
  TPoint ptAdj = myVertexList.at(indexAdjacentVertex);
  if(isInCircle(indexTriangle, ptAdj)){
    if(swapTriangleOnEdge(indexTriangle, 1)){
      unsigned int indexTrNew1 = myTrianglesList.size()-2;
      unsigned int indexTrNew2 = myTrianglesList.size()-1;
      swapTest(indexTrNew1, 1);
      swapTest(indexTrNew2, 1);
    }
  } 
  return;
}











template<typename TPoint> 
inline
bool 
DGtal::TriangularMeshFrom2DPoints<TPoint>::swapTriangleOnEdge(unsigned int indexTriangle, unsigned int num){
  

  MeshTriangle &tr = myTrianglesList.at(indexTriangle);
  if(!tr.isActive){
    return false;
  }
  unsigned int indexAdjacentTr = tr.indexAdjTriangles[num-1];
  MeshTriangle &trAdjacent = myTrianglesList.at(indexAdjacentTr);
  if(indexAdjacentTr==0){
    trace.error() << " No adjacency" << std::endl;
    return false;
  }
  tr.isActive=false;
  trAdjacent.isActive=false;
  MeshTriangle trNew1, trNew2;
  
  // First and second points of the num th vertex and third point of tr: 
  unsigned int  indPt1, indPt2, indPt3;
  indPt1 = tr.indexesPt[num-1];
  indPt2 = tr.indexesPt[num%3];
  indPt3 = tr.indexesPt[(num+1)%3];

  unsigned int indPtAdjacent = getIndexAdjacentVertex(indexTriangle, num);
  
  trNew1.indexesPt[0] = indPtAdjacent;
  trNew1.indexesPt[1] = indPt2;
  trNew1.indexesPt[2] = indPt3;
  trNew1.isActive = true;

  trNew2.indexesPt[0] = indPt1;
  trNew2.indexesPt[1] = indPtAdjacent;
  trNew2.indexesPt[2] = indPt3;
  trNew2.isActive = true;
   
  myTrianglesList.push_back(trNew1);
  myTrianglesList.push_back(trNew2);  
 
  unsigned int indexTrNew1 = myTrianglesList.size()-2;
  unsigned int indexTrNew2 = myTrianglesList.size()-1;
  unsigned int indexTrB = tr.indexAdjTriangles[num-1];



  //----------
  // Updating adjacency of neighboring triangles
  
  // ** Triangles neighboring the main triangle
  unsigned int indexTrA1 = tr.indexAdjTriangles[num%3];
  unsigned int indexTrA2 = tr.indexAdjTriangles[(num+1)%3];
  

  // Adjacency of TrA1 towards TrNew1
  if(indexTrA1 != 0){
    MeshTriangle &trA1 = myTrianglesList.at(indexTrA1);
    unsigned int numFaceOfA1AdjToNew1 = getNumEdgeFromIndexVertex(indexTrA1, indPt2, indPt3);
    trA1.indexAdjTriangles[numFaceOfA1AdjToNew1-1] = indexTrNew1;
  }

  // Adjacency of TrA2 towards TrNew2
  if(indexTrA2 !=0){
    MeshTriangle &trA2 = myTrianglesList.at(indexTrA2);  
    unsigned int numFaceOfA2AdjToNew2  = getNumEdgeFromIndexVertex(indexTrA2, indPt3, indPt1 );
    trA2.indexAdjTriangles[numFaceOfA2AdjToNew2-1] = indexTrNew2;
  }

 
  // **  Triangles neighboring the adjacent triangle trB 
  MeshTriangle &trB = myTrianglesList.at(indexTrB);
  unsigned int numFaceOfBAdjToB2 = getNumEdgeFromIndexVertex(indexTrB, indPt1, indPtAdjacent);
  unsigned int numFaceOfBAdjToB1 = getNumEdgeFromIndexVertex(indexTrB, indPtAdjacent, indPt2);
  unsigned int indexTrB1 = trB.indexAdjTriangles[numFaceOfBAdjToB1-1];
  unsigned int indexTrB2 = trB.indexAdjTriangles[numFaceOfBAdjToB2-1];
  if(indexTrB1 != 0){    
    MeshTriangle & trB1 = myTrianglesList.at(indexTrB1);
    unsigned int numFaceAdjToBInB1 =  getNumEdgeFromIndexVertex(indexTrB1, indPtAdjacent, indPt2);
    trB1.indexAdjTriangles[numFaceAdjToBInB1-1] = indexTrNew1;
  }
  if(indexTrB2!=0){    
    MeshTriangle & trB2 = myTrianglesList.at(indexTrB2);
    unsigned int numFaceAdjToBInB2 =  getNumEdgeFromIndexVertex(indexTrB2, indPt1, indPtAdjacent);
    trB2.indexAdjTriangles[numFaceAdjToBInB2-1] = indexTrNew2;
  }

  

  // Adjacency of new triangles:
  MeshTriangle &tr1n = myTrianglesList.at(indexTrNew1);
  MeshTriangle &tr2n = myTrianglesList.at(indexTrNew2);
  

  unsigned int numFaceNewTr1AdjToA1 = getNumEdgeFromIndexVertex(indexTrNew1, indPt2, indPt3 ); 
  unsigned int numFaceNewTr2AdjToA2 = getNumEdgeFromIndexVertex(indexTrNew2, indPt3, indPt1 ); 

  unsigned int numFaceNewTr1AdjToB1 = getNumEdgeFromIndexVertex(indexTrNew1, indPtAdjacent, indPt2 ); 
  unsigned int numFaceNewTr2AdjToB2 = getNumEdgeFromIndexVertex(indexTrNew2, indPt1, indPtAdjacent ); 

  unsigned int numFaceNewTr1AdjToNewTr2 = getNumEdgeFromIndexVertex(indexTrNew1, indPt3 ,indPtAdjacent );
  unsigned int numFaceNewTr2AdjToNewTr1 = getNumEdgeFromIndexVertex(indexTrNew2, indPt3 ,indPtAdjacent );
 

  tr1n.indexAdjTriangles[numFaceNewTr1AdjToA1-1]= indexTrA1;
  tr1n.indexAdjTriangles[numFaceNewTr1AdjToB1-1]= indexTrB1;
  
  tr1n.indexAdjTriangles[numFaceNewTr1AdjToNewTr2-1]= indexTrNew2;
 
  tr2n.indexAdjTriangles[numFaceNewTr2AdjToA2-1]= indexTrA2;
  tr2n.indexAdjTriangles[numFaceNewTr2AdjToB2-1]= indexTrB2;
  tr2n.indexAdjTriangles[numFaceNewTr2AdjToNewTr1-1]= indexTrNew1;
  
  return true; 
}










template<typename TPoint> 
inline
std::vector<TPoint> 
DGtal::TriangularMeshFrom2DPoints<TPoint>::getTrianglesAsVertexVect() const{
  
  std::vector<TPoint> vectResult;
  for(unsigned int i=1; i< myTrianglesList.size(); i++){
    MeshTriangle triangle = myTrianglesList.at(i);
    if(triangle.isActive){
      vectResult.push_back(myVertexList.at(triangle.indexesPt[0]));
      vectResult.push_back(myVertexList.at(triangle.indexesPt[1]));
      vectResult.push_back(myVertexList.at(triangle.indexesPt[2]));
    }
  }
  return vectResult;
}






template<typename TPoint> 
inline
double 
DGtal::TriangularMeshFrom2DPoints<TPoint>::isSameSide(const TPoint &ptA, const TPoint &ptB,
						      const TPoint &pt1, const  TPoint & pt2) const{
  TPoint u (ptB[0]-ptA[0], ptB[1]-ptA[1]);
  TPoint v1 (pt1[0]-ptA[0], pt1[1]-ptA[1]);
  TPoint v2 (pt2[0]-ptA[0], pt2[1]-ptA[1]);
  double cp1 = u[0]*v1[1]-u[1]*v1[0];
  double cp2 = u[0]*v2[1]-u[1]*v2[0];
  return cp1*cp2;
}



template<typename TPoint> 
inline
bool 
DGtal::TriangularMeshFrom2DPoints<TPoint>::isInTriangle(unsigned int indexTriangle, const TPoint &pt) const{
  return isInTriangle(myTrianglesList.at(indexTriangle), pt);
}


template<typename TPoint> 
inline
bool 
DGtal::TriangularMeshFrom2DPoints<TPoint>::isInTriangle(const  MeshTriangle &triangle, const TPoint &pt) const{
  TPoint ptA = myVertexList.at(triangle.indexesPt[0]);
  TPoint ptB = myVertexList.at(triangle.indexesPt[1]);
  TPoint ptC = myVertexList.at(triangle.indexesPt[2]);
  double isSameSide1 = isSameSide(ptA, ptB, pt, ptC);
  double isSameSide2 = isSameSide(ptB, ptC, pt, ptA);
  double isSameSide3 = isSameSide(ptC, ptA, pt, ptB);
  bool res = isSameSide1>=0.0 && isSameSide2>=0.0 && isSameSide3 >= 0.0; 
  
  // In this case it is an inside point but we ignore it is not yet taken into account.
  if(res && (isSameSide1==0.0 || isSameSide2==0.0 || isSameSide3==0.0)){
    return false;
  }
  return res ;

}



template<typename TPoint> 
inline
bool
DGtal::TriangularMeshFrom2DPoints<TPoint>::isInCircle(unsigned int indexTriangle, unsigned int indexPt) const{
  return isInCircle(indexTriangle, myVertexList.at(indexPtD));   
}





template<typename TPoint> 
inline
bool
DGtal::TriangularMeshFrom2DPoints<TPoint>::isInCircle(unsigned int indexTriangle, const  TPoint &pt) const{
  MeshTriangle tr;
  TPoint ptA = myVertexList.at(myTrianglesList.at(indexTriangle).indexesPt[0]);
  TPoint ptB = myVertexList.at(myTrianglesList.at(indexTriangle).indexesPt[1]); 
  TPoint ptC = myVertexList.at(myTrianglesList.at(indexTriangle).indexesPt[2]);  
  
  SimpleMatrix<double, 4,4> mat;
  mat.setComponent(0, 0,(double) (ptD[0]*ptD[0]+ptD[1]*ptD[1]));
  mat.setComponent(0, 1,(double) ptD[0]);
  mat.setComponent(0, 2,(double) ptD[1]);
  mat.setComponent(0, 3, 1.0 );

  mat.setComponent(1, 0,(double) (ptA[0]*ptA[0]+ptA[1]*ptA[1]));
  mat.setComponent(1, 1,(double) ptA[0]);
  mat.setComponent(1, 2,(double) ptA[1]);
  mat.setComponent(1, 3, 1.0 );

  mat.setComponent(2, 0,(double) (ptB[0]*ptB[0]+ptB[1]*ptB[1]));
  mat.setComponent(2, 1,(double) ptB[0]);
  mat.setComponent(2, 2,(double) ptB[1]);
  mat.setComponent(2, 3, 1.0 );

  mat.setComponent(3, 0,(double) (ptC[0]*ptC[0]+ptC[1]*ptC[1]));
  mat.setComponent(3, 1,(double) ptC[0]);
  mat.setComponent(3, 2,(double) ptC[1]);
  mat.setComponent(3, 3, 1.0 );

  return mat.determinant() > 0.0;
  
}


template< typename TPoint> 
inline 
unsigned int
DGtal::TriangularMeshFrom2DPoints<TPoint>::getNumTriangles() const{
  return myTrianglesList.size();  
}



template <typename TPoint>
inline
std::ostream&
DGtal::operator<< ( std::ostream & out, 
		    const TriangularMeshFrom2DPoints<TPoint> & object )
{
  object.selfDisplay( out );
  return out;
}





//------------------------------------------------------------------------------
template <typename TPoint>
inline
std::string
DGtal::TriangularMeshFrom2DPoints<TPoint>::className() const
{
  return "TriangularMeshFrom2DPoints";
}


//                                                                           //
///////////////////////////////////////////////////////////////////////////////


