/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file MeshFromTriangles.ih
 * @author Bertrand Kerautret (\c kerautre@loria.fr )
 * LORIA (CNRS, UMR 7503), University of Nancy, France
 *
 * @date 2012/06/29
 *
 * Implementation of inline methods defined in MeshFromTriangles.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////

#include <cstdlib>
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------

/**
 * Constructor.
 */
template <typename TPoint>
inline
DGtal::MeshFromTriangles<TPoint>::MeshFromTriangles()
{
  MeshTriangle emptyTriangle;
  emptyTriangle.indexesPt[0]=0; emptyTriangle.indexesPt[1]=0; emptyTriangle.indexesPt[2]=0;
  emptyTriangle.indexAdjTriangles[0]=0; emptyTriangle.indexAdjTriangles[1]=0; emptyTriangle.indexAdjTriangles[2]=0;
  myTrianglesList.push_back(emptyTriangle);

}


/**
 * Constructor.
 */
template <typename TPoint>
inline
DGtal::MeshFromTriangles<TPoint>::MeshFromTriangles(const TPoint &ptLower, const TPoint &ptUpper)
{
  MeshTriangle emptyTriangle;
  emptyTriangle.indexesPt[0]=0; emptyTriangle.indexesPt[1]=0; emptyTriangle.indexesPt[2]=0;
  emptyTriangle.indexAdjTriangles[0]=0; emptyTriangle.indexAdjTriangles[1]=0; emptyTriangle.indexAdjTriangles[2]=0;
  myTrianglesList.push_back(emptyTriangle);
  

  // We compute the two other points of the bounding box
  TPoint ptLowerU (ptLower[0], ptUpper[1]);
  TPoint ptUpperL (ptUpper[0], ptLower[1]);
  
  myVertexList.push_back(ptLowerU);
  myVertexList.push_back(ptUpper);
  myVertexList.push_back(ptUpperL);
  myVertexList.push_back(ptLower);
  
  // Upper triangle
  //  addTriangle(0, 1, 2);
  //  addTriangle(2, 3, 0);
  MeshTriangle tr1;
  MeshTriangle tr2;
  tr1.indexesPt[0]=0;  tr1.indexesPt[1]=1;   tr1.indexesPt[2]=2;
  tr2.indexesPt[0]=2;  tr2.indexesPt[1]=3;   tr2.indexesPt[2]=0;
  myTrianglesList.push_back(tr1);
  myTrianglesList.push_back(tr2);

  
  myTrianglesList.at(1).indexAdjTriangles[0] = 0;
  myTrianglesList.at(1).indexAdjTriangles[1] = 0;
  myTrianglesList.at(1).indexAdjTriangles[2] = 2;
  myTrianglesList.at(2).indexAdjTriangles[0] = 0;
  myTrianglesList.at(2).indexAdjTriangles[1] = 0;
  myTrianglesList.at(2).indexAdjTriangles[2] = 1;

  myTrianglesList.at(0).isActive=false;
  myTrianglesList.at(1).isActive=true;
  myTrianglesList.at(2).isActive=true;
  
}



/**
 * Destructor.
 */
template <typename TPoint>
inline
DGtal::MeshFromTriangles<TPoint>::~MeshFromTriangles()
{
}

///////////////////////////////////////////////////////////////////////////////
// Interface - public :

/**
 * Writes/Displays the object on an output stream.
 * @param out the output stream where the object is written.
 */
template <typename TPoint>
inline
void
DGtal::MeshFromTriangles<TPoint>::selfDisplay ( std::ostream & out ) const
{
  out << "[MeshFromTriangles]";
}

/**
 * Checks the validity/consistency of the object.
 * @return 'true' if the object is valid, 'false' otherwise.
 */
template <typename TPoint>
inline
bool
DGtal::MeshFromTriangles<TPoint>::isValid() const
{
    return true;
}




///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions                                        //

    




//------------------------------------------------------------------------------
template <typename TPoint>
inline
std::string
DGtal::MeshFromTriangles<TPoint>::className() const
{
  return "MeshFromTriangles";
}




template<typename TPoint> 
inline
typename DGtal::MeshFromTriangles<TPoint>::IndexOfCreatedTriangle 
DGtal::MeshFromTriangles<TPoint>::addPointInMesh(const TPoint & vertex ){
  
  typename DGtal::MeshFromTriangles<TPoint>::IndexOfCreatedTriangle resultingIndex;
  
  int indexTrIn = getTriangleIndexInclosing(vertex);
  assert(indexTrIn!=-1);
  
  MeshTriangle tr = myTrianglesList.at(indexTrIn);
  myTrianglesList.at(indexTrIn).isActive=false;
  myVertexList.push_back(vertex);
    
  MeshTriangle newTr1;
  newTr1.indexesPt[0] = tr.indexesPt[0];
  newTr1.indexesPt[1] = tr.indexesPt[1];  
  newTr1.indexesPt[2] = myVertexList.size()-1;
  newTr1.isActive=true;
  myTrianglesList.push_back(newTr1);
  
  resultingIndex.indexTr1=myTrianglesList.size()-1;
  
  MeshTriangle newTr2;
  newTr2.indexesPt[0] = tr.indexesPt[1];
  newTr2.indexesPt[1] = tr.indexesPt[2];
  newTr2.indexesPt[2] = myVertexList.size()-1;
  newTr2.isActive=true;
  myTrianglesList.push_back(newTr2);
  resultingIndex.indexTr2=myTrianglesList.size()-1;
  
  
  MeshTriangle newTr3;
  newTr3.indexesPt[0] = tr.indexesPt[2];
  newTr3.indexesPt[1] = tr.indexesPt[0];
  newTr3.indexesPt[2] = myVertexList.size()-1;
  newTr3.isActive=true;
  myTrianglesList.push_back(newTr3);
  resultingIndex.indexTr3=myTrianglesList.size()-1;
 


  //Setting Adjacency for new faces.
  myTrianglesList.at(myTrianglesList.size()-3).indexAdjTriangles[0] = tr.indexAdjTriangles[0];
  myTrianglesList.at(myTrianglesList.size()-3).indexAdjTriangles[1] = myTrianglesList.size()-2; //&newTr2;
  myTrianglesList.at(myTrianglesList.size()-3).indexAdjTriangles[2] = myTrianglesList.size()-1; //newTr3;

  myTrianglesList.at(myTrianglesList.size()-2).indexAdjTriangles[0] = tr.indexAdjTriangles[1];
  myTrianglesList.at(myTrianglesList.size()-2).indexAdjTriangles[1] = myTrianglesList.size()-1;//&newTr3; 
  myTrianglesList.at(myTrianglesList.size()-2).indexAdjTriangles[2] = myTrianglesList.size()-3;//newTr3;

  myTrianglesList.at(myTrianglesList.size()-1).indexAdjTriangles[0] = tr.indexAdjTriangles[2];
  myTrianglesList.at(myTrianglesList.size()-1).indexAdjTriangles[1] = myTrianglesList.size()-3; //&newTr1;
  myTrianglesList.at(myTrianglesList.size()-1).indexAdjTriangles[2] = myTrianglesList.size()-2; //&newTr2;
  
  //Updating Adjacency towards  new faces.
  
  MeshTriangle &tr1AdjacentNotNew = myTrianglesList.at(myTrianglesList.at(myTrianglesList.size()-3).indexAdjTriangles[0]);
  if(tr1AdjacentNotNew.indexAdjTriangles[0]==indexTrIn){ 
    tr1AdjacentNotNew.indexAdjTriangles[0]  = myTrianglesList.size()-3;
  }else if(tr1AdjacentNotNew.indexAdjTriangles[1]==indexTrIn){ 
    tr1AdjacentNotNew.indexAdjTriangles[1]  = myTrianglesList.size()-3;
  }else if(tr1AdjacentNotNew.indexAdjTriangles[2]==indexTrIn){ 
    tr1AdjacentNotNew.indexAdjTriangles[2]  = myTrianglesList.size()-3;
  }

  MeshTriangle &tr2AdjacentNotNew = myTrianglesList.at(myTrianglesList.at(myTrianglesList.size()-2).indexAdjTriangles[0]);
  if(tr2AdjacentNotNew.indexAdjTriangles[0]==indexTrIn){ 
    tr2AdjacentNotNew.indexAdjTriangles[0]  = myTrianglesList.size()-2;
  }else if(tr2AdjacentNotNew.indexAdjTriangles[1]==indexTrIn){ 
    tr2AdjacentNotNew.indexAdjTriangles[1]  = myTrianglesList.size()-2;
  }else if(tr2AdjacentNotNew.indexAdjTriangles[2]==indexTrIn){ 
    tr2AdjacentNotNew.indexAdjTriangles[2]  = myTrianglesList.size()-2;
  }
  
  MeshTriangle &tr3AdjacentNotNew = myTrianglesList.at(myTrianglesList.at(myTrianglesList.size()-1).indexAdjTriangles[0]);
  if(tr3AdjacentNotNew.indexAdjTriangles[0]==indexTrIn){ 
    tr3AdjacentNotNew.indexAdjTriangles[0]  = myTrianglesList.size()-1;
  }else if(tr3AdjacentNotNew.indexAdjTriangles[1]==indexTrIn){ 
    tr3AdjacentNotNew.indexAdjTriangles[1]  = myTrianglesList.size()-1;
  }else if(tr3AdjacentNotNew.indexAdjTriangles[2]==indexTrIn){ 
    tr3AdjacentNotNew.indexAdjTriangles[2]  = myTrianglesList.size()-1;
  }
  

      
  return resultingIndex;
}


template<typename TPoint> 
inline
std::vector<TPoint> 
DGtal::MeshFromTriangles<TPoint>::getTrianglePointsAdj(unsigned int i, unsigned int adjNum){
  MeshTriangle tr = myTrianglesList.at(i);
  return getTrianglePoints(tr.indexAdjTriangles[adjNum-1]);
}




template<typename TPoint> 
inline
std::vector<TPoint> 
DGtal::MeshFromTriangles<TPoint>::getTrianglePoints(unsigned int i){
  assert(i>=0);
  MeshTriangle tr = myTrianglesList.at(i);
  return getTrianglePoints(tr);
}


template<typename TPoint> 
inline
std::vector<TPoint> 
DGtal::MeshFromTriangles<TPoint>::getTrianglePoints(const MeshTriangle &tr){
  std::vector<TPoint> result;
  result.push_back(myVertexList.at(tr.indexesPt[0]));
  result.push_back(myVertexList.at(tr.indexesPt[1]));
  result.push_back(myVertexList.at(tr.indexesPt[2]));
  return result;
}




template<typename TPoint> 
inline
bool 
DGtal::MeshFromTriangles<TPoint>::flipTriangleOnEdge(unsigned int indexTriangle, unsigned int num){
  MeshTriangle &tr = myTrianglesList.at(indexTriangle);
  MeshTriangle &trAdjacent = myTrianglesList.at(tr.indexAdjTriangles[num-1]);
  tr.isActive=false;
  trAdjacent.isActive=false;
  MeshTriangle trNew1, trNew2;
  unsigned int indexp1, indexp2, indexp3;
  if(num==1){
    indexp1=tr.indexesPt[0];
    indexp2=tr.indexesPt[1];
    indexp3=tr.indexesPt[2];
  }else if(num==2){
    indexp1=tr.indexesPt[1];
    indexp2=tr.indexesPt[2];
    indexp3=tr.indexesPt[0];
  }else if(num==3){
    indexp1=tr.indexesPt[2];
    indexp2=tr.indexesPt[0];
    indexp3=tr.indexesPt[1];
  }
  trNew1.indexesPt[0]=indexp1;
  trNew1.indexesPt[1]=indexp2;
  trNew1.indexesPt[2]=indexp3;
  
  
  return true;  
}



template<typename TPoint> 
inline
TPoint
DGtal::MeshFromTriangles<TPoint>::getAdjacentVertex(unsigned int indexTriangle, 
						    unsigned int num){
  
  MeshTriangle &tr = myTrianglesList.at(indexTriangle);
  MeshTriangle trAdj;
  bool isPresent=false;
  if( tr.indexAdjTriangles[num-1] !=0){
    // First and second points of the num th vertex 
    unsigned int  indPt1, indPt2;
    indPt1 = tr.indexesPt[num-1];
    indPt2 = tr.indexesPt[num%3];
    
    
    trAdj= myTrianglesList.at(tr.indexAdjTriangles[num-1]);
  
    if(trAdj.indexesPt[2]!=indPt1 && trAdj.indexesPt[2]!=indPt2){
      return myVertexList.at(trAdj.indexesPt[2]);
    }else if(trAdj.indexesPt[1]!=indPt1 && trAdj.indexesPt[1]!=indPt2){
      return myVertexList.at(trAdj.indexesPt[1]);
    }else if(trAdj.indexesPt[0]!=indPt1 && trAdj.indexesPt[0]!=indPt2){
      return myVertexList.at(trAdj.indexesPt[0]);
    }else{
      trace.error() << "not found"<<std::endl;
      return TPoint(0,0);
    }
    
  }else{
    trace.error() << "not found"<<std::endl;
    return TPoint(0,0);
  }
 
}





template<typename TPoint> 
inline
int 
DGtal::MeshFromTriangles<TPoint>::getIndexAdjacentTriangle(unsigned int indexTriangle, 
							   unsigned int num){
    MeshTriangle &tr = myTrianglesList.at(indexTriangle);
    return tr.indexAdjTriangles[num-1];
    
}


template<typename TPoint> 
inline
std::vector<TPoint> 
DGtal::MeshFromTriangles<TPoint>::getTrianglesFromVertex() const{
  
  std::vector<TPoint> vectResult;
  for(unsigned int i=0; i< myTrianglesList.size(); i++){
    MeshTriangle triangle = myTrianglesList.at(i);
    if(triangle.isActive){
      vectResult.push_back(myVertexList.at(triangle.indexesPt[0]));
      vectResult.push_back(myVertexList.at(triangle.indexesPt[1]));
      vectResult.push_back(myVertexList.at(triangle.indexesPt[2]));
    }
  }
  return vectResult;
}


template<typename TPoint> 
inline
void 
DGtal::MeshFromTriangles<TPoint>::addVertex(const TPoint &aPoint){
  myVertexList.push_back(aPoint);    
}


template<typename TPoint>
inline 
void
DGtal::MeshFromTriangles<TPoint>::addTriangle(unsigned int index1, 
					      unsigned int index2,  unsigned int index3 ){
  MeshTriangle triangle;
  triangle.indexesPt[0] = index1;
  triangle.indexesPt[1] = index2;
  triangle.indexesPt[2] = index3;
  triangle.indexAdjTriangles[0]=0;
  triangle.indexAdjTriangles[1]=0;
  triangle.indexAdjTriangles[2]=0;
  triangle.isActive=true;
  myTrianglesList.push_back(triangle);
}



template<typename TPoint> 
inline
bool 
DGtal::MeshFromTriangles<TPoint>::isSameSide(const TPoint &ptA, const TPoint &ptB, const TPoint &pt1, const  TPoint & pt2){
  TPoint u (ptB[0]-ptA[0], ptB[1]-ptA[1]);
  TPoint v1 (pt1[0]-ptA[0], pt1[1]-ptA[1]);
  TPoint v2 (pt2[0]-ptA[0], pt2[1]-ptA[1]);
  double cp1 = u[0]*v1[1]-u[1]*v1[0];
  double cp2 = u[0]*v2[1]-u[1]*v2[0];
  return cp1*cp2 >=0;
}



template<typename TPoint> 
inline
bool 
DGtal::MeshFromTriangles<TPoint>::isInTriangle(unsigned int indexTriangle, const TPoint &pt){
  return isInTriangle(myTrianglesList.at(indexTriangle), pt);
}


template<typename TPoint> 
inline
bool 
DGtal::MeshFromTriangles<TPoint>::isInTriangle(const  MeshTriangle &triangle, const TPoint &pt){
  TPoint ptA = myVertexList.at(triangle.indexesPt[0]);
  TPoint ptB = myVertexList.at(triangle.indexesPt[1]);
  TPoint ptC = myVertexList.at(triangle.indexesPt[2]);
  
  return isSameSide(ptA, ptB, pt, ptC) && isSameSide(ptB, ptC, pt, ptA) && isSameSide(ptC, ptA, pt, ptB);

}



template<typename TPoint> 
inline
int 
DGtal::MeshFromTriangles<TPoint>::getTriangleIndexInclosing(TPoint p){
  for(unsigned int i=0; i< myTrianglesList.size(); i++){
    if(isInTriangle(i, p) && myTrianglesList.at(i).isActive)
      return i;
  }
  trace.error() << "no include"<< std::endl;
    return -1;
}


template<typename TPoint> 
inline
bool
DGtal::MeshFromTriangles<TPoint>::isInCircle(unsigned int indexTriangle, const  TPoint &ptD){
  MeshTriangle tr;
  TPoint ptA = myVertexList.at(myTrianglesList.at(indexTriangle).indexesPt[0]);
  TPoint ptB = myVertexList.at(myTrianglesList.at(indexTriangle).indexesPt[1]); 
  TPoint ptC = myVertexList.at(myTrianglesList.at(indexTriangle).indexesPt[2]);  
  
  SimpleMatrix<double, 4,4> mat;
  mat.setComponent(0, 0,(double) (ptD[0]*ptD[0]+ptD[1]*ptD[1]));
  mat.setComponent(0, 1,(double) ptD[0]);
  mat.setComponent(0, 2,(double) ptD[1]);
  mat.setComponent(0, 3, 1.0 );

  mat.setComponent(1, 0,(double) (ptA[0]*ptA[0]+ptA[1]*ptA[1]));
  mat.setComponent(1, 1,(double) ptA[0]);
  mat.setComponent(1, 2,(double) ptA[1]);
  mat.setComponent(1, 3, 1.0 );

  mat.setComponent(2, 0,(double) (ptB[0]*ptB[0]+ptB[1]*ptB[1]));
  mat.setComponent(2, 1,(double) ptB[0]);
  mat.setComponent(2, 2,(double) ptB[1]);
  mat.setComponent(2, 3, 1.0 );

  mat.setComponent(3, 0,(double) (ptC[0]*ptC[0]+ptC[1]*ptC[1]));
  mat.setComponent(3, 1,(double) ptC[0]);
  mat.setComponent(3, 2,(double) ptC[1]);
  mat.setComponent(3, 3, 1.0 );

  return mat.determinant() > 0.0;
  
}


template <typename TPoint>
inline
std::ostream&
DGtal::operator<< ( std::ostream & out, 
		    const MeshFromTriangles<TPoint> & object )
{
  object.selfDisplay( out );
  return out;
}

//                                                                           //
///////////////////////////////////////////////////////////////////////////////


