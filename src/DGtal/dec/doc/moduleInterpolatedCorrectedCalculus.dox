/**
 * @file
 * @author Colin Weill--Duflos (\c colin.weill-duflos@univ-smb.fr )
 * Laboratory of Mathematics (CNRS, UMR 5127), University of Savoie, France
 *
 * @date 2024/06/05
 *
 * Documentation file for feature InterpolatedCorrectedCalculus
 *
 * This file is part of the DGtal library.
 */

/*
 * Useful to avoid writing DGtal:: in front of every class.
 * Do not forget to add an entry in src/DGtal/base/Config.h.in !
 */
namespace DGtal {
//----------------------------------------
/*!
@page moduleInterpolatedCorrectedCalculus Interpolated Normals corrected DEC on digital surfaces
@writers Colin Weill--Duflos

[TOC]

@since 1.5

  Part of package \ref packageDEC.

In this documentation page, we detail the operators and tools for differential
 calculus computations on digital surfaces equipped with a normal field at vertices.

The method use for building operators is similar to \ref modulePolygonalCalculus ,
except that it assumes that the surface it is built on is a digital surface and
that it has corrected normal on vertices that are then interpolated when computing operators.

@note The sign convention for the divergence and the Laplacian
operator is opposite to the one of @cite degoes2020discrete. This is
to match the usual mathematical convention that the Laplacian (and the
Laplacian-Beltrami) has negative eigenvalues (and is the sum of second
derivatives in the cartesian grid). It also follows the formal
adjointness of exterior derivative and opposite of divergence as
relation \f$ \langle \mathrm{d} u, v \rangle = - \langle u,
\mathrm{div} v \rangle \f$. See also
https://en.wikipedia.org/wiki/Laplaceâ€“Beltrami_operator

@note All illustrations below have been obtained using the
DGtal+[polyscope](https://polyscope.run) example \ref dgtalCC-poisson.cpp. To build these examples, enable the `BUILD_POLYSCOPE_EXAMPLES` variable (e.g. `cmake .. -DBUILD_POLYSCOPE_EXAMPLES=ON`).

@warning The implementation heavily relies on implicit operators with many Eigen based small matrice constructions, which has a huge overhead in Debug mode. Please consider to build the examples in Release (*e.g.* `CMAKE_BUILD_TYPE` variable) for high performance on large geometrical objects.



\section sectInterpolatedCorrectedCalcIntro Introduction

We provide the same operators as those described in \cite degoes2020discrete . All of them are accessible as
 global and local operators through the implementation of SurfaceDEC. See \ref moduleDECIntroduction for a more thorough introduction to DEC concepts.

The main difference compared to other provided DEC implementation is the fact that normals are not considered constant through the faces,
but as defined at vertices and the bilinearly interpolated during calculations. One of the key difference of this approach
 is that the corrected geometry is continuous at edges.

\section sectInterpolatedCorrectedCalcFace Operators

\subsection sectInterpolatedCorrectedbuilding Building the object


Let us consider a single face digital surface (i.e. : a square). Using :

@code
using CC = InterpolatedCorrectedCalculus<EigenLinearAlgebraBackend, Z3i::RealPoint, Z3i::RealVector>;
using SurfMesh = SurfaceMesh<Z3i::RealPoint,Z3i::RealVector>;
using namespace Z3i;

//Vertices
std::vector<RealPoint> positions={ {0,0,0},{1,0,0},{1,1,0},{0,0,1} };
//Single face
std::vector<std::vector<size_t>> faces={{ 0,1,2,3 }};

mesh = SurfMesh(positions.begin(),positions.end(),faces.begin(),faces.end());
// We require normal at vertices. For digital surfaces, prefer using a convergent estimator
mesh.computeFaceNormalsFromPositions();
mesh.computeVertexNormalsFromFaceNormals();

CC calculus(mesh);
@endcode

we obtain a SurfaceMesh instance with a unique face, we add the naturally defined normal
to it and we define its associated InterpolatedCorrectedCalculus object.

\subsection sectInterpolatedCorrectedLambda Second order normal interpolation, regularization parameter

Note that the constructor takes two optional parameters : wether or not to use second order normal interpolation (defaults to false),
and a regularization parameter lambda (defaults to 0.1).

Second normal interpolation uses average values of normals, normalized, at edge midpoints to use a second order
normal interpolation instead of the bilinear interpolation used in computations. This does not require more
values of normals and thus the normal field used is not, in itself, more precise, but this avoid interpolated
values of normal with a norm too far from 1.

Lambda is the same regularization parameter that appears in
\cite degoes2020discrete when building the product between 1 forms and the Lapalce-Beltrami operator.

We can use second order interpolation as well as a different value for this lambda, here 0.5 :
@code
CC calculus(mesh, true, 0.5);
@endcode

\subsection sectInterpolatedCorrectedbuildingop Building the operators

The following operators can be built, both using local (per face) or global variants. Here @f$ n_v@f$, @f$ n_e @f$ and @f$ n_f @f$
denote the number of vertices, edges and faces of the surface and @f$ deg(f) @f$ the degree of face f.

Operator  | Local Variant | Local shape | Global variant | Global shape
--|--|--|--|--
D0 : differential for 0 forms       | `calculus.localD0(f);`    | @f$ deg(f) \times deg(f) @f$   | `calculus.D0()`      | @f$ n_e \times n_v @f$
M0 : inner product between 0 forms  | `calculus.localM0(f);`    | @f$ deg(f) \times deg(f) @f$   | `calculus.M0()`      | @f$ n_v \times n_v @f$
lumpedM0 : diagonal version of M0 (less accurate, easier to inverse)  |     |                    | `calculus.lumpedM0()`| @f$ n_v \times n_v @f$
M1 : inner product between 1 forms  | `calculus.localM1(f);`    | @f$ deg(f) \times deg(f) @f$   | `calculus.M1()`      | @f$ n_e \times n_e @f$
M2 : inner product between 2 forms  | `calculus.localM2(f);`    | @f$ 1 \times 1         @f$   | `calculus.M2()`      | @f$ n_f \times n_f @f$
Sharp                               | `calculus.localSharp(f);` | @f$ 3 \times deg(f) @f$   | `calculus.Sharp()`   | @f$ 3n_f \times n_e @f$
Flat                                | `calculus.localFlat(f);`  | @f$ deg(f) \times 3 @f$   | `calculus.Flat()`    | @f$ n_e \times 3n_f @f$
L0 : integrated Laplace-Beltrami    | `calculus.localL0(f);`    | @f$ deg(f) \times deg(f) @f$   | `calculus.L0()`      | @f$ n_v \times n_v @f$

Vectors fields are represented by one vector of size @f$ 3 n_f @f$ (for a field defined at faces), whith the first
@f$n_f@f$ values containing the x coordinates, then the next @f$n_f@f$ the y coordinates and the last @f$n_f@f$ the z
coordinates.

Let us add a scalar function on vertices. For instance, using Eigen syntax, we can use;

@code
CC::DenseVector phi(4); //4 vertices
phi << 1.0, 2.0, 0.0, 5.0;
@endcode

We can compute the gradient of this function using DEC formulas : @f$\nabla f = (d f)^\sharp @f$.

Since we have a unique face, we can compute it locally or globally and obtain the same result.

The local approach would be :
@code
CC::DenseVector localGrad = calculus.localSharp(0) * calculus.localD0(0) * phi;
@endcode

The global approach would be :
@code
CC::DenseVector grad = calculus.Sharp() * calculus.D0() * phi;
@endcode

In a similar manner, we can compute the (integrated) divergence of this gradient either locally or globally, using @f$\nabla . \mathbf(u) = *d*\mathbf(u)^\flat @f$.
Since we use the integrated version (to havoid having to inverse M0), we only have to compute @f$ d*\mathbf(u)^\flat @f$

Locally :
@code
CC::DenseVector localDiv = calculus.localD0(0).transpose() * calculus.localM1(0) * calculus.localFlat(0) * localGrad;
@endcode

Globally :
@code
CC::DenseVector div = calculus.D0().transpose() * calculus.M1() * calculus.Flat() * localGrad;
@endcode

\section sectInterpolatedCorrectedCalcPoisson Example: Solving a Laplace problem

Let suppose we want to solve the following Laplace problem for data interpolation:
\f{eqnarray*}{
        \Delta_\Omega u& = 0  \\
        & s.t. u = g \text{ on } \partial\Omega
\f}

We want to solve that problem on a digital surface @f$\Omega@f$
 with a boundary and some scalar values attached
to boundary vertices, or sampled on the object surface.

Furthermore, the discrete version of the Laplace problem boils down to
a simple linear problem using on the discrete Laplace-Beltrami sparse
matrix.

We also use class DirichletConditions to enforce Dirichlet boundary
conditions on the system.

The overall code is:
\snippet dgtalCC-poisson.cpp CC-init

Leading to the following results (see \ref dgtalCC-poisson.cpp):

Surface  | Boundary condition @f$ g@f$ | Solution @f$ u @f$
--|--|--
@image html images/cc/poisson-cc-surf.png "" | @image html images/cc/poisson-cc-g.png "" | @image html images/cc/poisson-cc-u.png ""

*/

}
