/**
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESSpace FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file Viewer3D.ih
 * @author Bertrand Kerautret (\c kerautre@loria.fr )
 * LORIA (CNRS, UMR 7503), University of Nancy, France
 *
 * @date 2011/01/03
 *
 * Implementation of inline methods defined in Viewer3D.h
 *
 * This file is part of the DGtal library.
 */

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
#ifdef _MSC_VER
#define NOMINMAX
#include <windows.h>
#include <GL/gl.h>
#include "DGtal/io/viewers/windows/GL/glext.h"
#endif

#include "DGtal/io/viewers/Viewer3D.h"

#include <algorithm> 
#include <limits>
#include <QColor>
#include <QTextEdit>
#include <QMessageBox>
#include <QTextStream>
#include <QDir>

#include <cstdlib>
#include "DGtal/io/CDrawableWithDisplay3D.h"
#include "DGtal/io/viewers/CDrawableWithViewer3D.h"
#include "DGtal/io/viewers/Viewer3DFactory.h"
#include "QGLViewer/manipulatedFrame.h"
#include "QGLViewer/manipulatedCameraFrame.h"
//////////////////////////////////////////////////////////////////////////////

using namespace std;
using namespace qglviewer;

///////////////////////////////////////////////////////////////////////////////
// Implementation of inline methods //



template < typename Space ,typename KSpace >
inline
void
DGtal::Viewer3D<Space, KSpace>::rotateDomain(Image2DDomainD3D &anDom, double angleRotation,
                                             ImageDirection rotationDir){
  DGtal::PointVector<3, int> pt;
  pt[0] = (int) (anDom.point1[0]+anDom.point2[0]+anDom.point3[0]+anDom.point4[0])/4.0;
  pt[1] = (int) (anDom.point1[1]+anDom.point2[1]+anDom.point3[1]+anDom.point4[1])/4.0;
  pt[2] = (int) (anDom.point1[2]+anDom.point2[2]+anDom.point3[2]+anDom.point4[2])/4.0;
  rotateImageVertex(anDom, angleRotation, rotationDir);
  
  std::vector<typename DGtal::Display3D<Space, KSpace>::LineD3D> &aVectLine = Viewer3D<Space, KSpace>::myLineSetList.at(anDom.myLineSetIndex);
  for(unsigned int i = 0; i< aVectLine.size();i++){
    typename DGtal::Display3D<Space, KSpace>::LineD3D &aLine = aVectLine.at(i);
    rotateLineD3D(aLine, pt, angleRotation, rotationDir );
  }

}


template < typename Space ,typename KSpace >
template <typename TValues>
inline
void
DGtal::Viewer3D<Space, KSpace>::rotatePoint(TValues &x, TValues &y, TValues &z,
                                            double cx, double cy, double cz,
                                            double angleRotation, ImageDirection rotationDir){
  double dx = x-cx; double dy = y-cy; double dz = z-cz;
  if(rotationDir  == zDirection){
    x = cx+dx*cos(angleRotation)-dy*sin(angleRotation);
    y = cy+dx*sin(angleRotation)+dy*cos(angleRotation);
  }
  if(rotationDir  == yDirection){
    x = cx+dx*cos(angleRotation)-dz*sin(angleRotation);
    z = cz+dx*sin(angleRotation)+dz*cos(angleRotation);
  }
  if(rotationDir  == xDirection){
    y = cy+dy*cos(angleRotation)-dz*sin(angleRotation);
    z = cz+dy*sin(angleRotation)+dz*cos(angleRotation);
  }
}




template < typename Space ,typename KSpace >
inline
void
DGtal::Viewer3D<Space, KSpace>::rotateLineD3D(typename DGtal::Display3D<Space, KSpace>::LineD3D &aLine,
                                              DGtal::PointVector<3, int> pt,
                                              double angleRotation, ImageDirection dirRotation){
  double dx1 = aLine.point1[0] - pt[0]; double dy1 = aLine.point1[1] - pt[1]; double dz1 = aLine.point1[2] - pt[2];
  double dx2 = aLine.point2[0] - pt[0]; double dy2 = aLine.point2[1] - pt[1]; double dz2 = aLine.point2[2] - pt[2];
  if(dirRotation==zDirection){
     aLine.point1[0]=pt[0]+dx1*std::cos(angleRotation)-dy1*std::sin(angleRotation);
     aLine.point1[1]=pt[1]+dx1*std::sin(angleRotation)+dy1*std::cos(angleRotation);

     aLine.point2[0]=pt[0]+dx2*std::cos(angleRotation)-dy2*std::sin(angleRotation);
     aLine.point2[1]=pt[1]+dx2*std::sin(angleRotation)+dy2*std::cos(angleRotation);

  }else if(dirRotation==xDirection){
    aLine.point1[1]=pt[1]+dy1*std::cos(angleRotation)-dz1*std::sin(angleRotation);
    aLine.point1[2]=pt[2]+dy1*std::sin(angleRotation)+dz1*std::cos(angleRotation);

    aLine.point2[1]=pt[1]+dy2*std::cos(angleRotation)-dz2*std::sin(angleRotation);
    aLine.point2[2]=pt[2]+dy2*std::sin(angleRotation)+dz2*std::cos(angleRotation);
  }else  if(dirRotation==yDirection){
    aLine.point1[0]=pt[0]+dx1*std::cos(angleRotation)-dz1*std::sin(angleRotation);
    aLine.point1[2]=pt[2]+dx1*std::sin(angleRotation)+dz1*std::cos(angleRotation);

    aLine.point2[0]=pt[0]+dx2*std::cos(angleRotation)-dz2*std::sin(angleRotation);
    aLine.point2[2]=pt[2]+dx2*std::sin(angleRotation)+dz2*std::cos(angleRotation);
  }else{
    trace.error() << "No direction!!"<< std::endl;
  }

}


template < typename Space ,typename KSpace >
inline
unsigned int
DGtal::Viewer3D< Space ,KSpace >::getCurrentDomainNumber()
{
  return myImageDomainList.size();
}

template < typename Space ,typename KSpace >
inline
unsigned int
DGtal::Viewer3D< Space ,KSpace >::getCurrentGLImageNumber()
{
  return myGSImageList.size();
}


template < typename Space ,typename KSpace >
inline
void
DGtal::Viewer3D< Space ,KSpace >::addTextureImage(const typename Viewer3D< Space ,KSpace >::TextureImage &image)
{
  myGSImageList.push_back(image);
  Display3D< Space, KSpace>::updateBoundingBox(image.point1);
  Display3D< Space, KSpace>::updateBoundingBox(image.point2);
  Display3D< Space, KSpace>::updateBoundingBox(image.point3);
  Display3D< Space, KSpace>::updateBoundingBox(image.point4);
}



template < typename Space ,typename KSpace >
template < typename TImageType, typename TFunctor >
inline
void
DGtal::Viewer3D< Space ,KSpace >::updateTextureImage(unsigned int imageIndex, const TImageType & image, const TFunctor & aFunctor,
                                                     double xTranslation, double yTranslation, double zTranslation,
                                                     double rotationAngle, ImageDirection rotationDir)
{
  BOOST_CONCEPT_ASSERT(( concepts::CConstImage < TImageType > ));
  assert ( imageIndex< myGSImageList.size());
  typename Viewer3D< Space ,KSpace >::TextureImage &anImage = myGSImageList.at(imageIndex);
  Display::updateBoundingBox(RealPoint(anImage.point1[0]+xTranslation,
                                                   anImage.point1[1]+yTranslation,
                                                   anImage.point1[2]+zTranslation));
  Display::updateBoundingBox(RealPoint(anImage.point2[0]+xTranslation,
                                                   anImage.point2[1]+yTranslation,
                                                   anImage.point2[2]+zTranslation));
  Display::updateBoundingBox(RealPoint(anImage.point3[0]+xTranslation,
                                                   anImage.point3[1]+yTranslation,
                                                   anImage.point3[2]+zTranslation));
  Display::updateBoundingBox(RealPoint(anImage.point4[0]+xTranslation,
                                                   anImage.point4[1]+yTranslation,
                                                   anImage.point4[2]+zTranslation));
  anImage.updateImageDataAndParam(image, aFunctor, xTranslation, yTranslation, zTranslation);
  if(anImage.myDrawDomain)
    {
      *this << DGtal::Translate2DDomain(anImage.myIndexDomain, xTranslation, yTranslation, zTranslation);
    }

  if(rotationAngle!=0.0){
    rotateDomain(myImageDomainList.at(anImage.myIndexDomain), rotationAngle, rotationDir);
    rotateImageVertex(anImage, rotationAngle, rotationDir);
  }
}


template < typename Space ,typename KSpace >
inline
void
DGtal::Viewer3D< Space ,KSpace >::updateOrientationTextureImage(unsigned int imageIndex,
                                                                double xPosition,
                                                                double yPosition,
                                                                double zPosition,
                                                                ImageDirection newDirection)
{
  assert ( imageIndex< myGSImageList.size());
  typename Viewer3D< Space ,KSpace >::TextureImage &anImage = myGSImageList.at(imageIndex);
  Display3D< Space, KSpace>::updateBoundingBox(anImage.point1);
  Display3D< Space, KSpace>::updateBoundingBox(anImage.point2);
  Display3D< Space, KSpace>::updateBoundingBox(anImage.point3);
  Display3D< Space, KSpace>::updateBoundingBox(anImage.point4);
  anImage.updateImageOrientation(newDirection, xPosition, yPosition, zPosition);
  if(anImage.myDrawDomain)
    {
      *this << DGtal::Update2DDomainPosition<Space ,KSpace >(anImage.myIndexDomain,
                                                             newDirection,
                                                             xPosition,
                                                             yPosition, zPosition);
    }
}

template < typename Space ,typename KSpace >
inline
void
DGtal::Viewer3D<Space, KSpace>::updateEmbeddingTextureImage(unsigned int anImageIndex,
                            typename Space::Point aPoint1, typename Space::Point aPoint2,
                            typename Space::Point aPoint3, typename Space::Point aPoint4)
{
  assert ( anImageIndex< myGSImageList.size());
  typename Viewer3D< Space ,KSpace >::TextureImage &anImage = myGSImageList.at(anImageIndex);
  Display3D< Space, KSpace>::updateBoundingBox(aPoint1);
  Display3D< Space, KSpace>::updateBoundingBox(aPoint2);
  Display3D< Space, KSpace>::updateBoundingBox(aPoint3);
  Display3D< Space, KSpace>::updateBoundingBox(aPoint4);
  anImage.updateImage3DEmbedding(aPoint1, aPoint2, aPoint3, aPoint4);
}




template < typename Space ,typename KSpace >
inline
void
DGtal::Viewer3D< Space ,KSpace >::TextureImage::updateImageOrientation( ImageDirection normalDir,
                                                                        double xBottomLeft, double yBottomLeft, double zBottomLeft)
{
  if(normalDir==zDirection)
    {
      point1[0] = xBottomLeft-0.5; point1[1] = yBottomLeft-0.5; point1[2] = zBottomLeft;
      point2[0] = xBottomLeft+myImageWidth-0.5; point2[1] = yBottomLeft-0.5; point2[2] = zBottomLeft;
      point3[0] = xBottomLeft+myImageWidth-0.5; point3[1] = yBottomLeft+myImageHeight-0.5; point3[2] = zBottomLeft;
      point4[0] = xBottomLeft-0.5; point4[1] = yBottomLeft+myImageHeight-0.5; point4[2] = zBottomLeft;
    }else if(normalDir==yDirection)
    {
      point1[0] = xBottomLeft-0.5; point1[1] = yBottomLeft; point1[2] = zBottomLeft-0.5;
      point2[0] = xBottomLeft+myImageWidth-0.5; point2[1] = yBottomLeft; point2[2] = zBottomLeft-0.5;
      point3[0] = xBottomLeft+myImageWidth-0.5; point3[1] = yBottomLeft; point3[2] = zBottomLeft+myImageHeight-0.5;
      point4[0] = xBottomLeft-0.5; point4[1] = yBottomLeft; point4[2] = zBottomLeft+myImageHeight-0.5;
    }else if(normalDir==xDirection)
    {
      point1[0] = xBottomLeft; point1[1] = yBottomLeft-0.5; point1[2]= zBottomLeft-0.5;
      point2[0] = xBottomLeft; point2[1] = yBottomLeft+myImageWidth-0.5; point2[2] = zBottomLeft-0.5;
      point3[0] = xBottomLeft; point3[1] = yBottomLeft+myImageWidth-0.5; point3[2] = zBottomLeft+myImageHeight-0.5;
      point4[0] = xBottomLeft; point4[1] = yBottomLeft-0.5; point4[2] = zBottomLeft+myImageHeight-0.5;
    }
  myDirection=normalDir;
}

template < typename Space ,typename KSpace >
inline
void
DGtal::Viewer3D< Space ,KSpace >::Image2DDomainD3D::updateDomainOrientation(ImageDirection normalDir,
                                                                            double xBottomLeft, double yBottomLeft, double zBottomLeft)
{
  if(normalDir==zDirection)
    {
      point1[0] = xBottomLeft-0.5; point1[1] = yBottomLeft-0.5; point1[2] = zBottomLeft;
      point2[0] = xBottomLeft+myDomainWidth-0.5; point2[1] = yBottomLeft-0.5; point2[2] = zBottomLeft;
      point3[0] = xBottomLeft+myDomainWidth-0.5; point3[1] = yBottomLeft+myDomainHeight-0.5; point3[2] = zBottomLeft;
      point4[0] = xBottomLeft-0.5; point4[1] = yBottomLeft+myDomainHeight-0.5; point4[2] = zBottomLeft;
    }else if(normalDir==yDirection)
    {
      point1[0] = xBottomLeft-0.5; point1[1] = yBottomLeft; point1[2] = zBottomLeft-0.5;
      point2[0] = xBottomLeft+myDomainWidth-0.5; point2[1] = yBottomLeft; point2[2] = zBottomLeft-0.5;
      point3[0] = xBottomLeft+myDomainWidth-0.5; point3[1] = yBottomLeft; point3[2] = zBottomLeft+myDomainHeight-0.5;
      point4[0] = xBottomLeft-0.5; point4[1] = yBottomLeft; point4[2] = zBottomLeft+myDomainHeight-0.5;
    }else if(normalDir==xDirection)
    {
      point1[0] = xBottomLeft; point1[1] = yBottomLeft-0.5; point1[2]= zBottomLeft-0.5;
      point2[0] = xBottomLeft; point2[1] = yBottomLeft+myDomainWidth-0.5; point2[2] = zBottomLeft-0.5;
      point3[0] = xBottomLeft; point3[1] = yBottomLeft+myDomainWidth-0.5; point3[2] = zBottomLeft+myDomainHeight-0.5;
      point4[0] = xBottomLeft; point4[1] = yBottomLeft-0.5; point4[2] = zBottomLeft+myDomainHeight-0.5;
    }
  myDirection=normalDir;
}


template < typename Space ,typename KSpace >
inline
void
DGtal::Viewer3D< Space ,KSpace >::Image2DDomainD3D::translateDomain (double xTranslation,
                                                                     double yTranslation,
                                                                     double zTranslation)
{
  point1[0] += xTranslation; point1[1] += yTranslation; point1[2] += zTranslation;
  point2[0] += xTranslation; point2[1] += yTranslation; point2[2] += zTranslation;
  point3[0] += xTranslation; point3[1] += yTranslation; point3[2] += zTranslation;
  point4[0] += xTranslation; point4[1] += yTranslation; point4[2] += zTranslation;
}


template < typename Space ,typename KSpace >
template < typename TDomain>
void
DGtal::Viewer3D< Space ,KSpace >::addImage2DDomainD3D(const TDomain &aDomain,
                                                      std::string mode,
                                                      const DGtal::Color &aColor)
{
  typename DGtal::Viewer3D< Space ,KSpace >::Image2DDomainD3D anImageDomain(aDomain);
  anImageDomain.color = aColor;
  anImageDomain.myMode = mode;
  anImageDomain.myLineSetIndex=Viewer3D<Space, KSpace>::myLineSetList.size();

  myImageDomainList.push_back(anImageDomain);
  Display3D< Space, KSpace>::updateBoundingBox(anImageDomain.point1);
  Display3D< Space, KSpace>::updateBoundingBox(anImageDomain.point2);
  Display3D< Space, KSpace>::updateBoundingBox(anImageDomain.point3);
  Display3D< Space, KSpace>::updateBoundingBox(anImageDomain.point4);

  std::vector<typename DGtal::Viewer3D< Space ,KSpace >::LineD3D> vectLines= compute2DDomainLineRepresentation(anImageDomain);
  Viewer3D<Space, KSpace>::myLineSetList.push_back(vectLines);
}


template < typename Space ,typename KSpace >
inline
std::vector<typename DGtal::Viewer3D< Space ,KSpace >::LineD3D>
DGtal::Viewer3D< Space ,KSpace >::compute2DDomainLineRepresentation( typename DGtal::Viewer3D< Space ,KSpace >::Image2DDomainD3D &anImageDomain )
{
  std::vector<typename DGtal::Viewer3D< Space ,KSpace >::LineD3D> vectLinesResu= compute2DDomainLineRepresentation(anImageDomain, 0.05);
  std::vector<typename DGtal::Viewer3D< Space ,KSpace >::LineD3D> vectLinesVerso= compute2DDomainLineRepresentation(anImageDomain, -0.05);
  for(unsigned int i=0; i<vectLinesVerso.size(); i++)
    {
      vectLinesResu.push_back(vectLinesVerso.at(i));
    }
  return vectLinesResu;
}


template < typename Space ,typename KSpace >
inline
std::vector<typename DGtal::Viewer3D< Space ,KSpace >::LineD3D>
DGtal::Viewer3D< Space ,KSpace >::compute2DDomainLineRepresentation(typename DGtal::Viewer3D< Space ,KSpace >::Image2DDomainD3D &anImageDomain, double delta )
{
  std::vector<typename DGtal::Viewer3D< Space ,KSpace >::LineD3D> aLineSet;
  typename Viewer3D<Space, KSpace>::LineD3D aLine;
  aLine.color = anImageDomain.color;
  aLine.width=0.1;

  if( anImageDomain.myMode=="BoundingBox")
    {
      aLine.point1[0]=anImageDomain.point1[0]; aLine.point1[1]=anImageDomain.point1[1]; aLine.point1[2]=anImageDomain.point1[2];
      aLine.point2[0]=anImageDomain.point2[0]; aLine.point2[1]=anImageDomain.point2[1]; aLine.point2[2]=anImageDomain.point2[2];
      aLineSet.push_back(aLine);
      aLine.point1[0]=anImageDomain.point2[0]; aLine.point1[1]=anImageDomain.point2[1]; aLine.point1[2]=anImageDomain.point2[2];
      aLine.point2[0]=anImageDomain.point3[0]; aLine.point2[1]=anImageDomain.point3[1]; aLine.point2[2]=anImageDomain.point3[2];
      aLineSet.push_back(aLine);
      aLine.point1[0]=anImageDomain.point3[0]; aLine.point1[1]=anImageDomain.point3[1]; aLine.point1[2]=anImageDomain.point3[2];
      aLine.point2[0]=anImageDomain.point4[0]; aLine.point2[1]=anImageDomain.point4[1]; aLine.point2[2]=anImageDomain.point4[2];
      aLineSet.push_back(aLine);
      aLine.point1[0]=anImageDomain.point4[0]; aLine.point1[1]=anImageDomain.point4[1]; aLine.point1[2]=anImageDomain.point4[2];
      aLine.point2[0]=anImageDomain.point1[0]; aLine.point2[1]=anImageDomain.point1[1]; aLine.point2[2]=anImageDomain.point1[2];
      aLineSet.push_back(aLine);
    }else if(anImageDomain.myMode=="InterGrid")
    {
      if(anImageDomain.myDirection==zDirection)
        {
          //lines align to the x direction
          for(unsigned int i=0; i <= anImageDomain.myDomainHeight; i++)
            {
              aLine.point1[0] = anImageDomain.point1[0]; aLine.point1[1] = anImageDomain.point1[1]+i; aLine.point1[2] = anImageDomain.point1[2]+delta;
              aLine.point2[0] = anImageDomain.point2[0]; aLine.point2[1] = anImageDomain.point2[1]+i; aLine.point2[2] = anImageDomain.point2[2]+delta;
              aLineSet.push_back(aLine);
            }
          //lines align to the y direction
          for(unsigned int i=0; i <= anImageDomain.myDomainWidth; i++)
            {
              aLine.point1[0] = anImageDomain.point1[0]+i; aLine.point1[1] = anImageDomain.point1[1]; aLine.point1[2] = anImageDomain.point1[2]+delta;
              aLine.point2[0] = anImageDomain.point4[0]+i; aLine.point2[1] = anImageDomain.point4[1]; aLine.point2[2] = anImageDomain.point4[2]+delta;
              aLineSet.push_back(aLine);
            }
        }else if(anImageDomain.myDirection==xDirection)
        {
          //lines align to the y direction
          for(unsigned int i=0; i <= anImageDomain.myDomainHeight; i++)
            {
              aLine.point1[0] = anImageDomain.point1[0]+delta; aLine.point1[1] = anImageDomain.point1[1]; aLine.point1[2] = anImageDomain.point1[2]+i;
              aLine.point2[0] = anImageDomain.point1[0]+delta; aLine.point2[1] = anImageDomain.point2[1]; aLine.point2[2] = anImageDomain.point1[2]+i;
              aLineSet.push_back(aLine);
            }

          //lines align to the z direction
          for(unsigned int i=0; i <= anImageDomain.myDomainWidth; i++)
            {
              aLine.point1[0] = anImageDomain.point1[0]+delta; aLine.point1[1] = anImageDomain.point1[1]+i; aLine.point1[2] = anImageDomain.point1[2];
              aLine.point2[0] = anImageDomain.point1[0]+delta; aLine.point2[1] = anImageDomain.point1[1]+i; aLine.point2[2] = anImageDomain.point4[2];
              aLineSet.push_back(aLine);
            }
        }else if(anImageDomain.myDirection==yDirection)
        {
          //lines align to the x direction
          for(unsigned int i=0; i <= anImageDomain.myDomainHeight; i++)
            {
              aLine.point1[0] = anImageDomain.point1[0]; aLine.point1[1] = anImageDomain.point1[1]+delta; aLine.point1[2] = anImageDomain.point1[2]+i;
              aLine.point2[0] = anImageDomain.point2[0]; aLine.point2[1] = anImageDomain.point1[1]+delta; aLine.point2[2] = anImageDomain.point1[2]+i;
              aLineSet.push_back(aLine);
            }

          //lines align to the z direction
          for(unsigned int i=0; i <= anImageDomain.myDomainWidth; i++)
            {
              aLine.point1[0] = anImageDomain.point1[0]+i; aLine.point1[1] = anImageDomain.point1[1]+delta; aLine.point1[2] = anImageDomain.point1[2];
              aLine.point2[0] = anImageDomain.point1[0]+i; aLine.point2[1] = anImageDomain.point1[1]+delta; aLine.point2[2] = anImageDomain.point4[2];
              aLineSet.push_back(aLine);
            }
        }
    }else if(anImageDomain.myMode=="Grid")
    {
      if(anImageDomain.myDirection==zDirection)
        {
          //lines align to the x direction
          for(unsigned int i=0; i < anImageDomain.myDomainHeight; i++)
            {
              aLine.point1[0] = anImageDomain.point1[0]; aLine.point1[1] = anImageDomain.point1[1]+i+0.5; aLine.point1[2] = anImageDomain.point1[2]+delta;
              aLine.point2[0] = anImageDomain.point2[0]; aLine.point2[1] = anImageDomain.point2[1]+i+0.5; aLine.point2[2] = anImageDomain.point2[2]+delta;
              aLineSet.push_back(aLine);
            }
          //lines align to the y direction
          for(unsigned int i=0; i < anImageDomain.myDomainWidth; i++)
            {
              aLine.point1[0] = anImageDomain.point1[0]+i+0.5; aLine.point1[1] = anImageDomain.point1[1]; aLine.point1[2] = anImageDomain.point1[2]+delta;
              aLine.point2[0] = anImageDomain.point4[0]+i+0.5; aLine.point2[1] = anImageDomain.point4[1]; aLine.point2[2] = anImageDomain.point4[2]+delta;
              aLineSet.push_back(aLine);
            }
        }else if(anImageDomain.myDirection==xDirection)
        {
          //lines align to the y direction
          for(unsigned int i=0; i < anImageDomain.myDomainHeight; i++)
            {
              aLine.point1[0] = anImageDomain.point1[0]+delta; aLine.point1[1] = anImageDomain.point1[1]; aLine.point1[2] = anImageDomain.point1[2]+i+0.5;
              aLine.point2[0] = anImageDomain.point1[0]+delta; aLine.point2[1] = anImageDomain.point2[1]; aLine.point2[2] = anImageDomain.point1[2]+i+0.5;
              aLineSet.push_back(aLine);
            }

          //lines align to the z direction
          for(unsigned int i=0; i < anImageDomain.myDomainWidth; i++)
            {
              aLine.point1[0] = anImageDomain.point1[0]+delta; aLine.point1[1] = anImageDomain.point1[1]+i+0.5; aLine.point1[2] = anImageDomain.point1[2];
              aLine.point2[0] = anImageDomain.point1[0]+delta; aLine.point2[1] = anImageDomain.point1[1]+i+0.5; aLine.point2[2] = anImageDomain.point4[2];
              aLineSet.push_back(aLine);
            }
        }else if(anImageDomain.myDirection==yDirection)
        {
          //lines align to the x direction
          for(unsigned int i=0; i < anImageDomain.myDomainHeight; i++)
            {
              aLine.point1[0] = anImageDomain.point1[0]; aLine.point1[1] = anImageDomain.point1[1]+delta; aLine.point1[2] = anImageDomain.point1[2]+i+0.5;
              aLine.point2[0] = anImageDomain.point2[0]; aLine.point2[1] = anImageDomain.point1[1]+delta; aLine.point2[2] = anImageDomain.point1[2]+i+0.5;
              aLineSet.push_back(aLine);
            }

          //lines align to the z direction
          for(unsigned int i=0; i < anImageDomain.myDomainWidth; i++)
            {
              aLine.point1[0] = anImageDomain.point1[0]+i+0.5; aLine.point1[1] = anImageDomain.point1[1]+delta; aLine.point1[2] = anImageDomain.point1[2];
              aLine.point2[0] = anImageDomain.point1[0]+i+0.5; aLine.point2[1] = anImageDomain.point1[1]+delta; aLine.point2[2] = anImageDomain.point4[2];
              aLineSet.push_back(aLine);
            }
        }
    }
  return aLineSet;
}


template < typename Space ,typename KSpace >
inline
void
DGtal::Viewer3D< Space ,KSpace >::updateAn2DDomainOrientation(unsigned int domainIndex,
                                                              double xPosition, double yPosition,
                                                              double zPosition, ImageDirection newDirection)
{
  ASSERT( domainIndex < myImageDomainList.size());
  typename Viewer3D< Space ,KSpace >::Image2DDomainD3D &aDomain = myImageDomainList.at(domainIndex);

  Display3D< Space, KSpace>::updateBoundingBox(aDomain.point1);
  Display3D< Space, KSpace>::updateBoundingBox(aDomain.point2);
  Display3D< Space, KSpace>::updateBoundingBox(aDomain.point3);
  Display3D< Space, KSpace>::updateBoundingBox(aDomain.point4);
  aDomain.updateDomainOrientation(newDirection, xPosition, yPosition, zPosition);

  std::vector<typename DGtal::Viewer3D< Space ,KSpace >::LineD3D> vectNewLines= compute2DDomainLineRepresentation(aDomain);
  std::vector<typename DGtal::Viewer3D< Space ,KSpace >::LineD3D> &vectLines = Viewer3D<Space, KSpace>::myLineSetList.at(aDomain.myLineSetIndex);
  vectLines.clear();
  for(unsigned int i=0; i<vectNewLines.size(); i++)
    {
      vectLines.push_back(vectNewLines.at(i));
    }

}


template < typename Space ,typename KSpace >
inline
void
DGtal::Viewer3D< Space ,KSpace >::translateAn2DDomain(unsigned int domainIndex, double xTranslation, double yTranslation, double zTranslation)
{
  typename Viewer3D< Space ,KSpace >::Image2DDomainD3D &anDomain = myImageDomainList.at(domainIndex);
  anDomain.translateDomain(xTranslation, yTranslation, zTranslation);

  Display3D< Space, KSpace>::updateBoundingBox(anDomain.point1);
  Display3D< Space, KSpace>::updateBoundingBox(anDomain.point2);
  Display3D< Space, KSpace>::updateBoundingBox(anDomain.point3);
  Display3D< Space, KSpace>::updateBoundingBox(anDomain.point4);

  std::vector<typename DGtal::Display3D<Space, KSpace>::LineD3D> &vectLines = Viewer3D<Space,KSpace>::myLineSetList.at(anDomain.myLineSetIndex);
  for(unsigned int i=0; i<vectLines.size(); i++){
    typename DGtal::Display3D<Space,KSpace>::LineD3D &aLine = vectLines.at(i);
    aLine.point1[0]=aLine.point1[0]+xTranslation; aLine.point1[1]=aLine.point1[1]+yTranslation; aLine.point1[2]=aLine.point1[2]+zTranslation;
    aLine.point2[0]=aLine.point2[0]+xTranslation; aLine.point2[1]=aLine.point2[1]+yTranslation; aLine.point2[2]=aLine.point2[2]+zTranslation;
  }
}

template < typename Space ,typename KSpace >
inline
std::string
DGtal::Viewer3D< Space ,KSpace >::TextureImage::className() const
{
  return "TextureImage";
}

template <typename Space, typename KSpace>
inline
DGtal::Viewer3D<Space,KSpace> &
DGtal::Viewer3D<Space, KSpace>::operator<<(const DGtal::Color & aColor)
{
  myDefaultColor=aColor;
  return *this;
}

template <typename Space, typename KSpace>
inline
DGtal::Viewer3D<Space, KSpace> &
DGtal::Viewer3D<Space, KSpace>::operator<<(const typename Viewer3D<Space, KSpace>::StreamKey & key)
{
  switch (key)
    {
    case Viewer3D<Space, KSpace>::updateDisplay:
      Viewer3D<Space, KSpace>::updateList();
      break;

    case Viewer3D<Space, KSpace>::addNewList:
      Viewer3D<Space, KSpace>::createNewCubeList();
      break;

    case Viewer3D<Space, KSpace>::shiftSurfelVisu:
      Viewer3D<Space, KSpace>::myCurrentfShiftVisuPrisms+=0.3;
      break;
    }
  return *this;
}

template <typename Space, typename KSpace>
template <typename TDrawableWithViewer3D>
inline
DGtal::Viewer3D<Space, KSpace> &
DGtal::Viewer3D<Space, KSpace>::operator<<( const TDrawableWithViewer3D & object )
{
  BOOST_CONCEPT_ASSERT((concepts::CDrawableWithViewer3D< TDrawableWithViewer3D, Space, KSpace >));

  DGtal::Viewer3DFactory<Space,KSpace>::draw(*this, object);
  return *this;
}


///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions and external operators //

template <typename Space, typename KSpace>
inline
std::ostream&
DGtal::operator<< ( std::ostream & out,
                    const Viewer3D<Space, KSpace> & object )
{
  object.selfDisplay ( out );
  return out;
}

// //
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////

// heritage of parents templates methods //


// end of heritage //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////

// surcharge of parents methods //


// end of surcharge //
///////////////////////////////////////////////////////////////////////////////

template< typename Space, typename KSpace>
inline
void
DGtal::Viewer3D<Space, KSpace>::drawWithNames()
{
  // JOL: 2014/10/15. This method is called only when the user tries
  // to select some graphic object through QGLViewer. By default,
  // selection is left clic + shift key.
  // JOL: 2014/10/15. This is my addition for interacting with
  // quads. Seems to work well.

  glCallList ( myQuadsMapId );

  glCallList ( myCubesMapId );


  for ( unsigned int i=0; i<Viewer3D<Space, KSpace>::myLineSetList.size(); i++ )
    {
      glCallList ( myLineSetListId+i );
    }

  for ( unsigned int i=0; i<Viewer3D<Space, KSpace>::myBallSetList.size(); i++ )
    {
      glCallList(myBallSetListId+i);
    }

}

template< typename Space, typename KSpace>
inline
void
DGtal::Viewer3D<Space, KSpace>::draw()
{
  
  
  glPushMatrix();
  glMultMatrixd ( manipulatedFrame()->matrix() );
  glPushMatrix();
  glScalef(myGLScaleFactorX, myGLScaleFactorY, myGLScaleFactorZ);

  glLightfv(GL_LIGHT0, GL_SPECULAR, myLightSpecularCoeffs);
  glLightfv(GL_LIGHT0, GL_DIFFUSE, myLightDiffuseCoeffs);
  glLightfv(GL_LIGHT0, GL_AMBIENT, myLightAmbientCoeffs);
  if( myLightPositionFixToCamera ){
        updateLightCoordsFromCamera();  
  }else{
    updateRelativeCameraFromLightPosition();
  }
  glLightfv(GL_LIGHT0, GL_POSITION, myLightPosition);  
  
  unsigned int i = 0;
  typename vector< typename Viewer3D<Space, KSpace>::ClippingPlaneD3D >::const_iterator it = Viewer3D<Space, KSpace>::myClippingPlaneList.begin();
  
  // OpenGL can't draw more than GL_MAX_CLIP_PLANES clipping plane
  while ( i < GL_MAX_CLIP_PLANES && it !=Viewer3D<Space, KSpace>::myClippingPlaneList.end() )
    {
      double eq [4];
      eq[0]=it->a;
      eq[1]=it->b;
      eq[2]=it->c;
      eq[3]=it->d;
      glEnable ( GL_CLIP_PLANE0+i );
      glClipPlane ( GL_CLIP_PLANE0+i, eq );
      i++;
      it++;
    }
  if (i == GL_MAX_CLIP_PLANES)
    {
      std::cerr <<"Warning maximal clipping plane added" << std::endl;
    }

  Vec centerS = sceneCenter();
  Vec posCam = camera()->position();
  double distCam =sqrt ( ( posCam.x-centerS.x ) * ( posCam.x-centerS.x ) +
                         ( posCam.y-centerS.y ) * ( posCam.y-centerS.y ) +
                         ( posCam.z-centerS.z ) * ( posCam.z-centerS.z ) );
  for(unsigned int j=0; j< myVectTextureImage.size(); j++)
    {
      GLTextureImage &textureImg = myVectTextureImage.at(j);
      glPushName ( textureImg.myTextureName );
      glEnable(GL_TEXTURE_2D);
      glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
      glBindTexture(GL_TEXTURE_2D, textureImg.myTextureName);
      glBegin(GL_QUADS);
      glColor4ub ( 255.0, 255.0, 255.0, 255.0 );
      glNormal3d(textureImg.vectNormal[0], textureImg.vectNormal[1], textureImg.vectNormal[2]);

      glTexCoord2f(0, 0);
      glVertex3f(textureImg.point1[0], textureImg.point1[1], textureImg.point1[2]);
      glTexCoord2f(textureImg.myTextureFitX, 0.0);
      glVertex3f(textureImg.point2[0], textureImg.point2[1], textureImg.point2[2]);
      glTexCoord2f(textureImg.myTextureFitX, textureImg.myTextureFitY);
      glVertex3f(textureImg.point3[0], textureImg.point3[1], textureImg.point3[2]);
      glTexCoord2f(0.0, textureImg.myTextureFitY);
      glVertex3f(textureImg.point4[0], textureImg.point4[1], textureImg.point4[2]);
      glEnd();
      glDisable(GL_TEXTURE_2D);

    }


  for ( unsigned int j=0; j< Viewer3D<Space, KSpace>::myLineSetList.size(); j++ )
    {
      if ( Viewer3D<Space, KSpace>::myLineSetList.at ( j ).size() !=0 )
        {
          glLineWidth ( max(myGLLineMinWidth,
                            Viewer3D<Space, KSpace>::myLineSetList.at ( j ).at ( 0 ).width )) ;
        }
      glCallList(myLineSetListId+j);
    }

  glCallList(myPrismListId);
  
  glCallList( myCubesMapId );
      

  for ( unsigned int j=0; j< Viewer3D<Space, KSpace>::myBallSetList.size(); j++ )
    {
      if(myUseGLPointsForBalls)
        {
          if ( Viewer3D<Space, KSpace>::myBallSetList.at ( j ).size() !=0 )
            {
              glPointSize ( max(myGLPointMinWidth,
                                ( Viewer3D<Space, KSpace>::myBallSetList.at ( j ).at ( 0 ).radius ) ));
            }
        }
      else
        glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, GL_FALSE);
      
      glCallList(myBallSetListId+j);
      glUpdateLightRenderingMode();
    }
  
  glDisable(GL_CULL_FACE);
  glCallList(myQuadsMapId);
  if(myViewWire)
    {
      glLineWidth ( max(myGLLineMinWidth,Viewer3D<Space, KSpace>::myMeshDefaultLineWidth /distCam ));
      glCallList(myQuadsMapWiredId);
    }

  glDisable(GL_CULL_FACE);
  glCallList(myTriangleSetListId);
  if(myViewWire)
    {
      glLineWidth ( max(myGLLineMinWidth,
                        Viewer3D<Space, KSpace>::myMeshDefaultLineWidth /distCam ));
      glCallList(myTriangleSetListWiredId);
    }

  glDisable(GL_CULL_FACE);
  glCallList(myPolygonSetListId);
  if(myViewWire)
    {
      glLineWidth (max(myGLLineMinWidth,
                       Viewer3D<Space, KSpace>::myMeshDefaultLineWidth /distCam ));
      glCallList(myPolygonSetListWiredId);
    }

  if(myIsMovingLight){
    drawLight(GL_LIGHT0);
  }
  
   glPopMatrix();
   glPopMatrix();
}


template< typename Space, typename KSpace>
void
DGtal::Viewer3D<Space, KSpace>::selfDisplay ( std::ostream & out ) const
{
  out << "[Viewer3D]";
}


template< typename Space, typename KSpace>
bool
DGtal::Viewer3D<Space, KSpace>::isValid() const
{
  return true;
}

template< typename Space, typename KSpace>
void
DGtal::Viewer3D<Space, KSpace>::init()
{
  myAutoSaveState = false;
  myIsMovingLight = false;
  myLigthRotationStep = 0.01;
  myRefMouseXPos = 0;
  myRefMouseYPos = 0;
  
  myLightPositionRefCamera[0] = myLightPositionRefCameraDefault[0];
  myLightPositionRefCamera[1] = myLightPositionRefCameraDefault[1];
  myLightPositionRefCamera[2] = myLightPositionRefCameraDefault[2];
  updateLightCoordsFromCamera();

  glClearColor (0.0, 0.0, 0.0, 0.0);
  glShadeModel (GL_SMOOTH);  

  glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, myMaterialShininessCoeff);
  glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, myMaterialSpecularCoeffs);

  
  glLightfv(GL_LIGHT0, GL_SPECULAR, myLightSpecularCoeffs);
  glLightfv(GL_LIGHT0, GL_DIFFUSE, myLightDiffuseCoeffs);
  glLightfv(GL_LIGHT0, GL_AMBIENT, myLightAmbientCoeffs);
  
  glLightfv(GL_LIGHT0, GL_POSITION, myLightPosition);
  
  glEnable(GL_LIGHTING);
  glEnable(GL_LIGHT0);
  glEnable(GL_DEPTH_TEST);
  
  Viewer3D<Space, KSpace>::myMeshDefaultLineWidth=10.0;
  myNbListe=0;
  myViewWire=false;
  setBackgroundColor ( QColor ( 217, 228, 255 ) );
  setForegroundColor ( QColor ( 217, 22, 25 ) );
  
  Viewer3D<Space, KSpace>::createNewCubeList ( );
  vector<typename Viewer3D<Space, KSpace>::LineD3D> listeLine;
  Viewer3D<Space, KSpace>::myLineSetList.push_back ( listeLine );
  vector<typename Viewer3D<Space, KSpace>::BallD3D> listeBall;
  Viewer3D<Space, KSpace>::myBallSetList.push_back ( listeBall );
  Viewer3D<Space, KSpace>::myCurrentFillColor = Color ( 220, 220, 220 );
  Viewer3D<Space, KSpace>::myCurrentLineColor = Color ( 22, 22, 222, 50 );
  myDefaultBackgroundColor = Color ( backgroundColor().red(), backgroundColor().green(),
                                     backgroundColor().blue() );
  myIsBackgroundDefault=true;
  Viewer3D<Space, KSpace>::myBoundingPtLow[0]=-10.0;//numeric_limits<double>::max( );
  Viewer3D<Space, KSpace>::myBoundingPtLow[1]=-10.0;//numeric_limits<double>::max( );
  Viewer3D<Space, KSpace>::myBoundingPtLow[2]=-10.0;//numeric_limits<double>::max( );

  Viewer3D<Space, KSpace>::myBoundingPtUp[0]=-10.0;//numeric_limits<double>::min( );
  Viewer3D<Space, KSpace>::myBoundingPtUp[1]=-10.0;//numeric_limits<double>::min( );
  Viewer3D<Space, KSpace>:: myBoundingPtUp[2]=-10.0;//numeric_limits<double>::min( );
  Viewer3D<Space, KSpace>::createNewCubeList ( );
  typename std::vector< typename Viewer3D<Space, KSpace>::CubeD3D> aKSCubeList;

  Viewer3D<Space, KSpace>::myCurrentfShiftVisuPrisms=0.0;
  Viewer3D<Space, KSpace>::myDefaultColor= Color ( 255, 255, 255 );
  camera()->showEntireScene();
  setKeyDescription ( Qt::Key_E, "Export the current display into OFF file (just Cube, surfel and SurfelPrism for now)." );
  setKeyDescription ( Qt::Key_W, "Switch display with and without wired view of triangle and quad faces." );
  setKeyDescription ( Qt::Key_T, "Sort elements for display improvements." );
  setKeyDescription ( Qt::Key_L, "Load last visualisation settings (from a .qglviewer.xml file generated by using SHIFT+L)");
  setKeyDescription ( Qt::ShiftModifier+Qt::Key_L, "Save visualisation settings." );
  setKeyDescription ( Qt::Key_B, "Switch background color with White/Black colors." );
  setKeyDescription ( Qt::Key_C, "Show camera informations." );
  setKeyDescription ( Qt::Key_R, "Reset default scale for 3 axes to 1.0f." );
  setKeyDescription ( Qt::Key_D, "Enable/Disable the two side face rendering." );
  setKeyDescription ( Qt::Key_O, "Switch the ball display mode (quad ball display (default) or OpenGL point)." );
  setKeyDescription ( Qt::Key_R, "Reset default scale for 3 axes to 1.0f." );
  setKeyDescription ( Qt::Key_M, "Switch the rendering mode bewteen Default, Metallic and Plastic mode." );
  setKeyDescription ( Qt::Key_P, "Switch the light source position mode between the camera mode (default: the light source position is fixed according to the camera position) and scene mode (the light source position is fixed according the scene coordinate system)." );
#if !defined (QGLVIEWER_VERSION) || QGLVIEWER_VERSION < 0x020500
  setMouseBindingDescription((Qt::ControlModifier|Qt::ShiftModifier) + Qt::LeftButton, "move light source position defined in the main coordinate system (an x-axis (resp. y-axis) mouse move changes the azimuth (resp. inclination) angle of the light source). Note that light source is always looking at the center point (0,0,0).");
#else
  setMouseBindingDescription(Qt::ControlModifier|Qt::ShiftModifier, Qt::LeftButton, "move light source position defined in the main coordinate system (an x-axis (resp. y-axis) mouse move changes the azimuth (resp. inclination) angle of the light source). Note that light source is always looking at the center point (0,0,0).");
#endif


  glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, GL_TRUE);

#if !defined (QGLVIEWER_VERSION) || QGLVIEWER_VERSION < 0x020500
  setMouseBindingDescription ( Qt::ShiftModifier+Qt::RightButton, "Delete the mouse selected list." );
#else
  setMouseBindingDescription ( Qt::ShiftModifier, Qt::RightButton, "Delete the mouse selected list." );
#endif

  setManipulatedFrame ( new ManipulatedFrame() );
}


template< typename Space, typename KSpace>
void
DGtal::Viewer3D<Space, KSpace>::sortSurfelFromCamera()
{
  CompFarthestVoxelFromCamera comp;
  comp.posCam= camera()->position();

  for (auto &mapElem: Viewer3D<Space, KSpace>::myCubesMap)
    
    {
      DGtal::trace.info() << "sort quad size" << mapElem.second.size() << std::endl;
      sort ( mapElem.second.begin(), mapElem.second.end(), comp );
    }
  CompFarthestSurfelFromCamera compSurf;
  DGtal::trace.info() << "sort surfel size" << Viewer3D<Space, KSpace>::myPrismList.size() << std::endl;
  sort ( Viewer3D<Space, KSpace>::myPrismList.begin(), Viewer3D<Space, KSpace>::myPrismList.end(), compSurf );
}




template< typename Space, typename KSpace>
void
DGtal::Viewer3D<Space, KSpace>::sortTriangleFromCamera()
{
  CompFarthestTriangleFromCamera comp;
  comp.posCam= camera()->position();
  for (auto &listElem: Viewer3D<Space, KSpace>::myTriangleSetList)
    {
      sort ( listElem.begin(), listElem.end(), comp );
    }
}



template< typename Space, typename KSpace>
void
DGtal::Viewer3D<Space, KSpace>::sortQuadFromCamera()
{
  CompFarthestSurfelFromCamera comp;
  comp.posCam= camera()->position();

  for (auto &listElem: Viewer3D<Space, KSpace>::myQuadsMap)
    {
      DGtal::trace.info() << "sort quad size" << listElem.second.size() << std::endl;
      sort ( listElem.second.begin(), listElem.second.end(), comp );
    }
}


template< typename Space, typename KSpace>
void
DGtal::Viewer3D<Space, KSpace>::sortPolygonFromCamera()
{
  CompFarthestPolygonFromCamera comp;
  comp.posCam= camera()->position();

  for (auto &listElem: Viewer3D<Space, KSpace>::myPolygonSetList)
    {
      DGtal::trace.info() << "sort polygon size" << listElem.size() << std::endl;
      sort ( listElem.begin(), listElem.end(), comp );
    }

}




template< typename Space, typename KSpace>
void
DGtal::Viewer3D<Space, KSpace>::postSelection ( const QPoint& point )
{
  camera()->convertClickToLine ( point, myOrig, myDir );
  bool found;
  this->myPosSelector= point;
  mySelectedPoint = camera()->pointUnderPixel ( point, found );
  if ( found )
    {
      DGtal::trace.info() << "Element of liste= " << selectedName() << "selected" << endl;
      // JOL: 2014/10/15
      mySelectedElementId = selectedName();
      void* aData = 0;
      SelectCallbackFct fct = getSelectCallback3D( selectedName(), aData );
      if ( fct ) fct( this, selectedName(), aData );
      // I leave the remaining code.      
      updateList(false);
    }else if (mySelectedElementId != -1)
    {
      mySelectedElementId = -1;
      updateList(false);
    }
}



template< typename Space, typename KSpace>
void
DGtal::Viewer3D<Space, KSpace>::updateList ( bool needToUpdateBoundingBox )
{

  // glDeleteLists
  glDeleteLists(myCubesMapId, 1);
  glDeleteLists(myLineSetListId, myNbLineSetList);
  glDeleteLists(myBallSetListId, myNbBallSetList);
  glDeleteLists(myTriangleSetListId, 1);
  glDeleteLists(myTriangleSetListWiredId, 1);
  glDeleteLists(myPrismListId, 1);
  glDeleteLists(myPolygonSetListId, 1);
  glDeleteLists(myPolygonSetListWiredId, 1);
  glDeleteLists(myQuadsMapId, 1);
  glDeleteLists(myQuadsMapWiredId, 1);

  // Storing ID for each list
  myCubesMapId = glGenLists(1);
  myLineSetListId = glGenLists(Viewer3D<Space, KSpace>::myLineSetList.size());
  myNbLineSetList =  Viewer3D<Space, KSpace>::myLineSetList.size();
  myBallSetListId = glGenLists(Viewer3D<Space, KSpace>::myBallSetList.size());
  myNbBallSetList = Viewer3D<Space, KSpace>::myBallSetList.size();
  myTriangleSetListId = glGenLists(1);
  myTriangleSetListWiredId = glGenLists(1);
  myCubeSetListWiredId = glGenLists(1);
  myPolygonSetListId = glGenLists(1);
  myPolygonSetListWiredId = glGenLists(1);
  myQuadsMapId = glGenLists(1);
  myQuadsMapWiredId = glGenLists(1);
  myPrismListId = glGenLists(1);


  myNbListe=0;

  glEnable ( GL_BLEND );
  glEnable ( GL_MULTISAMPLE_ARB );
  glEnable ( GL_SAMPLE_ALPHA_TO_COVERAGE_ARB );
  glBlendFunc ( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );


  
  glCreateListCubesMaps(Viewer3D<Space, KSpace>::myCubesMap, myCubesMapId);
  

  glCreateListQuadD3D(Viewer3D<Space, KSpace>::myPrismList, myPrismListId);
  myNbListe++;

  for ( unsigned int j=0; j<Viewer3D<Space, KSpace>::myLineSetList.size(); j++ )
    {
      glCreateListLines(Viewer3D<Space, KSpace>::myLineSetList.at(j),  myLineSetListId+j);
      myNbListe++;
    }

  for ( unsigned int j=0; j<Viewer3D<Space, KSpace>::myBallSetList.size(); j++ )
    {
      glCreateListBalls(Viewer3D<Space, KSpace>::myBallSetList.at (j), myBallSetListId+j);
      myNbListe++;
    }


  // First list: quad faces.
  glCreateListQuadMaps(Viewer3D<Space, KSpace>::myQuadsMap, myQuadsMapId);
  myNbListe++;

  // Second list: Wired version of quad face.
  glCreateListQuadMapsWired(Viewer3D<Space, KSpace>::myQuadsMap,myQuadsMapWiredId);
  myNbListe++;

  // Third list: Triangle faces.
  glCreateListTriangles( Viewer3D<Space, KSpace>::myTriangleSetList, myTriangleSetListId);
  myNbListe++;

  // Fourth list: Wired version of triangle face.
  glCreateListTrianglesWired(Viewer3D<Space, KSpace>::myTriangleSetList, myTriangleSetListWiredId);
  myNbListe++;

  // Fifth list: Polygonal faces.
  glCreateListPolygons(Viewer3D<Space, KSpace>::myPolygonSetList, myPolygonSetListId);
  myNbListe++;

  // Sixth list: Wired version of polygonal face.
  glCreateListPolygonsWired(Viewer3D<Space, KSpace>::myPolygonSetList, myPolygonSetListWiredId);
  myNbListe++;


  // Seventh list: Textured images.
  glUpdateTextureImages(myGSImageList);


  if ( needToUpdateBoundingBox )
    {
      setSceneBoundingBox ( qglviewer::Vec ( Viewer3D<Space, KSpace>::myBoundingPtLow[0],
                                             Viewer3D<Space, KSpace>::myBoundingPtLow[1],
                                             Viewer3D<Space, KSpace>::myBoundingPtLow[2] ),
                            qglviewer::Vec ( Viewer3D<Space, KSpace>::myBoundingPtUp[0],
                                             Viewer3D<Space, KSpace>::myBoundingPtUp[1],
                                             Viewer3D<Space, KSpace>::myBoundingPtUp[2] ) );
      showEntireScene();
    }
  glPopMatrix();
}



template< typename Space, typename KSpace>
void
DGtal::Viewer3D<Space, KSpace>::glDrawGLBall (const typename Viewer3D<Space, KSpace>::BallD3D &aBall )
{
  double thetaResolution = aBall.resolution;
  double thetaStep= (2.0*M_PI)/thetaResolution;
  double phiResolution = aBall.resolution;
  double phiStep= M_PI/phiResolution;

  double radius = aBall.radius;
  double xCenter = aBall.center[0];
  double yCenter = aBall.center[1];
  double zCenter = aBall.center[2];
  glBegin(GL_QUAD_STRIP);
  for(unsigned int j =0; j < phiResolution; j++)
    {
      double phi0 = M_PI/2.0-j*phiStep;
      double phi1 = M_PI/2.0-(j+1)*phiStep;
      for(unsigned int i =0; i <= thetaResolution; i++)
        {
          double theta0 =  i * thetaStep;
          glColor4ub ( aBall.color.red(), aBall.color.green(), aBall.color.blue(), aBall.color.alpha() );
          glNormal3f(cos(phi0)*cos(theta0), cos(phi0)*sin(theta0), sin(phi0));
          glVertex3f(xCenter+cos(phi0)*cos(theta0)*radius,yCenter+ cos(phi0)*sin(theta0)*radius, zCenter+ sin(phi0)*radius);
          glNormal3f(cos(phi1)*cos(theta0), cos(phi1)*sin(theta0), sin(phi1));
          glVertex3f(xCenter+cos(phi1)*cos(theta0)*radius,yCenter+ cos(phi1)*sin(theta0)*radius, zCenter+ sin(phi1)*radius);
        }
    }
  glEnd();
  
}

template< typename Space, typename KSpace>
void
DGtal::Viewer3D<Space, KSpace>::mousePressEvent ( QMouseEvent *e )
{
  if(e->modifiers() == (Qt::ControlModifier|Qt::ShiftModifier))
    {
      myIsMovingLight=true;
      myRefMouseXPos = e->x();
      myRefMouseYPos = e->y();
      if( myLightPositionFixToCamera )
        {
           updateLightCoordsFromCamera();
        }
      myLightR = sqrt( myLightPosition[0]* myLightPosition[0]+
                       myLightPosition[1]* myLightPosition[1]+
                       myLightPosition[2]* myLightPosition[2]);
      myLightTheta = asin( myLightPosition[2]/myLightR);
      myLightPhi = atan2( myLightPosition[1], myLightPosition[0]);
    }
  else
    {
      QGLViewer::mousePressEvent(e);
    }
}

template< typename Space, typename KSpace>
void
DGtal::Viewer3D<Space, KSpace>::mouseReleaseEvent ( QMouseEvent *e )
{
  if(e->modifiers() == (Qt::ControlModifier|Qt::ShiftModifier) || myIsMovingLight){
    myIsMovingLight=false;
    updateGL();
  }else{
    QGLViewer::mouseReleaseEvent(e);
  }
}

template< typename Space, typename KSpace>
void
DGtal::Viewer3D<Space, KSpace>::mouseMoveEvent ( QMouseEvent *e )
{
  if(e->modifiers() == (Qt::ControlModifier|Qt::ShiftModifier)){
    int varX = e->x() - myRefMouseXPos; 
    int varY = e->y() - myRefMouseYPos; 
    myLightPhi += varX*myLigthRotationStep;
    myLightTheta += varY*myLigthRotationStep/2.0;
    myLightPosition[0] = myLightR*cos(myLightTheta)*cos(myLightPhi);
    myLightPosition[1] = myLightR*cos(myLightTheta)*sin(myLightPhi);
    myLightPosition[2] = myLightR*sin(myLightTheta);
    if(myLightPositionFixToCamera){
      updateRelativeCameraFromLightPosition();
    }
    glLightfv(GL_LIGHT0, GL_POSITION, myLightPosition);
    myRefMouseXPos = e->x();
    myRefMouseYPos = e->y();
    updateGL();
  }else{
    QGLViewer::mouseMoveEvent(e);
  }
}




template< typename Space, typename KSpace>
void
DGtal::Viewer3D<Space, KSpace>::keyPressEvent ( QKeyEvent *e )
{
  bool handled = false;

  if( e->key() == Qt::Key_D)
    {
      myIsDoubleFaceRendering = !myIsDoubleFaceRendering;
      glUpdateLightRenderingMode();
      updateGL();

    }
  if( e->key() == Qt::Key_E)
    {
      trace.info() << "Exporting mesh..." ;
      operator>> <Space, KSpace>(*this, "exportedMesh.off");
      trace.info() << "[done]"<< endl ;
    }
  if( e->key() == Qt::Key_M)
    {
      switch (myRenderingMode)
        {
        case RenderingMode::RenderingDefault : 
          myRenderingMode = RenderingMode::RenderingMetallic;
          break;
        case RenderingMode::RenderingMetallic : 
          myRenderingMode = RenderingMode::RenderingPlastic;
          break;
        case RenderingMode::RenderingPlastic :
          myRenderingMode = RenderingMode::RenderingLambertian;
          break;
        case RenderingMode::RenderingLambertian : 
          myRenderingMode = RenderingMode::RenderingDefault;
          break;
        } 
      updateRenderingCoefficients(myRenderingMode);
    }

  

  if ( ( e->key() ==Qt::Key_W ) )
    {
      myViewWire=!myViewWire;
      updateList(false);
      updateGL();
    }

  if ( ( e->key() ==Qt::Key_P ) )
    {
      myLightPositionFixToCamera =! myLightPositionFixToCamera;
      updateLightCoordsFromCamera();
      if(myLightPositionFixToCamera)
        {
          displayMessage(QString("Light source position fixed to camera."), 3000);
          updateRelativeCameraFromLightPosition();
        }
      else
        {
          displayMessage(QString("Light source position fixed to main scene."), 3000);
          //updateLightCoordsFromCamera();
        }
      updateGL();
    }
  
  if ( ( e->key() ==Qt::Key_O ) )
    {
      myUseGLPointsForBalls = !myUseGLPointsForBalls;
      updateList(false);
      updateGL();
    }

  if ( ( e->key() ==Qt::Key_R ) )
    {
      myGLScaleFactorX=1.0f;
      myGLScaleFactorY=1.0f;
      myGLScaleFactorZ=1.0f;
      updateGL();
    }

  if ( ( e->key() ==Qt::Key_T ) )
    {
      handled=true;
      DGtal::trace.info() << "sorting surfel according camera position....";
      sortSurfelFromCamera();
      sortTriangleFromCamera();
      sortQuadFromCamera();
      sortPolygonFromCamera();
      DGtal::trace.info() << " [done]"<< std::endl;
      updateList(false);
      updateGL();
    }
  if ( ( e->key() ==Qt::Key_B ) )
    {
      handled=true;
      myIsBackgroundDefault=!myIsBackgroundDefault;
      if ( !myIsBackgroundDefault )
        {
          setBackgroundColor ( QColor ( 255, 255,255 ) );
        }
      else
        {
          setBackgroundColor ( QColor ( 217, 228, 255 ) );
        }
      updateGL();
    }

 if ( ( e->key() ==Qt::Key_L ) )
    {
      if(e->modifiers()==Qt::ShiftModifier){
        saveStateToFile();
      }else{
        restoreStateFromFile();
        updateGL();
      }
    }
  if ( ( e->key() ==Qt::Key_C ) )
   {
      handled=true;
      GLint Viewport[4];
      GLdouble Projection[16], Modelview[16];

      glGetIntegerv ( GL_VIEWPORT , Viewport );
      glGetDoublev ( GL_MODELVIEW_MATRIX , Modelview );
      glGetDoublev ( GL_PROJECTION_MATRIX, Projection );

      for ( unsigned short m=0; m<4; ++m )
        {
          for ( unsigned short l=0; l<4; ++l )
            {
              double sum = 0.0;
              for ( unsigned short k=0; k<4; ++k )
                sum += Projection[l+4*k]*Modelview[k+4*m];
            }
        }

      DGtal::trace.info() << "Viewport: ";
      for ( unsigned short l=0; l<4; ++l )
        DGtal::trace.info() << Viewport[l] << ", ";
      DGtal::trace.info() << std::endl;

      Vec cp = camera()->position();
      Vec cd = camera()->viewDirection();
      Vec cup = camera()->upVector();

      DGtal::trace.info() << "camera.position: " ;
      for ( unsigned short l=0; l<3; ++l )
        DGtal::trace.info() << cp[l] << ", ";
      DGtal::trace.info() << std::endl;

      DGtal::trace.info() << "camera.direction: ";
      for ( unsigned short l=0; l<3; ++l )
        DGtal::trace.info() << cd[l] << ", ";
      DGtal::trace.info() << std::endl;

      DGtal::trace.info() << "camera.upVector: ";
      for ( unsigned short l=0; l<3; ++l )
        DGtal::trace.info() << cup[l] << ", ";
      DGtal::trace.info() << std::endl;

      DGtal::trace.info() << "zNear: " << camera()->zNear() << " - zFar: " << camera()->zFar() << std::endl;
    }

  if ( !handled )
    QGLViewer::keyPressEvent ( e );
}




template< typename Space, typename KSpace>
QString
DGtal::Viewer3D<Space, KSpace>::helpString() const
{
  QString text ( "<h2> Viewer3D</h2>" );
  text += "Use the mouse to move the camera around the object. ";
  text += "You can respectively revolve around, zoom and translate with the three mouse buttons. ";
  text += "Left and middle buttons pressed together rotate around the camera view direction axis<br><br>";
  text += "Pressing <b>Alt</b> and one of the function keys (<b>F1</b>..<b>F12</b>) defines a camera keyFrame. ";
  text += "Simply press the function key again to restore it-> Several keyFrames define a ";
  text += "camera path. Paths are saved when you quit the application and restored at next start.<br><br>";
  text += "Press <b>F</b> to display the frame rate, <b>A</b> for the world axis, ";
  text += "<b>Alt+Return</b> for full screen mode and <b>Control+S</b> to save a snapshot. ";
  text += "See the <b>Keyboard</b> tab in this window for a complete shortcut list.<br><br>";
  text += "Double clicks automates single click actions: A left button double click aligns the closer axis with the camera (if close enough). ";
  text += "A middle button double click fits the zoom of the camera and the right button re-centers the scene.<br><br>";
  text += "A left button double click while holding right button pressed defines the camera <i>Revolve Around Ball</i>. ";
  text += "See the <b>Mouse</b> tab and the documentation web pages for details.<br><br>";
  text += "Press <b>Escape</b> to exit the viewer.";
  return text;
}




template< typename Space, typename KSpace>
void
DGtal::Viewer3D<Space, KSpace>::glCreateListCubesMaps(const typename DGtal::Display3D<Space, KSpace>::CubesMap &aCubeMap,
                                                      unsigned int idList){
  glNewList ( idList , GL_COMPILE );
  
  for (auto &mapElem: aCubeMap)
    {
      glPushName ( mapElem.first );
      glEnable ( GL_LIGHTING );
      glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, GL_FALSE);
      glBegin ( GL_QUADS );      
      bool useColorSelection = false;
      if(mySelectedElementId == mapElem.first)
        useColorSelection = true;
      
      for (auto   &cube: mapElem.second)
        {
          if(useColorSelection)
            {
              unsigned char m =  (cube.color.red()+ cube.color.green()+ cube.color.blue())/3;
              if(m>128)
                {
                  glColor4ub ( std::max((int)(cube.color.red())-mySelectionColorShift, 0),
                               std::max((int)(cube.color.green())-mySelectionColorShift, 0),
                               std::max((int)(cube.color.blue())-mySelectionColorShift, 0),
                               cube.color.alpha());              
                }
              else{
                glColor4ub ( std::min(cube.color.red()+mySelectionColorShift, 255),
                             std::min(cube.color.green()+mySelectionColorShift, 255),
                             std::min(cube.color.blue()+mySelectionColorShift, 255),
                             cube.color.alpha());              
              } 
            }
          else
            { 
              glColor4ub ( cube.color.red(), cube.color.green(), cube.color.blue(),cube.color.alpha());
            }
          double _width= cube.width;
          //z+
          glNormal3f ( 0.0, 0.0, 1.0 );
          glVertex3f ( cube.center[0]-_width, cube.center[1]+_width, cube.center[2]+_width );
          glVertex3f ( cube.center[0]-_width, cube.center[1]-_width, cube.center[2]+_width );
          glVertex3f ( cube.center[0]+_width, cube.center[1]-_width, cube.center[2]+_width );
          glVertex3f ( cube.center[0]+_width, cube.center[1]+_width, cube.center[2]+_width );
          //z-
          glNormal3f ( 0.0, 0.0, -1.0 );
          glVertex3f ( cube.center[0]-_width, cube.center[1]+_width, cube.center[2]-_width );
          glVertex3f ( cube.center[0]+_width, cube.center[1]+_width, cube.center[2]-_width );
          glVertex3f ( cube.center[0]+_width, cube.center[1]-_width, cube.center[2]-_width );
          glVertex3f ( cube.center[0]-_width, cube.center[1]-_width, cube.center[2]-_width );
          //x+
          glNormal3f ( 1.0, 0.0, 0.0 );
          glVertex3f ( cube.center[0]+_width, cube.center[1]-_width, cube.center[2]+_width );
          glVertex3f ( cube.center[0]+_width, cube.center[1]-_width, cube.center[2]-_width );
          glVertex3f ( cube.center[0]+_width, cube.center[1]+_width, cube.center[2]-_width );
          glVertex3f ( cube.center[0]+_width, cube.center[1]+_width, cube.center[2]+_width );
          //x-
          glNormal3f ( -1.0, 0.0, 0.0 );
          glVertex3f ( cube.center[0]-_width, cube.center[1]-_width, cube.center[2]+_width );
          glVertex3f ( cube.center[0]-_width, cube.center[1]+_width, cube.center[2]+_width );
          glVertex3f ( cube.center[0]-_width, cube.center[1]+_width, cube.center[2]-_width );
          glVertex3f ( cube.center[0]-_width, cube.center[1]-_width, cube.center[2]-_width );
          //y+
          glNormal3f ( 0.0, 1.0, 0.0 );
          glVertex3f ( cube.center[0]-_width, cube.center[1]+_width, cube.center[2]+_width );
          glVertex3f ( cube.center[0]+_width, cube.center[1]+_width, cube.center[2]+_width );
          glVertex3f ( cube.center[0]+_width, cube.center[1]+_width, cube.center[2]-_width );
          glVertex3f ( cube.center[0]-_width, cube.center[1]+_width, cube.center[2]-_width );
          //y-
          glNormal3f ( 0.0, -1.0, 0.0 );
          glVertex3f ( cube.center[0]-_width, cube.center[1]-_width, cube.center[2]+_width );
          glVertex3f ( cube.center[0]-_width, cube.center[1]-_width, cube.center[2]-_width );
          glVertex3f ( cube.center[0]+_width, cube.center[1]-_width, cube.center[2]-_width );
          glVertex3f ( cube.center[0]+_width, cube.center[1]-_width, cube.center[2]+_width );
        }
      glEnd();
      glPopName();
    }
  glEndList();
  glUpdateLightRenderingMode();
  
}



template< typename Space, typename KSpace>
void
DGtal::Viewer3D<Space, KSpace>::glCreateListQuadD3D(const VectorQuad &aVectQuad,
                                                    unsigned int idList){
  glNewList ( idList, GL_COMPILE );
  glPushName ( myNbListe );
  glEnable ( GL_DEPTH_TEST );
  glEnable ( GL_BLEND );
  glEnable ( GL_MULTISAMPLE_ARB );
  glEnable ( GL_SAMPLE_ALPHA_TO_COVERAGE_ARB );
  glBlendFunc ( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );

  glBegin ( GL_QUADS );
  for ( auto const &q: aVectQuad )
    {
      glColor4ub ( q.color.red(), q.color.green(),
                   q.color.blue(), q.color.alpha() );
      glNormal3f ( q.nx, q.ny, q.nz );
      glVertex3f ( q.point1[0], q.point1[1] , q.point1[2] );
      glVertex3f ( q.point2[0], q.point2[1] , q.point2[2] );
      glVertex3f ( q.point3[0], q.point3[1] , q.point3[2] );
      glVertex3f ( q.point4[0], q.point4[1] , q.point4[2] );
    }
  glEnd();
  glEndList();
}



template< typename Space, typename KSpace>
void
DGtal::Viewer3D<Space, KSpace>::glCreateListLines(const VectorLine &aVectLine,
                                                  unsigned int idList){
  glNewList ( idList, GL_COMPILE );
  glDisable ( GL_LIGHTING );
  glPushName ( myNbListe );
  glBegin ( GL_LINES );
  for (auto const &l: aVectLine )
    {
      glColor4ub ( l.color.red(), l.color.green(),
                   l.color.blue(), l.color.alpha() );
      glVertex3f ( l.point1[0], l.point1[1], l.point1[2] );
      glVertex3f ( l.point2[0], l.point2[1], l.point2[2] );
    }
  glEnd();
  glEnable ( GL_LIGHTING );
  glEndList();
}



template< typename Space, typename KSpace>
void
DGtal::Viewer3D<Space, KSpace>::glCreateListBalls(const VectorBall &aVectBall,
                                                  unsigned int idList){
  if(myUseGLPointsForBalls)
    {
      glNewList ( idList, GL_COMPILE );
      glDepthMask ( GL_TRUE );
      glDisable ( GL_TEXTURE_2D );
      glDisable ( GL_POINT_SMOOTH );
      glDisable ( GL_LIGHTING );
      glPushName ( myNbListe );
      glBegin ( GL_POINTS );
      for ( auto const &ball: aVectBall )
        {
          glColor4ub ( ball.color.red(), ball.color.green(),
                       ball.color.blue(), ball.color.alpha() );
          glVertex3f ( ball.center[0], ball.center[1], ball.center[2] );
        }
      glEnd();
      glEnable ( GL_LIGHTING );
      glEndList();
    }
  else
    {
      glNewList ( idList, GL_COMPILE );
      glPushName ( myNbListe );
      glDepthMask ( GL_TRUE );
      glDisable ( GL_TEXTURE_2D );
      glDisable ( GL_POINT_SMOOTH );
      for ( auto const & b: aVectBall)
        {
          glDrawGLBall ( b );
        }
      glEnd();
      glEndList();
    }
}




template< typename Space, typename KSpace>
void
DGtal::Viewer3D<Space, KSpace>::glCreateListQuadMaps(const typename DGtal::Display3D<Space, KSpace>::QuadsMap &aQuadMap,
                                                    unsigned int idList){
  glNewList ( idList, GL_COMPILE );
  for (auto & mapElem: aQuadMap)
    {
      glPushName ( mapElem.first );
      glEnable ( GL_LIGHTING );
      glBegin ( GL_QUADS );
      bool useColorSelection = false;
      if(mySelectedElementId == mapElem.first)
        useColorSelection = true;
      
      for (auto &q: mapElem.second)
        {
          if(useColorSelection)
            {
              unsigned char m = (q.color.red()+ q.color.green()+ q.color.blue())/3;
              if(m>128)
                {
                  glColor4ub ( std::max((int)(q.color.red())-mySelectionColorShift, 0),
                               std::max((int)(q.color.green())-mySelectionColorShift, 0),
                               std::max((int)(q.color.blue())-mySelectionColorShift, 0),
                               q.color.alpha());              
                }
              else{
                glColor4ub ( std::min(q.color.red()+mySelectionColorShift, 255),
                             std::min(q.color.green()+mySelectionColorShift, 255),
                             std::min(q.color.blue()+mySelectionColorShift, 255),
                             q.color.alpha());              
              } 
            }
          else
            {
              glColor4ub ( q.color.red(), q.color.green(), q.color.blue(), q.color.alpha());              
              
            }

          glNormal3f ( q.nx, q.ny ,q.nz );
          glVertex3f ( q.point1[0], q.point1[1], q.point1[2] );
          glVertex3f ( q.point2[0], q.point2[1], q.point2[2] );
          glVertex3f ( q.point3[0], q.point3[1], q.point3[2] );
          glVertex3f ( q.point4[0], q.point4[1], q.point4[2] );
        }
      glEnd();
      glPopName();
    }
  glEndList();
}




template< typename Space, typename KSpace>
void
DGtal::Viewer3D<Space, KSpace>::glCreateListQuadMapsWired(const typename DGtal::Display3D<Space, KSpace>::QuadsMap &aQuadMap,
                                                         unsigned int idList){
  glNewList ( idList, GL_COMPILE );
  glPushName ( myNbListe );
  glDisable ( GL_LIGHTING );
  glBegin ( GL_LINES );
  
  for (auto const &mapElem: aQuadMap)
    {
      for(auto const &q: mapElem.second)
        {
          glColor4ub ( 150.0,150.0,150.0,255.0 );
          glColor4ub ( Viewer3D<Space, KSpace>::myCurrentLineColor.red(),
                       Viewer3D<Space, KSpace>::myCurrentLineColor.green(),
                       Viewer3D<Space, KSpace>::myCurrentLineColor.blue(),
                       Viewer3D<Space, KSpace>::myCurrentLineColor.alpha() );
          glVertex3f ( q.point1[0], q.point1[1], q.point1[2] );
          glVertex3f ( q.point2[0], q.point2[1], q.point2[2] );
          glVertex3f ( q.point2[0], q.point2[1], q.point2[2] );
          glColor4ub ( Viewer3D<Space, KSpace>::myCurrentLineColor.red(),
                       Viewer3D<Space, KSpace>::myCurrentLineColor.green(),
                       Viewer3D<Space, KSpace>::myCurrentLineColor.blue(),
                       Viewer3D<Space, KSpace>::myCurrentLineColor.alpha() );
          glVertex3f ( q.point3[0], q.point3[1], q.point3[2] );
          glVertex3f ( q.point3[0], q.point3[1], q.point3[2] );
          glVertex3f ( q.point4[0], q.point4[1], q.point4[2] );
          glColor4ub ( Viewer3D<Space, KSpace>::myCurrentLineColor.red(),
                       Viewer3D<Space, KSpace>::myCurrentLineColor.green(),
                       Viewer3D<Space, KSpace>::myCurrentLineColor.blue(),
                       Viewer3D<Space, KSpace>::myCurrentLineColor.alpha() );
          glVertex3f ( q.point4[0], q.point4[1], q.point4[2] );
          glVertex3f ( q.point1[0], q.point1[1], q.point1[2] );
        }
    }
  glEnd();
  glEndList();

}


template< typename Space, typename KSpace>
void
DGtal::Viewer3D<Space, KSpace>::glCreateListTriangles(const std::vector<VectorTriangle> &aVectTriangle,
                                                     unsigned int idList){
  glNewList ( idList, GL_COMPILE );
  glPushName ( myNbListe );
  glEnable ( GL_LIGHTING );
  glBegin ( GL_TRIANGLES );
  for(auto const &tList: aVectTriangle)
    {
      for (auto const &t: tList)
        {
          glColor4ub (t.color.red(),t.color.green(),t.color.blue(),t.color.alpha() );
          glNormal3f (t.nx,t.ny ,t.nz );
          glVertex3f (t.point1[0],t.point1[1],t.point1[2] );
          glVertex3f (t.point2[0],t.point2[1],t.point2[2] );
          glVertex3f (t.point3[0],t.point3[1],t.point3[2] );
        }
    }
  glEnd();
  glEndList();
}


template< typename Space, typename KSpace>
void
DGtal::Viewer3D<Space, KSpace>::glCreateListTrianglesWired(const std::vector<VectorTriangle> &aVectTriangle,
                                                          unsigned int idList){
  glNewList ( idList, GL_COMPILE );
  glPushName ( myNbListe );
  glDisable ( GL_LIGHTING );
  glBegin ( GL_LINES );
  for (auto const &tList: aVectTriangle)
    {
      for (auto const &t: tList)
        {
          glColor4ub ( Viewer3D<Space, KSpace>::myCurrentLineColor.red(),
                       Viewer3D<Space, KSpace>::myCurrentLineColor.green(),
                       Viewer3D<Space, KSpace>::myCurrentLineColor.blue(),
                       Viewer3D<Space, KSpace>::myCurrentLineColor.alpha() );
          glVertex3f (t.point1[0],t.point1[1],t.point1[2] );
          glVertex3f (t.point2[0],t.point2[1],t.point2[2] );
          glVertex3f (t.point2[0],t.point2[1],t.point2[2] );
          glVertex3f (t.point3[0],t.point3[1],t.point3[2] );
          glVertex3f (t.point3[0],t.point3[1],t.point3[2] );
          glVertex3f (t.point1[0],t.point1[1],t.point1[2] );
        }
    }
  glEnd();
  glEndList();

}



template< typename Space, typename KSpace>
void
DGtal::Viewer3D<Space, KSpace>::glCreateListPolygons(const std::vector<VectorPolygon>  &aVectPolygon,
                                                     unsigned int idList){
  glNewList ( idList, GL_COMPILE );
  glPushName ( myNbListe );
  glEnable ( GL_LIGHTING );
  
  for(auto const &pList: aVectPolygon)
    {
      for (auto const &p: pList)
        {
          glBegin ( GL_POLYGON );
          glColor4ub ( p.color.red(), p.color.green(), p.color.blue(), p.color.alpha() );
          glNormal3f ( p.nx, p.ny ,p.nz );
          for(unsigned int j=0;j < (p.vertices).size();j++)
            {
              glVertex3f ( (p.vertices).at(j)[0], (p.vertices).at(j)[1], (p.vertices).at ( j )[2] );
            }
          glEnd();
        }
    }
  glEndList();
}



template< typename Space, typename KSpace>
void
DGtal::Viewer3D<Space, KSpace>::glCreateListPolygonsWired(const std::vector<VectorPolygon>  &aVectPolygon,
                                                          unsigned int idList){
  glNewList ( idList, GL_COMPILE );
  glPushName ( myNbListe );
  glDisable ( GL_LIGHTING );
  glBegin ( GL_LINES );
  for(auto const &pList: aVectPolygon)
    { 
      for (auto const &p: pList)
        {
          glColor4ub ( Viewer3D<Space, KSpace>::myCurrentLineColor.red(),
                       Viewer3D<Space, KSpace>::myCurrentLineColor.green(),
                       Viewer3D<Space, KSpace>::myCurrentLineColor.blue() ,
                       Viewer3D<Space, KSpace>::myCurrentLineColor.alpha() );
          for(unsigned int j=0;j < (p.vertices).size();j++)
            {
              glVertex3f ( (p.vertices).at(j)[0], (p.vertices).at(j)[1], (p.vertices).at ( j )[2] );
              glVertex3f ( (p.vertices).at((j+1)%(p.vertices).size())[0],
                           (p.vertices).at((j+1)%(p.vertices).size())[1],
                           (p.vertices).at ( (j+1)%(p.vertices).size() )[2] );
            }
        }
    }
  glEnd();
  glEndList();
}



template< typename Space, typename KSpace>
void
DGtal::Viewer3D<Space, KSpace>::glUpdateTextureImages(const  VectorTextureImage &aVectImage){

  for(unsigned int j=0; j<myVectTextureImage.size(); j++){
    glDeleteTextures(1,&(myVectTextureImage[j].myTextureName));
  }
  myVectTextureImage.clear();
  for(unsigned int j=0; j<aVectImage.size(); j++)
    {
      typename Viewer3D<Space, KSpace>::TextureImage  aGSImage = aVectImage.at(j);
      GLTextureImage textureImg(aGSImage);

      glGenTextures(1, &textureImg.myTextureName);
      glBindTexture(GL_TEXTURE_2D, textureImg.myTextureName);

      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
      if(textureImg.myMode==Viewer3D<Space, KSpace>::GrayScaleMode)
        {
          glTexImage2D(GL_TEXTURE_2D, 0, GL_LUMINANCE, textureImg.myBufferWidth, textureImg.myBufferHeight, 0,
                       GL_LUMINANCE, GL_UNSIGNED_BYTE, textureImg.myTextureImageBufferGS);
        }else if(textureImg.myMode==Viewer3D<Space, KSpace>::RGBMode)
        {
          glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, textureImg.myBufferWidth, textureImg.myBufferHeight, 0,
                       GL_RGB, GL_UNSIGNED_BYTE, textureImg.myTextureImageBufferRGB);
        }
      myVectTextureImage.push_back(textureImg);
    }
}

template< typename Space, typename KSpace>
void
DGtal::Viewer3D<Space, KSpace>::glUpdateLightRenderingMode() const
{
  if(myIsDoubleFaceRendering)
    glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, GL_TRUE);
  else
    glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, GL_FALSE);
}



template< typename Space, typename KSpace>
QDomElement
DGtal::Viewer3D<Space, KSpace>::domElement(const QString& name, QDomDocument& document) const
{
  // Creates a custom node for a light  position
  QDomElement deRendering = document.createElement("Rendering");
  deRendering.setAttribute("mode", myRenderingMode);
  QDomElement de = document.createElement("Light");
  de.setAttribute("pos_light_x", myLightPosition[0]);
  de.setAttribute("pos_light_y", myLightPosition[1]);
  de.setAttribute("pos_light_z", myLightPosition[2]);
  // Get default state domElement and append custom node
  QDomElement res = QGLViewer::domElement(name, document);
  res.appendChild(de);
  res.appendChild(deRendering);
  return res;
}



template< typename Space, typename KSpace>
void
DGtal::Viewer3D<Space, KSpace>::initFromDOMElement(const QDomElement& element)
{
  // Restore standard state
  QGLViewer::initFromDOMElement(element);
  QDomElement child=element.firstChild().toElement();
  while (!child.isNull())
  {
    if (child.tagName() == "Rendering")
      {
        myRenderingMode = (RenderingMode)(child.attribute("mode").toInt());
      }
    if (child.tagName() == "Light")
    {
      if (child.hasAttribute("pos_light_x"))
        {
          myLightPosition[0] = child.attribute("pos_light_x").toDouble();
        }
      
      if (child.hasAttribute("pos_light_y"))
        {
          myLightPosition[1] = child.attribute("pos_light_y").toDouble();
        }
      if (child.hasAttribute("pos_light_z"))
        {
          myLightPosition[2] = child.attribute("pos_light_z").toDouble();
        }
    }
    child = child.nextSibling().toElement();
  }
  if(myLightPositionFixToCamera){
    updateRelativeCameraFromLightPosition();
  }
  updateRenderingCoefficients(myRenderingMode, false);
  updateGL();
}


template< typename Space, typename KSpace>
void
DGtal::Viewer3D<Space, KSpace>::closeEvent	(	QCloseEvent * 	e	){
  if (myAutoSaveState)
  {
    saveStateToFile();
  }
  QGLWidget::closeEvent(e);
}

template< typename Space, typename KSpace>
void
DGtal::Viewer3D<Space, KSpace>::setGLDoubleRenderingMode(bool doubleSidedRendering)
{
  myIsDoubleFaceRendering = doubleSidedRendering;
  glUpdateLightRenderingMode();
}


template< typename Space, typename KSpace>
void 
DGtal::Viewer3D<Space, KSpace>::setGLMaterialShininessCoefficient(const GLfloat matShininessCoeff)
{
  myMaterialShininessCoeff = matShininessCoeff;  
  updateGL();
}


template< typename Space, typename KSpace>
void 
DGtal::Viewer3D<Space, KSpace>::setGLLightAmbientCoefficients(const GLfloat lightAmbientCoeffs [4])
{
  myLightAmbientCoeffs[0] =  lightAmbientCoeffs[0];
  myLightAmbientCoeffs[1] =  lightAmbientCoeffs[1];
  myLightAmbientCoeffs[2] =  lightAmbientCoeffs[2];
  myLightAmbientCoeffs[3] =  lightAmbientCoeffs[3]; 
  updateGL();
}


template< typename Space, typename KSpace>
void 
DGtal::Viewer3D<Space, KSpace>::setGLLightDiffuseCoefficients(const GLfloat lightDiffuseCoeffs [4])
{
  myLightDiffuseCoeffs[0] =  lightDiffuseCoeffs[0];
  myLightDiffuseCoeffs[1] =  lightDiffuseCoeffs[1];
  myLightDiffuseCoeffs[2] =  lightDiffuseCoeffs[2];
  myLightDiffuseCoeffs[3] =  lightDiffuseCoeffs[3];
  updateGL();
}


template< typename Space, typename KSpace>
void 
DGtal::Viewer3D<Space, KSpace>::setUseGLPointForBalls(const bool useOpenGLPt)
{
  myUseGLPointsForBalls = useOpenGLPt;
}



template< typename Space, typename KSpace>
void 
DGtal::Viewer3D<Space, KSpace>::updateRenderingCoefficients(const RenderingMode aRenderMode, bool displayState)
{
  stringstream ss; 
  ss << "Rendering mode ";
    
  GLfloat newCoefDiff, newCoefSpec = 1.0f;
  switch (aRenderMode) 
    {
    case RenderingMode::RenderingDefault :
      newCoefDiff = myDefaultRenderDiff;
      newCoefSpec = myDefaultRenderSpec;
      ss << "Default (diffuse with few specular)";
      break;
    case RenderingMode::RenderingMetallic :
      newCoefDiff = myMetallicRenderDiff;
      newCoefSpec = myMetallicRenderSpec;
      ss << "Metallic (diffuse with specular)";
      break;
    case RenderingMode::RenderingPlastic :
      newCoefDiff = myPlasticRenderDiff;
      newCoefSpec = myPlasticRenderSpec;
      ss << "Plastic (few diffuse with large specular)";
      break;
    case RenderingMode::RenderingLambertian :
      newCoefDiff = myLambertRenderDiff;
      newCoefSpec = myLambertRenderSpec;
      ss << "Lambertian (only diffuse)";
      break;
    }
  for (unsigned int i = 0; i<3; i++) 
    myLightDiffuseCoeffs[i] = newCoefDiff;
  myLightDiffuseCoeffs[3] = 1.0;
  for (unsigned int i = 0; i<3; i++) 
    myLightSpecularCoeffs[i] = newCoefSpec;
  myLightSpecularCoeffs[3] = 1.0;
  if (displayState)
    {
      displayMessage(QString(ss.str().c_str()), 3000);
    }
  updateGL();
}



template< typename Space, typename KSpace>
void
DGtal::Viewer3D<Space, KSpace>::setGLLightSpecularCoefficients(const GLfloat lightSpecularCoeffs [4])
{
  myLightSpecularCoeffs[0] =  lightSpecularCoeffs[0];
  myLightSpecularCoeffs[1] =  lightSpecularCoeffs[1];
  myLightSpecularCoeffs[2] =  lightSpecularCoeffs[2];
  myLightSpecularCoeffs[3] =  lightSpecularCoeffs[3];
  updateGL();
}


template<typename Space, typename KSpace>
inline
void 
DGtal::Viewer3D<Space, KSpace>::show(){
  QGLWidget::show();
  updateList(false);
}


template<typename Space, typename KSpace>
inline
void 
DGtal::Viewer3D<Space, KSpace>::paintGL(){
	if (displaysInStereo())
	{
		for (int view=1; view>=0; --view)
		{
			// Clears screen, set model view matrix with shifted matrix for ith buffer
			preDrawStereo(view);
                        postDraw();
                  	// Used defined method. Default is empty
			if (camera()->frame()->isManipulated())
                          fastDraw();
			else
                          draw();
		
		}
	}
	else
	{
		// Clears screen, set model view matrix...
		preDraw();
		postDraw();
                // Used defined method. Default calls draw()
		if (camera()->frame()->isManipulated())
			fastDraw();
		else
                  draw();
		// Add visual hints: axis, camera, grid...
		
	}
	Q_EMIT drawFinished(true);
}


template< typename Space, typename KSpace>
void DGtal::Viewer3D<Space, KSpace>::updateLightCoordsFromCamera() {
  Vec posLCam;
  posLCam[0] = myLightPositionRefCamera[0];
  posLCam[1] = myLightPositionRefCamera[1];
  posLCam[2] = myLightPositionRefCamera[2];  
  Vec posL = camera()->worldCoordinatesOf(posLCam);
  myLightPosition[0] = static_cast<GLfloat>(posL[0]);
  myLightPosition[1] = static_cast<GLfloat>(posL[1]);
  myLightPosition[2] = static_cast<GLfloat>(posL[2]);
  myLightPosition[3] = 1.0f;
}



template< typename Space, typename KSpace>
void DGtal::Viewer3D<Space, KSpace>::updateRelativeCameraFromLightPosition() {
  Vec posL;
  posL[0] = myLightPosition[0];
  posL[1] = myLightPosition[1];
  posL[2] = myLightPosition[2];  
  Vec posLCam = camera()->cameraCoordinatesOf(posL); 
  myLightPositionRefCamera[0] = static_cast<GLfloat>(posLCam[0]);
  myLightPositionRefCamera[1] = static_cast<GLfloat>(posLCam[1]);
  myLightPositionRefCamera[2] = static_cast<GLfloat>(posLCam[2]);
}
