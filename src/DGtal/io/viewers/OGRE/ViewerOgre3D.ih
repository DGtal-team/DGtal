/**
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file ViewerOgre3D.ih
 * @author Anis Benyoub (\c anis.benyoub@insa-lyon.fr )
 * Liris CNRS
 *
 * @date 2012/06/10
 *
 * Implementation of inline methods defined in ViewerOgre3D.h
 *
 * This file is part of the DGtal library.
 */

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
#include "DGtal/io/viewers/OGRE/ViewerOgre3D.h"
#include "DGtal/io/viewers/OGRE/Ogre3DDisplayFactory.h"
#include "DGtal/base/CountedPtr.h"
#include "DGtal/io/viewers/OGRE/OgreStyle3DFactory.h"
#include "DGtal/io/viewers/OGRE/CommonOgre.h"
#include "DGtal/io/viewers/OGRE/Requirements.h"
#include <unistd.h>

#if (OGRE_PLATFORM == OGRE_PLATFORM_APPLE) && __LP64__
#include "DGtal/io/viewers/OGRE/OgreEventCatcher.h"
#include "DGtal/io/viewers/OGRE/MyApplication.h"
#endif

//////////////////////////////////////////////////////////////////////////////


namespace DGtal
{
  template<> ViewerOgre3D* DGtal::Singleton<ViewerOgre3D>::mySingleton = 0;
};

///////////////////////////////////////////////////////////////////////////////
// Implementation of inline methods //



/**
 *  adding dgtal objects to the scene
 */
template <typename TDrawableWithDisplay3D>
inline
DGtal::ViewerOgre3D &
DGtal::ViewerOgre3D::operator<< ( const TDrawableWithDisplay3D & object )
{
  //  BOOST_CONCEPT_ASSERT((CDrawableWithDisplay3D< TDrawableWithDisplay3D >));

  DGtal::CountedPtr<DrawableWithViewerOgre3D> style( DGtal::OgreStyle3DFactory::defaultStyle(object) );
   
   
  // Apply default style
  if ( style.get() )
    {
      DGtal::OgreStyle3DFactory::draw(*this, style.get());
    }
    
    
  // Apply Customized style
  StyleMapping::const_iterator it = myStyles.find( object.className() );
  if ( it != myStyles.end() ) 
    if ( it->second.get() != 0 )
      {
	DGtal::OgreStyle3DFactory::draw(*this, it->second.get());
      }
      
      
      
  // Check for specific mode.
  ModeMapping::const_iterator itm = myModes.find( object.className() );
  if ( itm != myModes.end() )
    {
      
      // Apply default style for specific mode.
      CountedPtr<DrawableWithViewerOgre3D> style_mode ( DGtal::OgreStyle3DFactory::defaultStyle(object, itm->second) );
      
      if ( style_mode.get() )StyleMapping::const_iterator it = myStyles.find( object.className() );
      if ( it != myStyles.end() ) 
 
	{
	  DGtal::OgreStyle3DFactory::draw(*this, style_mode.get());
	}
      
      
      // Apply customized style for specific mode
      std::string specific_style = object.className() + "/" + itm->second;
      it = myStyles.find( specific_style );
      if ( it != myStyles.end() ) 
	if ( it->second.get() != 0 )
	  {
	    DGtal::OgreStyle3DFactory::draw(*this, it->second.get());
	  }
    }
    

  DGtal::Ogre3DDisplayFactory::draw ( *this, object );
  computeSceneCenter ( );
  updateInitialCameraPosition( );
  updatePlane();

  return *this;
}



/**
 *  Returns a dgtal object from selection
 */
template <typename TDrawableWithDisplay3D>
void DGtal::ViewerOgre3D::operator>> ( TDrawableWithDisplay3D & object )
{
  
  mySelectionMode = true;
  myMode->setCaption("Mode: Selection / Select a Point");
  start();
  if( (mySelectedDGtalNode!=NULL) &&
      (( ( DrawableWithOgreWrapper<TDrawableWithDisplay3D> * ) ( mySelectedDGtalNode->getDGtalObject() ) )->getDgtalObject()->className() == object.className()))
    {
      const TDrawableWithDisplay3D * myPoint  = ( ( DrawableWithOgreWrapper<TDrawableWithDisplay3D> * ) ( mySelectedDGtalNode->getDGtalObject() ) )->getDgtalObject();
      object = ( *myPoint );
      mySelectionMode = false;
      myMode->setCaption("Mode: View");
    
    }
  else
    {
      //Must raise an exeption
    }
    
}



/**
 * Using manipulate on a DGtal Object
 *  @param ptrfonction is a pointer on the function you want to useful
 *  @param anObject is the initial Object
 *  @param minValue && @param @maxValue  are the range you want to study the object on
 *  @param step is the evolution step.
 */
template <typename TDrawableWithDisplay3D>
void DGtal::ViewerOgre3D::manipulate ( TDrawableWithDisplay3D & anObject, 
				TDrawableWithDisplay3D & ( *ptrfonction ) ( TDrawableWithDisplay3D, int ), 
				int minValue, int maxValue, int step )
{
  myManupilatingFlag = true;
  myMaxManupulating = maxValue;
  myMinManupulating = minValue;
  myCurrentManupulating = minValue;
  myStep = step;
  updateManipulateDisplay();
  while ( myManupilatingFlag )
    {
      clearScene();
      TDrawableWithDisplay3D & Object = ptrfonction ( anObject,  myCurrentManupulating );
      ( *this ) << ( Object );
      start();
      delete &Object;
    }
  myMode->setCaption("Mode: View");

}

/**
 * @param objectName the name of the object (generally obtained
 * with a 'object.className()').
 *
 * @return the current mode for the given object name or "" if no
 * specific mode has been set.
 */
inline
std::string
DGtal::ViewerOgre3D::getMode ( const std::string & objectName ) const
{
  ModeMapping::const_iterator itm = myModes.find ( objectName );
  return itm == myModes.end() ? "" : itm->second;
}

/**
 *  Destructor.
 */
DGtal::ViewerOgre3D::~ViewerOgre3D()
{  
  delete myInputManager;
  delete myMode;
  destroyScene();
  
  myWindow->removeAllViewports();
  mySceneMgr->destroyAllCameras();
  mySceneMgr->destroyAllManualObjects();
  mySceneMgr->destroyAllEntities();
  mySceneMgr->destroyAllLights();
  getRootSceneNode()->removeAndDestroyAllChildren();

  Ogre::ResourceGroupManager& lRgMgr = Ogre::ResourceGroupManager::getSingleton();

  lRgMgr.destroyResourceGroup("General");

  myRoot->destroySceneManager(mySceneMgr);

  myRoot->shutdown();
  delete myRoot;
  delete myLogManager;
}



/**
 *  Constructor.
 */
DGtal::ViewerOgre3D::ViewerOgre3D( ) : myCurrentObject ( 0 ), mySelectionMode ( false )
{
  mySourceDirectory = sourcePath;
  myBinaryDirectory = binaryPath;
  myLogManager = new  Ogre::LogManager();
  myLogManager->createLog(myBinaryDirectory+"Ogre.log" , true, false, true); 
  myRoot = new Ogre::Root ( myBinaryDirectory+"plugins.cfg", mySourceDirectory+"ogre.cfg", "" );

  //Chargement des ressources et configuration
  initMaterials();

  if ( !initConfigs() )
    {
      return ;
    }

  //Creation de la scene principale
  mySceneMgr = myRoot->createSceneManager ( "DefaultSceneManager", "Fenetre Principale" );

  //DEVICES
  myWindow = myRoot->initialise ( true	, "ViewerOgre3D" );

  //----------------- Fonts loading
  loadFonts();
 

  //CREATION DE LA SCENE
  createScene();


  myMode = new TextZone("Mode: View"); 
  //myMode->setPosition(70,550);


  //Creation de l'input listener
  createFrameListener();


  myRayScnQuery = mySceneMgr->createRayQuery ( Ogre::Ray() );

  mySelectedDGtalNode = NULL;

  myUpperFatherNonRoot = NULL;
  
  myCurrentSelfIlluminationColor= DGtal::Color(100,100,100,255);
  myCurrentAmbientIlluminationColor= DGtal::Color(100,100,100,255);
  myCurrentDiphuseIlluminationColor= DGtal::Color(100,100,100,255);
  myCurrentSpecularIlluminationColor= DGtal::Color(100,100,100,255);
  myTexture= "unselected.jpg";
  

  myBackgroundBlackColor=true;

}





#include <iostream>

/**
 *  Rendering launch method.
 */
void DGtal::ViewerOgre3D::start()
{

  // myRoot->startRendering();
  myInputManager->startRendering();
  
  
  double timeSinceLastFrame = 0;
  double startTime = 0;
    
    
#if  !((OGRE_PLATFORM == OGRE_PLATFORM_APPLE) && __LP64__)
  while(InputListener::getSingletonPtr()->viewerIsRunning()) 
    {
      Ogre::WindowEventUtilities::messagePump();
      startTime = InputListener::getSingletonPtr()->getTimer()->getMillisecondsCPU();
      InputListener::getSingletonPtr()->getKeyBoard()->capture();
      InputListener::getSingletonPtr()->getMouse()->capture();
      InputListener::getSingletonPtr()->updateViewer(timeSinceLastFrame);
      myRoot->renderOneFrame();
      timeSinceLastFrame = InputListener::getSingletonPtr()->getTimer()->getMillisecondsCPU() - startTime;
    }
#else
        	
  NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
  myOgreEventCatcher = [[OgreEventCatcher alloc] init];
  [myOgreEventCatcher startRendering];
  int retVal = MyApplicationMain(0,NULL);
  [pool release];
#endif	
}



/**
 * Initiate ressources
 */
void DGtal::ViewerOgre3D::initMaterials()
{
  //Chargement des matÃ©riaux , des meshs et de tout ce qu'on a comme ressource
  Ogre::ConfigFile cf;
  cf.load ( mySourceDirectory+"ressources.cfg" );
  Ogre::ConfigFile::SectionIterator sectionIter = cf.getSectionIterator();

  Ogre::String sectionName, typeName, dataName;
  Ogre::ConfigFile::SettingsMultiMap * settings;
  Ogre::ConfigFile::SettingsMultiMap::iterator i;

  while ( sectionIter.hasMoreElements() )
    {
      sectionName = sectionIter.peekNextKey();
      settings = sectionIter.getNext();

      for ( i = settings->begin(); i != settings->end(); ++i )
        {
          typeName = i->first;
          dataName = i->second;

          Ogre::ResourceGroupManager::getSingleton().addResourceLocation ( mySourceDirectory+dataName, typeName, sectionName );
        }
    }

  Ogre::ResourceGroupManager::getSingleton().initialiseAllResourceGroups();

  

  //fin chargement materials
}


/**
 *  Config initiate
 */
bool DGtal::ViewerOgre3D::initConfigs()
{
  if ( !myRoot->restoreConfig() )
    {
      if ( !myRoot->showConfigDialog() )
        {
          return false; //erreur de chargement config
        }
    }

  return true;
}

/**
 *  Scene create
 */
void DGtal::ViewerOgre3D::createScene()
{
  Ogre::TextureManager::getSingleton().setDefaultNumMipmaps ( 5 );
  Ogre::ResourceGroupManager::getSingleton().initialiseAllResourceGroups();


  mySceneMgr->setAmbientLight ( Ogre::ColourValue ( 0.6, 0.6, 0.6 ) );
  mySceneMgr->setShadowTechnique(Ogre::SHADOWTYPE_STENCIL_ADDITIVE);

  Ogre::Light * light = mySceneMgr->createLight ( "Light" );
  light->setType ( Ogre::Light::LT_POINT);
  light->setDiffuseColour ( 1.0, 1.0, 1.0 );
  light->setSpecularColour (1.0, 1.0, 1.0 );
  light->setPosition ( Ogre::Vector3(mySceneCenter.x,mySceneCenter.y,getUpperPosition().z+800));
  light->setCastShadows(true);




  //Camera
  myCamera = mySceneMgr->createCamera ( "mYCamera" );
  myCamera->setFarClipDistance ( 3000 );
  myCamera->setNearClipDistance ( 2 );
  myCamera->setPosition ( Ogre::Vector3 ( 0, 10, 500 ) );
  myCamera->lookAt ( Ogre::Vector3 ( 0, 0, 0 ) );

  // Viewport
  myViewPort = myWindow->addViewport ( myCamera );
  myViewPort->setBackgroundColour ( Ogre::ColourValue ( 129.0/255., 192.0/255.,1 ) );

  // Parametrage du point de vue
  myCamera->setAspectRatio ( Ogre::Real ( myViewPort->getActualWidth() ) / Ogre::Real ( myViewPort->getActualHeight() ) );

  
  myRootNode = new DGtalNode ( mySceneMgr );
  Representation * hisRepresentation = new Representation ( mySceneMgr, mySceneMgr->getRootSceneNode()->createChildSceneNode ( "RootNode" ), "RootNode" );
  myRootNode->setRepresentation ( hisRepresentation );
  myRootNode->setFather ( NULL );
  myRootNode->setRoot();
 
  drawAxes();
  drawWrist();
  
  Ogre::Plane plan1(Ogre::Vector3::UNIT_Z, 0);
  Ogre::Plane plan2(-Ogre::Vector3::UNIT_Z, 0);
  Ogre::MeshManager::getSingleton().createPlane("sol1",  Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,
						plan1, 3000, 3000, 10, 10, true, 1, 1, 1,  Ogre::Vector3::UNIT_Y);
  Ogre::MeshManager::getSingleton().createPlane("sol2",  Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,
						plan2, 300, 3000, 10, 10, true, 1, 1, 1,  Ogre::Vector3::UNIT_Y);
  Ogre::Entity *ent1= mySceneMgr->createEntity("EntiteSol", "sol1");
  Ogre::Entity *ent2= mySceneMgr->createEntity("EntiteSol2", "sol2");



  ent1->setCastShadows(false);
  ent2->setCastShadows(false);
  myPlane = mySceneMgr->getRootSceneNode()->createChildSceneNode();
  myPlane->attachObject(ent1);
  myPlane->attachObject(ent2);
  myPlane->setVisible(false);
 

}


/**
 *  Frame listenner creartion
 */
void DGtal::ViewerOgre3D::createFrameListener()
{

  new DGtal::InputListener ( myWindow, this, myCamera, mySceneMgr );
  myInputManager = &(DGtal::InputListener::getSingleton()) ; 
  myRoot->addFrameListener ( myInputManager );
}


/**
 *  Get a son node ( of the root one)
 */
Ogre::SceneNode * DGtal::ViewerOgre3D::getANode()
{
  return myRootNode->getNode()->createChildSceneNode();
}


/**
 *  looks for a point and changes the current selection if found (x, y)
 *  the mouse coordinates and (h,w) the window dimension
 */

void DGtal::ViewerOgre3D::lookForIt ( unsigned int x, unsigned int y, unsigned int h, unsigned int w )
{

  Representation * temp = NULL;
  double DistanceToCamera = -1;


  Ogre::Ray mouseRay = myCamera->getCameraToViewportRay ( ( double ) x / ( double ) w, ( double ) y / ( double ) h );
  myRayScnQuery->setRay ( mouseRay );
  Ogre::RaySceneQueryResult &result = myRayScnQuery->execute();
  Ogre::RaySceneQueryResult::iterator itr;


  for ( itr = result.begin( ); itr != result.end(); itr++ )
    {

      if ( itr->movable )
        {
          Representation * Encloser = findRepresentation ( itr->movable->getName() );
          if ( Encloser != NULL )
            {

              Ogre::Vector3 AVector ( myInputManager->getCameraMan()->getSceneNode()->getPosition() - Encloser->getNode()->_getDerivedPosition() );
              double localDistance = AVector.length();

              if ( DistanceToCamera == -1 )
                {
                  DistanceToCamera = localDistance;
                  temp = Encloser;
                }
              else
                if ( ( DistanceToCamera >= localDistance ) )
                  {
                    DistanceToCamera = localDistance;
                    temp = Encloser;
                  }
            }
        }
    }

  if ( mySelectedDGtalNode != NULL )
    {
      mySelectedDGtalNode->unselect();
    }

  if ( myUpperFatherNonRoot != NULL )
    {
      myUpperFatherNonRoot ->unselect();
    }


  if ( temp != NULL )
    {
      mySelectedDGtalNode = temp->getAttachedParent();
      myUpperFatherNonRoot = mySelectedDGtalNode->getUpperNonRootNode();

	

      if ( myUpperFatherNonRoot != NULL )
        {
          myUpperFatherNonRoot ->groupSelect();
        }



      if ( mySelectedDGtalNode != NULL )
        {
          mySelectedDGtalNode->select();
        }
    }
  else
    {
      mySelectedDGtalNode = NULL;
      myUpperFatherNonRoot = NULL;
    }


}

/**
 *  Creates a triangle  and returns it's representation
 *  @param x1 xCoordinate for the first point
 *  @param y1 yCoordinate for the first point
 *  @param z1 zCoordinate for the first point
 *  @param x2 xCoordinate for the second point
 *  @param y2 yCoordinate for the second point
 *  @param z2 zCoordinate for the second point
 *  @param x3 xCoordinate for the second point
 *  @param y3 yCoordinate for the second point
 *  @param z3 zCoordinate for the second point
 *  @param aNode the future representation node
 *  @param materialNode the material name (should be precreated)
 * 
 *  @return the new representation
 */
DGtal::Representation * DGtal::ViewerOgre3D::addTriangle(double x1, double y1, double z1,
					   double x2, double y2,double z2,
					   double x3, double y3,double z3,
					   Ogre::SceneNode * aNode,std::string materialName)
{
  Ogre::SceneNode * m_bodySceneNode = aNode->createChildSceneNode();
  Ogre::ManualObject  * m_ent  = mySceneMgr->createManualObject ( );
  m_ent->begin ( materialName, Ogre::RenderOperation::OT_TRIANGLE_LIST );
  m_ent->position ( x1*scaleFactor, y1*scaleFactor, z1*scaleFactor );
  m_ent->textureCoord(0,1);
  m_ent->position ( x2*scaleFactor, y2*scaleFactor, z2*scaleFactor );
  m_ent->textureCoord(0,0);
  m_ent->position ( x3*scaleFactor, y3*scaleFactor, z3*scaleFactor );
  m_ent->textureCoord(1,0);
 
  
  m_ent->triangle(0,1,2);
  m_ent->triangle(2,1,0);
  m_ent->end();

  Ogre::MeshPtr  aMesh = m_ent->convertToMesh(m_bodySceneNode->getName());
  Ogre::Entity * aEntityMesh= mySceneMgr->createEntity(aMesh->getName());

  m_bodySceneNode->attachObject ( aEntityMesh );
  DGtal::Representation * aRepresentation = new Representation ( mySceneMgr, aEntityMesh, m_bodySceneNode, aEntityMesh->getName(), "Mesh" );
  aRepresentation->setMaterialName ( materialName );
  aRepresentation->setMaterial(myTempMaterial);
  return aRepresentation;
}



/**
 *  Creates a quad  and returns it's representation
 *  @param x1 xCoordinate for the first point
 *  @param y1 yCoordinate for the first point
 *  @param z1 zCoordinate for the first point
 *  @param x2 xCoordinate for the second point
 *  @param y2 yCoordinate for the second point
 *  @param z2 zCoordinate for the second point
 *  @param x3 xCoordinate for the second point
 *  @param y3 yCoordinate for the second point
 *  @param z3 zCoordinate for the second point
 *  @param x4 xCoordinate for the second point
 *  @param y4 yCoordinate for the second point
 *  @param z4 zCoordinate for the second point
 *  @param aNode the future representation node
 *  @param materialNode the material name (should be precreated)
 * 
 *  @return the new representation
 */
DGtal::Representation * DGtal::ViewerOgre3D::addQuad(double x1, double y1, double z1,
				       double x2, double y2,double z2,
				       double x3, double y3,double z3,
				       double x4, double y4,double z4,
				       Ogre::SceneNode * aNode,std::string materialName)
{
  Ogre::SceneNode * m_bodySceneNode = aNode->createChildSceneNode();
  Ogre::ManualObject  * m_ent  = mySceneMgr->createManualObject ( );
  m_ent->begin ( materialName, Ogre::RenderOperation::OT_TRIANGLE_LIST );

  m_ent->position ( x1*scaleFactor, y1*scaleFactor, z1*scaleFactor );
  m_ent->textureCoord(1,0);
  m_ent->position ( x2*scaleFactor, y2*scaleFactor, z2*scaleFactor );
  m_ent->textureCoord(0,0);
  m_ent->position ( x3*scaleFactor, y3*scaleFactor, z3*scaleFactor );
  m_ent->textureCoord(0,1);
  m_ent->position ( x4*scaleFactor, y4*scaleFactor, z4*scaleFactor );
  m_ent->textureCoord(1,1);


  m_ent->quad(0,1,2,3);
  m_ent->quad(3,2,1,0);
  m_ent->end();


  Ogre::MeshPtr  aMesh = m_ent->convertToMesh(m_bodySceneNode->getName());
  Ogre::Entity * aEntityMesh= mySceneMgr->createEntity(aMesh->getName());
  aEntityMesh->setMaterialName(materialName);
  m_bodySceneNode->attachObject ( aEntityMesh );
  DGtal::Representation * aRepresentation = new Representation ( mySceneMgr, aEntityMesh, m_bodySceneNode, aEntityMesh->getName(), "Mesh" );
  aRepresentation->setMaterialName ( materialName );
  aRepresentation->setMaterial(myTempMaterial);
  return aRepresentation;
}


/**
 *  Creates a polygon  and returns it's representation
 *  @param vectPontsPolygon it's a list of the point that makes the polygon
 *  @param aNode the future representation node
 *  @param materialNode the material name (should be precreated)
 * 
 *  @return the new representation
 */
DGtal::Representation * DGtal::ViewerOgre3D::addPolygon(std::vector<PointOgre3D>  vectPointsPolygon,Ogre::SceneNode * aNode,std::string materialName)
{
  Ogre::SceneNode * m_bodySceneNode = aNode->createChildSceneNode();
  Ogre::ManualObject  * m_ent  = mySceneMgr->createManualObject ( );

  m_ent->begin ( materialName, Ogre::RenderOperation::OT_TRIANGLE_LIST );
  std::vector<PointOgre3D>::iterator it;
  int i=vectPointsPolygon.size();

  
  for (it=vectPointsPolygon.begin();it!=vectPointsPolygon.end();it++ )
    {
      
      m_ent->position ( (*it).x  *scaleFactor,  (*it).y*scaleFactor,  (*it).z*scaleFactor );
      m_ent->textureCoord(i,vectPointsPolygon.size()-i);
      i--;
    }
    m_ent->textureCoord(1,0);
  for (int i=0;i!=vectPointsPolygon.size()-2;i++ )
    {
      m_ent->triangle(0,i+1,i+2);
    }


  for (int i=0;i!=vectPointsPolygon.size()-2;i++ )
    {
      m_ent->triangle(i+2,i+1,0);
    }

  m_ent->end();

  Ogre::MeshPtr  aMesh = m_ent->convertToMesh(m_bodySceneNode->getName());
  Ogre::Entity * aEntityMesh= mySceneMgr->createEntity(aMesh->getName());

  m_bodySceneNode->attachObject ( aEntityMesh );
  DGtal::Representation * aRepresentation = new Representation ( mySceneMgr, aEntityMesh, m_bodySceneNode, aEntityMesh->getName(), "Mesh" );
  aRepresentation->setMaterialName ( materialName );
  aRepresentation->setMaterial(myTempMaterial);
  return aRepresentation;
}



/**
 *  adds a line
 */
DGtal::Representation * DGtal::ViewerOgre3D::addLine ( double x1, double y1, double z1, double x2, double y2, double z2, Ogre::SceneNode * aNode,std::string materialName )
{

  Ogre::SceneNode * m_bodySceneNode = aNode->createChildSceneNode();
  Ogre::ManualObject  * m_ent  = mySceneMgr->createManualObject ( );
  m_ent->begin ( "BaseWhiteNoLighting", Ogre::RenderOperation::OT_LINE_LIST );
  m_ent->colour ( 0.5, 0.0, 1.0 );
  m_ent->position ( x1*scaleFactor, y1*scaleFactor, z1*scaleFactor );
  m_ent->position ( x2*scaleFactor, y2*scaleFactor, z2*scaleFactor );
  m_ent->end();
  m_ent->setCastShadows(false);
  Ogre::MeshPtr  aMesh = m_ent->convertToMesh(m_bodySceneNode->getName());
  Ogre::Entity * aEntityMesh= mySceneMgr->createEntity(aMesh->getName());
  m_bodySceneNode->attachObject ( aEntityMesh );
  DGtal::Representation * aRepresentation = new Representation ( mySceneMgr, m_ent, m_bodySceneNode, m_ent->getName(), "Entity" );
  aRepresentation->setMaterialName ( materialName );
  aRepresentation->setMaterial(myTempMaterial);
  return aRepresentation;
}

/**
 *  adds a point
 */
DGtal::Representation * DGtal::ViewerOgre3D::addPoint ( double x, double y, double z,
					  Ogre::SceneNode * aNode,std::string materialName, double factor )
{
  Ogre::Entity  * m_ent = mySceneMgr->createEntity ( Ogre::SceneManager::PT_SPHERE );
  m_ent->setCastShadows(true);
  m_ent->setMaterialName ( materialName );

  Ogre::SceneNode * m_bodySceneNode = aNode->createChildSceneNode();

  m_bodySceneNode->attachObject ( m_ent );
  
  m_bodySceneNode->setPosition ( Ogre::Vector3 ( x*scaleFactor, y*scaleFactor, z*scaleFactor ) );
  m_bodySceneNode->setScale ( factor*scaleFactor / 1000.0,
			      factor*scaleFactor / 1000.0, 
			      factor*scaleFactor / 1000.0 );
  
  DGtal::Representation * aRepresentation = new Representation ( mySceneMgr,
								 m_ent, m_bodySceneNode,
								 m_ent->getName(), "Entity" );

  aRepresentation->setMaterialName ( materialName );
  aRepresentation->setMaterial(myTempMaterial);
  return aRepresentation;
}


/**
 *  adds a voxel
 */
DGtal::Representation  * DGtal::ViewerOgre3D::addVoxel ( double x, double y, double z, 
					   Ogre::SceneNode * aNode,
					   std::string materialName )
{

  
  Ogre::Entity  * m_ent = mySceneMgr->createEntity ( Ogre::SceneManager::PT_CUBE );
  m_ent->setCastShadows(true);
  m_ent->setMaterialName ( materialName );

  Ogre::SceneNode * m_bodySceneNode = aNode->createChildSceneNode();

  m_bodySceneNode->attachObject ( m_ent );
  
  m_bodySceneNode->setPosition ( Ogre::Vector3 ( x*scaleFactor, y*scaleFactor, z*scaleFactor ) );
  m_bodySceneNode->setScale ( scaleFactor / 100.0,
			      scaleFactor / 100.0, 
			      scaleFactor / 100.0 );
  
  DGtal::Representation * aRepresentation = new Representation ( mySceneMgr,
								 m_ent, m_bodySceneNode,
								 m_ent->getName(), "Entity" );

  aRepresentation->setMaterialName ( materialName );
  aRepresentation->setMaterial(myTempMaterial);
  return aRepresentation;

}


/**
 *  adds a kalimsky voxel
 */
DGtal::Representation * DGtal::ViewerOgre3D::addKSVoxel ( int x, int y, int z, 
					    Ogre::SceneNode * aNode,
					    std::string materialName )
{
  Ogre::SceneNode * m_bodySceneNode = aNode->createChildSceneNode();
  Ogre::Entity  * m_ent = mySceneMgr->createEntity ( Ogre::SceneManager::PT_CUBE );
  m_ent->setMaterialName ( aNode->getName() );
  m_ent->setCastShadows(true);
  m_bodySceneNode->attachObject ( m_ent );
  
  m_bodySceneNode->setPosition ( Ogre::Vector3 ( ( x + 0.5 ) *scaleFactor,
						 ( y + 0.5 ) *scaleFactor,
						 ( z + 0.5 ) *scaleFactor ) );
  
  
  m_bodySceneNode->setScale ( scaleFactor / 120.0, scaleFactor / 120.0, scaleFactor / 120.0 );
  DGtal::Representation * aRepresentation = new Representation ( mySceneMgr,
								 m_ent, m_bodySceneNode, 
								 m_ent->getName(), "Entity" );
  aRepresentation->setMaterialName ( materialName);
  aRepresentation->setMaterial(myTempMaterial);
  return aRepresentation;
}


/**
 *  adds a kalimsky surfel
 */
DGtal::Representation * DGtal::ViewerOgre3D::addKSSurfel ( double x, double y, double z,
					     bool xSurfel, bool ySurfel, bool zSurfel,
					     Ogre::SceneNode * aNode ,std::string materialName)
{
  Ogre::SceneNode * m_bodySceneNode = aNode->createChildSceneNode();
  Ogre::Entity  * m_ent = mySceneMgr->createEntity ( Ogre::SceneManager::PT_CUBE );


  m_ent->setMaterialName ( materialName);
  m_ent->setCastShadows(true);
  if ( !xSurfel )
    {
      m_bodySceneNode->setScale ( scaleFactor / 2500.0, scaleFactor / 175.0, scaleFactor / 175.0 );

      m_bodySceneNode->attachObject ( m_ent );
      m_bodySceneNode->setPosition ( Ogre::Vector3 ( ( x + 0.5 ) *scaleFactor, ( y + 0.5 ) *scaleFactor, ( z + 0.5 ) *scaleFactor ) + Ogre::Vector3::UNIT_X* ( -0.5*scaleFactor ) );
    }
  else
    if ( !ySurfel )
      {
        m_bodySceneNode->setScale ( scaleFactor / 175.0, scaleFactor / 2500.0, scaleFactor / 175.0 );

        m_bodySceneNode->attachObject ( m_ent );

        m_bodySceneNode->setPosition ( Ogre::Vector3 ( ( x + 0.5 ) *scaleFactor, ( y + 0.5 ) *scaleFactor, ( z + 0.5 ) *scaleFactor )  + Ogre::Vector3::UNIT_Y* ( -0.5*scaleFactor ) );
      }
    else
      if ( !zSurfel )
        {
          m_bodySceneNode->setScale ( scaleFactor / 175.0, scaleFactor / 175.0, scaleFactor / 2500.0 );

          m_bodySceneNode->attachObject ( m_ent );
          m_bodySceneNode->setPosition ( Ogre::Vector3 ( ( x + 0.5 ) *scaleFactor, ( y + 0.5 ) *scaleFactor, ( z + 0.5 ) *scaleFactor ) + Ogre::Vector3::UNIT_Z* ( -0.5*scaleFactor ) );

        }


  DGtal::Representation * aRepresentation = new Representation ( mySceneMgr, m_ent, m_bodySceneNode, m_ent->getName(), "Entity" );

  aRepresentation->setMaterialName ( materialName);
  return aRepresentation;
}



/**
 * adds a kalimsky pointel
 */
DGtal::Representation * DGtal::ViewerOgre3D::addKSPointel ( double x, double y, double z,
					      Ogre::SceneNode * aNode ,
					      std::string materialName)
{
  Ogre::SceneNode * m_bodySceneNode = aNode->createChildSceneNode();
  Ogre::Entity  * m_ent = mySceneMgr->createEntity ( Ogre::SceneManager::PT_SPHERE );

  m_ent->setMaterialName ( materialName);
  m_ent->setCastShadows(true);
  m_bodySceneNode->attachObject ( m_ent );
  m_bodySceneNode->setPosition ( Ogre::Vector3 ( ( x + 0.5 ) *scaleFactor, ( y + 0.5 ) *scaleFactor, ( z + 0.5 ) *scaleFactor ) );
  m_bodySceneNode->setScale ( scaleFactor / 900.0, scaleFactor / 900.0, scaleFactor / 900.0 );
  DGtal::Representation * aRepresentation = new Representation ( mySceneMgr, m_ent, m_bodySceneNode, m_ent->getName(), "Entity" );
  aRepresentation->setMaterialName ( aNode->getName());
  aRepresentation->setMaterial(myTempMaterial);
  return aRepresentation;
}

/**
 * adds a kalimsky pointel
 */
DGtal::Representation * DGtal::ViewerOgre3D::addKSLinel ( double x1, double y1, double z1, 
					    double x2, double y2, double z2,
					    Ogre::SceneNode * aNode,
					    std::string materialName)
{

  Ogre::SceneNode * m_bodySceneNode = aNode->createChildSceneNode();
  Ogre::Entity  * m_ent = mySceneMgr->createEntity ( Ogre::SceneManager::PT_CUBE );

  m_ent->setMaterialName ( materialName );
  m_ent->setCastShadows(true);
  m_bodySceneNode->attachObject ( m_ent );

  if ( fabs ( ( x1 - x2 ) ) > 0.001 )
    {
      m_bodySceneNode->setScale ( scaleFactor / 150.0, scaleFactor / 2000.0, scaleFactor / 2000.0 );
      m_bodySceneNode->setPosition ( Ogre::Vector3 ( ( x1 + 1.0 ) *scaleFactor, ( y1 + 0.5 ) *scaleFactor, ( z1 + 0.5 ) *scaleFactor ) );
    }
  else
    if ( fabs ( ( y1 - y2 ) ) > 0.001 )
      {
        m_bodySceneNode->setScale ( scaleFactor / 2000.0, scaleFactor / 150.0, scaleFactor / 2000.0 );
        m_bodySceneNode->setPosition ( Ogre::Vector3 ( ( x1 + 0.5 ) *scaleFactor, ( y1 + 1.0 ) *scaleFactor, ( z1 + 0.5 ) *scaleFactor ) );
      }
    else
      if ( fabs ( ( z1 - z2 ) ) > 0.001 )
        {
          m_bodySceneNode->setScale ( scaleFactor / 2000.0, scaleFactor / 2000.0, scaleFactor / 150.0 );
          m_bodySceneNode->setPosition ( Ogre::Vector3 ( ( x1 + 0.5 ) *scaleFactor, ( y1 + 0.5 ) *scaleFactor, ( z1 + 1.0 ) *scaleFactor ) );
        }

  DGtal::Representation * aRepresentation = new Representation ( mySceneMgr, m_ent, m_bodySceneNode, m_ent->getName(), "Entity" );

  aRepresentation->setMaterialName ( materialName);
  aRepresentation->setMaterial(myTempMaterial);
  return aRepresentation;


}



/**
 *  Add a DgtalNode to the list
 */
void DGtal::ViewerOgre3D::addToList ( DGtalNode * aNode )
{

  myNodes[aNode->getName() ] = aNode;
}


/**
 *  Find the representation coressponding to a point
 */
DGtal::Representation * DGtal::ViewerOgre3D::findRepresentation ( std::string aName )
{


  std::map<std::string, DGtalNode *>::iterator aNode = myNodes.begin();

  Representation * theRepresentationToGet = NULL;

  while ( ( aNode != myNodes.end() ) && ( theRepresentationToGet == NULL ) )
    {


      theRepresentationToGet = ( *aNode ).second->ifRepresentation ( aName );

      if ( theRepresentationToGet != NULL )
        {

        }
      else
        {
          aNode++;
        }
    }

  return ( theRepresentationToGet );


}


/**
 *  clears the scene
 */
void DGtal::ViewerOgre3D::clearScene()
{
  myRootNode->clear();
  mySelectedDGtalNode = NULL;
  myUpperFatherNonRoot = NULL;
  myNodes.clear();
}


/**
 *   Displays the scene on the standard output
 */
void DGtal::ViewerOgre3D::sceneDisplay()
{
  myRootNode->display ( 0 );
}


/**
 * draws the axes
 */
void DGtal::ViewerOgre3D::drawAxes()
{

  // Coordinate system Drawing
  myAxis =  mySceneMgr->createManualObject ( "Entity_Axis" );
  myAxisNode = mySceneMgr->getRootSceneNode()->createChildSceneNode ( "Node_Axis" );

  myAxis->begin ( "BaseWhiteNoLighting", Ogre::RenderOperation::OT_LINE_LIST );


  myAxis->colour ( 1.0, 0.0, 0.0 );
  // Ex drawing
  myAxis->position ( 0, 0, 0 );
  myAxis->position ( 10, 0, 0 );
  myAxis->position ( 9, 0, 0.5 );
  myAxis->position ( 10, 0, 0 );
  myAxis->position ( 9, 0, -0.5 );
  myAxis->position ( 10, 0, 0 );
  myAxis->colour ( 0.0, 1.0, 0.0 );

  //Ey Drawing
  myAxis->position ( 0, 0, 0 );
  myAxis->position ( 0, 10, 0 );
  myAxis->position ( 0.5, 9, 0 );
  myAxis->position ( 0, 10, 0 );
  myAxis->position ( -0.5, 9, 0 );
  myAxis->position ( 0, 10, 0 );
  myAxis->colour ( 0.0, 0.0, 1.0 );

  //Ez Drawing
  myAxis->position ( 0, 0, 0 );
  myAxis->position ( 0, 0, 10 );
  myAxis->position ( 0.5, 0, 9 );
  myAxis->position ( 0, 0, 10 );
  myAxis->position ( -0.5, 0, 9 );
  myAxis->position ( 0, 0, 10 );

  myAxis->end();
  myAxis->setCastShadows(false);

  myAxisNode->attachObject ( myAxis );
}




/**
 * draws the wrist
 */
void DGtal::ViewerOgre3D::drawWrist()
{

  myWrist = mySceneMgr->createManualObject ( "Wrist" );


  float const radius = 10,
    thickness =0, // Of course this must be less than the radius value.
    accuracy = 35;

  myWrist->begin ( "BaseWhiteNoLighting",  Ogre::RenderOperation::OT_LINE_LIST  );
  myWrist->colour ( 0.2, 0.2, 0.2);
  unsigned point_index = 0;

  for ( float theta = 0; theta <= 2 * Ogre::Math::PI; theta += Ogre:: Math::PI / accuracy )
    {
      myWrist->position ( radius * cos ( theta ),
                          0,
                          radius * sin ( theta ) );
      myWrist->position ( radius * cos ( theta - Ogre::Math::PI / accuracy ),
                          0,
                          radius * sin ( theta - Ogre::Math::PI / accuracy ) );
      myWrist->position ( ( radius - thickness ) * cos ( theta - Ogre::Math::PI / accuracy ),
                          0,
                          ( radius - thickness ) * sin ( theta - Ogre::Math::PI / accuracy ) );
      myWrist->position ( ( radius - thickness ) * cos ( theta ),
                          0,
                          ( radius - thickness ) * sin ( theta ) );
    }

  myWrist->end();

  myWrist->begin ( "BaseWhiteNoLighting",  Ogre::RenderOperation::OT_LINE_LIST );
  myWrist->colour ( 1.0, 0.2, 0.2);
  myWrist->position ( radius + 8, 0, 0 );
  myWrist->position ( radius + 8 - 1.5, 0, -1.5 );

  myWrist->position ( radius + 8 - 1.5, 0, -1.5 );
  myWrist->position ( radius + 8 - 3, 0, 0 );

  myWrist->position ( radius + 8 - 3, 0, 0 );
  myWrist->position ( radius + 8 - 1.5, 0, 0 + 1.5 );

  myWrist->position ( radius + 8 - 1.5, 0, 0 + 1.5 );
  myWrist->position ( radius + 8, 0, 0 );


  myWrist->end();
  myWrist->begin ( "BaseWhiteNoLighting",  Ogre::RenderOperation::OT_LINE_LIST );
  myWrist->colour ( 0.2, 0.2, 0.2);
  for ( float theta = 0; theta <= 2 * Ogre::Math::PI; theta += Ogre:: Math::PI / accuracy )
    {
      myWrist->position ( 0, radius * cos ( theta ),
                          radius * sin ( theta ) );
      myWrist->position ( 0, radius * cos ( theta - Ogre::Math::PI / accuracy ),
                          radius * sin ( theta - Ogre::Math::PI / accuracy ) );
      myWrist->position ( 0, ( radius - thickness ) * cos ( theta - Ogre::Math::PI / accuracy ),
                          ( radius - thickness ) * sin ( theta - Ogre::Math::PI / accuracy ) );
      myWrist->position ( 0, ( radius - thickness ) * cos ( theta ),
                          ( radius - thickness ) * sin ( theta ) );
    }

  myWrist->end();

  myWrist->begin ( "BaseWhiteNoLighting",  Ogre::RenderOperation::OT_LINE_LIST );
  myWrist->colour ( 0.2, 1.0, 0.2);
  myWrist->position ( 0, radius + 8, 0 );
  myWrist->position ( 0, radius + 8 - 1.5, -1.5 );

  myWrist->position ( 0, radius + 8 - 1.5, -1.5 );
  myWrist->position ( 0, radius + 8 - 3, 0 );

  myWrist->position ( 0, radius + 8 - 3, 0 );
  myWrist->position ( 0, radius + 8 - 1.5, 0 + 1.5 );

  myWrist->position ( 0, radius + 8 - 1.5, 0 + 1.5 );
  myWrist->position ( 0, radius + 8, 0 );


  myWrist->end();


  myWrist->begin ( "BaseWhiteNoLighting",  Ogre::RenderOperation::OT_LINE_LIST );
  myWrist->colour ( 0.2, 0.2, 0.2);
  for ( float theta = 0; theta <= 2 * Ogre::Math::PI; theta += Ogre:: Math::PI / accuracy )
    {
      myWrist->position ( radius * cos ( theta ),
                          radius * sin ( theta ),0 );
      myWrist->position (  radius * cos ( theta - Ogre::Math::PI / accuracy ),
			   radius * sin ( theta - Ogre::Math::PI / accuracy ),0 );
      myWrist->position (  ( radius - thickness ) * cos ( theta - Ogre::Math::PI / accuracy ),
			   ( radius - thickness ) * sin ( theta - Ogre::Math::PI / accuracy ),0 );
      myWrist->position (  ( radius - thickness ) * cos ( theta ),
			   ( radius - thickness ) * sin ( theta ),0 );
    }

  myWrist->end();

  myWrist->begin ( "BaseWhiteNoLighting",  Ogre::RenderOperation::OT_LINE_LIST );
  myWrist->colour ( 0.2, 0.2, 1.0);
  myWrist->position (   0,0,radius + 8 );
  myWrist->position (   -1.5,0,radius + 8 - 1.5 );

  myWrist->position (   -1.5,0, radius + 8 - 1.5 );
  myWrist->position (   0, 0,radius + 8 - 3 );

  myWrist->position ( 0 ,0 ,  radius + 8 - 3);
  myWrist->position (  0 + 1.5, 0,radius + 8 - 1.5 );

  myWrist->position (   0 + 1.5,0,radius + 8 - 1.5 );
  myWrist->position (  0,0,radius + 8 );


  myWrist->end();
 
  myWrist->setCastShadows(false);
  myWristNode = mySceneMgr->getRootSceneNode()->createChildSceneNode();
  myWristNode->attachObject ( myWrist );
}




/**
 *  Flips the axis visibility .
 */
void DGtal::ViewerOgre3D::changeAxisVisibility()
{
  myAxisNode->flipVisibility();
}


/**
 *   Returns the lower point of the scene
 */
Ogre::Vector3 DGtal::ViewerOgre3D::getLowerPosition()
{

  std::map<std::string, DGtalNode *>::iterator them = myNodes.begin();
  Ogre::Vector3 low = ( *them ).second->getNode()->getPosition();
  while ( them != myNodes.end() )
    {
      if ( ( low.z ) > ( ( *them ).second->getNode()->getPosition().z ) )
        {
          low = ( *them ).second->getNode()->getPosition();
        }

      them ++;
    }

  return low;
}



/**
 *   Returns the upper point of the scene
 */
Ogre::Vector3 DGtal::ViewerOgre3D::getUpperPosition()
{
  Ogre::Vector3 up = Ogre::Vector3 ( 0, 0, 0 );
  std::map<std::string, DGtalNode *>::iterator them = myNodes.begin();

  while ( them != myNodes.end() )
    {
      if ( ( up.z ) < ( ( *them ).second->getNode()->getPosition().z ) )
        {
          up = ( *them ).second->getNode()->getPosition();
        }

      them ++;
    }

  return up;
}


/**
 *  Returns the leftest point
 */
Ogre::Vector3 DGtal::ViewerOgre3D::getLeftestPosition()
{
  Ogre::Vector3 up = Ogre::Vector3 ( 0, 0, 0 );
  std::map<std::string, DGtalNode *>::iterator them = myNodes.begin();

  while ( them != myNodes.end() )
    {
      if ( ( up.y ) > ( ( *them ).second->getNode()->getPosition().y ) )
        {
          up = ( *them ).second->getNode()->getPosition();
          them ++;
        }

      them ++;
    }

  return up;
}

/**
 *  Loads the fonts
 */
void DGtal::ViewerOgre3D::loadFonts()
{
  // get the resource manager
  Ogre::ResourceGroupManager &resGroupMgr = Ogre::ResourceGroupManager::getSingleton();
  // get the font manager
  Ogre::FontManager &fontMgr = Ogre::FontManager::getSingleton();
  // create a font resource
  Ogre::ResourcePtr font = fontMgr.create("MyFont","General");
  // set as truetype
  font->setParameter("type","truetype");
  // set the .ttf file name
  font->setParameter("source","NanumGothic.ttf");
  // set the size
  font->setParameter("size","18");
  // set the dpi
  font->setParameter("resolution","96");
  // load the ttf
  font->load();
}

/**
 *  Returns the Fowardest point
 */
Ogre::Vector3 DGtal::ViewerOgre3D::getFowardestPosition()
{
  Ogre::Vector3 up = Ogre::Vector3 ( 0, 0, 0 );
  std::map<std::string, DGtalNode *>::iterator them = myNodes.begin();

  while ( them != myNodes.end() )
    {
      if ( ( up.x ) > ( ( *them ).second->getNode()->getPosition().x ) )
        {
          up = ( *them ).second->getNode()->getPosition();
          them ++;
        }

      them ++;
    }

  return up;
}

/**
 *  updates the manipulating value
 */
void DGtal::ViewerOgre3D::newManipulatingValue ( int change )
{
  if ( change > 0 )
    {
      if ( ( myCurrentManupulating + myStep ) < myMaxManupulating )
        {
          myCurrentManupulating += myStep;
          myInputManager->stopRendering();
        }
    }
  else
    {
      if ( ( myCurrentManupulating - myStep ) > myMinManupulating )
        {
          myCurrentManupulating -= myStep;
          myInputManager->stopRendering();
        }
    }
    

  updateManipulateDisplay();
}


/**
 *  Updates the manipulate label value
 */
void DGtal::ViewerOgre3D::updateManipulateDisplay()
{

  string current;  
  ostringstream currentconvert; 
  currentconvert << myCurrentManupulating;   
  current = currentconvert.str();
    
  string max;  
  ostringstream maxconvert; 
  maxconvert << myMaxManupulating;   
  max = maxconvert.str();
    
  string min;  
  ostringstream minconvert; 
  minconvert << myMinManupulating;   
  min = minconvert.str();
    
  string step;  
  ostringstream stepconvert; 
  stepconvert << myStep;   
  step = stepconvert.str();
    
    
  myMode->setCaption("Mode: Manipulate / Current Value: "+  current +" / Max: "+  max +" / Min: "+  min +" / Step: "+  step );

}


/**
 *  Stops the manipulating mode
 */
void DGtal::ViewerOgre3D::abortManupulating()
{
  myInputManager->stopRendering();
  myManupilatingFlag = false;
}


/**
 *  Set the near and far clip distance of the camera
 */
void DGtal::ViewerOgre3D::setNearFar ( double near, double far )
{
  myCamera->setNearClipDistance ( scaleFactor*near );
  myCamera->setFarClipDistance ( scaleFactor*far );
}


void DGtal::ViewerOgre3D::setCameraUpVector ( Ogre::Vector3   anUp )
{
  myCamera->setFixedYawAxis ( true, anUp );
}




/**
 *  set's the camera upvector
 */
void DGtal::ViewerOgre3D::setCameraDirection ( Ogre::Vector3  aPoint )
{
  myCamera->lookAt ( aPoint );
}


/**
 *  Set's the camera position
 */
void DGtal::ViewerOgre3D::setCameraPosition ( Ogre::Vector3  aPosition )
{
  myCamera->setPosition ( aPosition );
}

/**
 *  adds a clipping plane
 */
void DGtal::ViewerOgre3D::addClippingPlane ( double a, double b, double c, double d )
{
  myRoot->getRenderSystem()->addClipPlane ( Ogre::Plane ( a, b, c, d ) );
}


/**
 *  Computes the scene center
 */
void  DGtal::ViewerOgre3D::computeSceneCenter ( )
{
  Ogre::Vector3 upper = getUpperPosition();
  Ogre::Vector3 lower = getLowerPosition();
  mySceneCenter = ( upper + lower ) / 2.0;
}




/**
 * Updates the wrist position
 */
void  DGtal::ViewerOgre3D::updateWrist ( )
{
  myWristNode->setPosition ( mySceneCenter );

}

/**
 * Sets the new initial position of the cameraman
 */
void DGtal::ViewerOgre3D::updateInitialCameraPosition( )
{
  Ogre::Vector3 initialPos = getFowardestPosition() + getLeftestPosition() + getUpperPosition();
  myInputManager->getCameraMan()->setInitialPosition ( initialPos );

}

/**
 *  Creates a texture starting from a DGtal color
 */
void DGtal::ViewerOgre3D::createMaterial(std::string  aName )
{
  Ogre::MaterialManager& lMaterialManager = Ogre::MaterialManager::getSingleton();
  Ogre::MaterialPtr lMaterial = lMaterialManager.create ( aName, "General" );
  Ogre::Technique* lFirstTechnique = lMaterial->getTechnique ( 0 );
  Ogre::Pass* lFirstPass = lFirstTechnique->getPass ( 0 );

  Ogre::ColourValue lSelfIllumnationColour ( ( double ) myCurrentSelfIlluminationColor.red() / 255.0,
					     ( double ) myCurrentSelfIlluminationColor.green() / 255.0, 
					     ( double ) myCurrentSelfIlluminationColor.blue() / 255.0,
					     ( double ) myCurrentSelfIlluminationColor.alpha()/ 255.0 );
  lFirstPass->setSelfIllumination ( lSelfIllumnationColour );


  Ogre::ColourValue lDiffuseColour ( ( double ) myCurrentDiphuseIlluminationColor.red() / 255.0,
				     ( double ) myCurrentDiphuseIlluminationColor.green() / 255.0, 
				     ( double ) myCurrentDiphuseIlluminationColor.blue() / 255.0, 
				     ( double ) myCurrentDiphuseIlluminationColor.alpha()/ 255.0);
  lFirstPass->setDiffuse ( lDiffuseColour );

  Ogre::ColourValue lAmbientColour (( double ) myCurrentAmbientIlluminationColor.red() / 255.0, 
				    ( double ) myCurrentAmbientIlluminationColor.green() / 255.0,
				    ( double ) myCurrentAmbientIlluminationColor.blue() / 255.0, 
				    ( double ) myCurrentAmbientIlluminationColor.alpha()/ 255.0 );
  lFirstPass->setAmbient ( lAmbientColour );

  // I want the specular to not be transparent.
  Ogre::ColourValue lSpecularColour ( ( double ) myCurrentSpecularIlluminationColor.red() / 255.0,
				      ( double ) myCurrentSpecularIlluminationColor.green() / 255.0, 
				      ( double ) myCurrentSpecularIlluminationColor.blue() / 255.0,
				      ( double ) myCurrentSpecularIlluminationColor.alpha()/ 255.0 );
  lFirstPass->setSpecular ( lSpecularColour );

  Ogre::Real lShininess = 64.0f;
  lFirstPass->setShininess ( lShininess );
  Ogre::TextureUnitState* lTextureUnit = lFirstPass->createTextureUnitState();
  
  lTextureUnit->setTextureName("unselected.jpg", Ogre::TEX_TYPE_2D);
  lTextureUnit->setTextureCoordSet(0.1);



  // This pass will use the "alpha" to make things transparent.
  // I disallow depth write (don't write in the Z-Buffer, check an opengl book for details).
  lFirstPass->setSceneBlending ( Ogre::SBT_TRANSPARENT_ALPHA );
  lFirstPass->setDepthWriteEnabled ( false );
  
  myTempMaterial = lMaterial;
}




//-------------------------------------------------------------------------------------Color management
/**
 *  Sets the self illumination color of the following object
 */
inline
void DGtal::ViewerOgre3D::setSelfIlluminationColor(DGtal::Color aColor)
{
  myCurrentSelfIlluminationColor=aColor;
}


/**
 *  Sets the Ambient illumination color of the following object
 */
inline
void DGtal::ViewerOgre3D::setAmbientIlluminationColor(DGtal::Color aColor)
{
  myCurrentAmbientIlluminationColor=aColor;
}

/**
 *  Sets the Specular illumination color of the following object
 */
inline
void DGtal::ViewerOgre3D::setSpecularIlluminationColor(DGtal::Color aColor)
{
  myCurrentSpecularIlluminationColor=aColor;
}

/**
 *  Sets the diphuse illumination color of the following object
 */
inline
void DGtal::ViewerOgre3D::setDiphuseIlluminationColor(DGtal::Color aColor)
{
  myCurrentDiphuseIlluminationColor=aColor;
}


/**
 *  Sets the texture of the following object
 */
inline
void DGtal::ViewerOgre3D::setTexture(std::string aTexture)
{
  myTexture=aTexture;
}




/**
 *  Returns the self illumination color of the following object
 */
DGtal::Color DGtal::ViewerOgre3D::getSelfIlluminationColor( )
{
  return DGtal::Color(255,255,255,255);
}


/**
 *  Returns the Ambient illumination color of the following object
 */
DGtal::Color  DGtal::ViewerOgre3D::getAmbientIlluminationColor( )
{
  return DGtal::Color(255,255,255,255);
}

/**
 *  Returns the Specular illumination color of the following object
 */
DGtal::Color DGtal::ViewerOgre3D::getSpecularIlluminationColor( )
{
  return DGtal::Color(255,255,255,255);
}

/**
 *  Returns the diphuse illumination color of the following object
 */
DGtal::Color DGtal::ViewerOgre3D::getDiphuseIlluminationColor( )
{ 
  return DGtal::Color(255,255,255,255);
}

/**
 *   Returns  the texture of the following object
 */
std::string DGtal::ViewerOgre3D::getTexture()
{
  return "";
}
     

/**
 *  
 */
void DGtal::ViewerOgre3D::more( )
{
  if (myUpperFatherNonRoot!=NULL)
    {
      myUpperFatherNonRoot->more();
    }
}


/**
 *  
 */
void DGtal::ViewerOgre3D::less( )
{
  if (myUpperFatherNonRoot!=NULL)
    {
      myUpperFatherNonRoot->less();
    }
}


/**
 *  Increases the transparency of the current UNFR
 */
void DGtal::ViewerOgre3D::moreTransparency( )
{
  if (myUpperFatherNonRoot!=NULL)
    {
      myUpperFatherNonRoot->moreTransparency();
    }
}


/**
 *  Decreases the transparency of the current UNFR
 */
void DGtal::ViewerOgre3D::lessTransparency( )
{
  if (myUpperFatherNonRoot!=NULL)
    {
      myUpperFatherNonRoot->lessTransparency();
    }
}

/**
 * Destroys the scene
 */
void DGtal::ViewerOgre3D::destroyScene()
{
  delete myRootNode;
}

/**
 *  Shows the commands on the standard output
 */
void DGtal::ViewerOgre3D::showHelp()
{
  cout <<"-------------------------------------------------------------------------------------------"<<endl;
  cout <<"Ogre DGtal viewer commands: \n"<<endl;
  
  cout<<"\tCommon commands to view, manipulate and selection modes:\n"<<endl;
  
  cout<<"\t\t Mouse interactions:\n"<<endl;
  cout<<"\t\t\t Right clic and drag: Translates the scene."<<endl;
  cout<<"\t\t\t Left clic and drag: Turns the scene around the scene center."<<endl;
  cout<<"\t\t\t Left shift + Left clic : Selects a scene object."<<endl;
  cout<<"\t\t\t Mouse roll: Zoom.\n"<<endl;
  
  
  cout <<"\t\t Commands without selection\n"<<endl;
  cout <<"\t\t\t P: Show/Hide the orthonormal basis."<<endl;
  cout <<"\t\t\t O: Shows/Hides the wirsts."<<endl;
  cout <<"\t\t\t G: Shows/Hides the shadow plane."<<endl;
  cout <<"\t\t\t T: Shows/Hides the text."<<endl;
  cout <<"\t\t\t F: Changes the background color, from black to white and the inverse operation."<<endl;
  cout <<"\t\t\t R: Resets the camera position."<<endl;
  cout <<"\t\t\t J: Sets full screen."<<endl;
  cout <<"\t\t\t I: Repositions the camera at (0,0) position."<<endl;
  cout <<"\t\t\t Left Control U: Scales up the window."<<endl;
  cout <<"\t\t\t Left Control Y: Scales down the window."<<endl;
  cout <<"\t\t\t X: Exports the scene to XML format and saves it to scene.scene."<<endl;
  cout <<"\t\t\t C: Takes a screen capture of the viewer and saves it to ScreenShot.png "<<endl;
  cout <<"\t\t\t H: Shows the user help on the standard output. "<<endl;
  cout <<"\t\t\t Escape: Shuts down the viewer.  "<<endl;

  
  cout<<"\t\t Commands when something is selected\n"<<endl;

  cout<<"\t\t\t K: Sizes up the selection."<<endl;
  cout<<"\t\t\t L: Sizes down the selection."<<endl;

  cout<<"\t\t\t N: Increases the selection's transparency."<<endl;
  cout<<"\t\t\t B: Decreases the selection's transparency.\n"<<endl;


  cout<<"\tSpecific commands\n"<<endl;
  cout<<"\t\t\tOn view mode:\n"<<endl;

  cout <<"\t\t\tOn manipulate mode:\n"<<endl;
  cout <<"\t\t\t U : Gets to the upper value of the manipulating. "<<endl;
  cout <<"\t\t\t Y : Gets to the lower value of the manipulating. "<<endl;


  cout <<"\t\t\tOn selection mode:\n"<<endl;
  cout <<"\t\t\t S : Confirms the selection.\n "<<endl;
  
  cout <<"\tOn free 3D explore: (To switch to this mode press MAJ button)\n"<<endl;
  cout <<"-------------------------------------------------------------------------------------------"<<endl;

}
/**
 *  Changes the text position on   a window resize
 */
void DGtal::ViewerOgre3D::resetPosition(int h, int w)
{
  myMode->setPosition(w/30,h-h/20);
  //myMode->setSize(36);
  // Parametrage du point de vue
  myCamera->setAspectRatio ( Ogre::Real ( myViewPort->getActualWidth() ) / Ogre::Real ( myViewPort->getActualHeight() ) );


}
/**
 *  Changes the text position on   a window resize
 */
void DGtal::ViewerOgre3D::printScene(std::string name)
{
  myWindow->writeContentsToFile(name);
  char path[500];
  cout<<"Screenshot saved at :"<< getcwd(path, 500)<<"/"<<name<<endl;
}

/**
 *  Flips the wrist visibility .
 */
void DGtal::ViewerOgre3D::changeWristVisibility()
{
  myWrist->setVisible(!myWrist->isVisible());
}

/**
 *  Flips the background color.
 */ 
void DGtal::ViewerOgre3D::flipBackgroundColor()
{
  if(myBackgroundBlackColor)
    {
      myViewPort->setBackgroundColour(Ogre::ColourValue (1.0,1.0,1.0));
      myBackgroundBlackColor=false;
    }
  else
    {
      myViewPort->setBackgroundColour(Ogre::ColourValue ( 129.0/255., 192.0/255.,255.0/255.));
      myBackgroundBlackColor=true;
    }
  
}


/**
 * Changes the visibility of the shadow cast plane 
 */
void DGtal::ViewerOgre3D::flipPlaneVisibility()
{
  myPlane->flipVisibility();
}

/**
 *  Updates the shadow plane position
 */
void DGtal::ViewerOgre3D::updatePlane (  )
{
  myPlane->setPosition ( getLowerPosition()-Ogre::Vector3(0.0,0.0,scaleFactor) );
}


/**
 *  Adds a point light to scene
 *  @param aColor the light's position
 *  @param aPosition the light's Color
 *  @param aCast defines if the light cast's shadows or not
 */
void  DGtal::ViewerOgre3D::addPointLight (DGtal::Color aColor, DGtal::Z3i::Point aPosition,bool aCast  )
{
  Ogre::Light * light = mySceneMgr->createLight ( "Light" );
  light->setType ( Ogre::Light::LT_POINT);
  light->setDiffuseColour ( aColor.red()/255.0,aColor.green()/255.0, aColor.blue()/255.0 );
  light->setSpecularColour ( aColor.red()/255.0,aColor.green()/255.0, aColor.blue()/255.0  );
  light->setPosition ( aPosition[0]*scaleFactor, 
		       aPosition[1]*scaleFactor,
		       aPosition[2]*scaleFactor );
  light->setCastShadows(aCast);
}




/**
 *  Adds a spot light to scene
 *  @param aColor the light's position
 *  @param direction the light's direction
 *  @param aPosition the light's Color
 *  @param aCast defines if the light cast's shadows or not
 */
void  DGtal::ViewerOgre3D::addSpotLight (DGtal::Color aColor, DGtal::Z3i::Point aPosition,
				  DGtal::Z3i::Point aDirection,bool aCast    )
{
  Ogre::Light * light = mySceneMgr->createLight ( "Light" );
  light->setType ( Ogre::Light::LT_SPOTLIGHT);
  light->setDirection ( Ogre::Vector3 ( aPosition[0]*scaleFactor, aPosition[1]*scaleFactor, aPosition[2]*scaleFactor  ) );
  light->setDiffuseColour ( aColor.red()/255.0,aColor.green()/255.0, aColor.blue()/255.0  );
  light->setSpecularColour ( aColor.red()/255.0,aColor.green()/255.0, aColor.blue()/255.0  );
  light->setPosition ( aPosition[0]*scaleFactor, aPosition[1]*scaleFactor, aPosition[2]*scaleFactor );
  light->setCastShadows(aCast);
}


/**
 *  Adds a directionnal light to scene
 *  @param aColor the light's position
 *  @param direction the light's direction
 *  @param aPosition the light's Color
 *  @param aCast defines if the light cast's shadows or not
 */
void  DGtal::ViewerOgre3D::addDirectionalLight ( DGtal::Color aColor, DGtal::Z3i::Point aPosition,
					  DGtal::Z3i::Point aDirection,bool aCast   )
{
  Ogre::Light * light = mySceneMgr->createLight ( "Light" );
  light->setType ( Ogre::Light::LT_DIRECTIONAL);
  light->setDirection ( Ogre::Vector3 ( aPosition[0]*scaleFactor, 
					aPosition[1]*scaleFactor, 
					aPosition[2]*scaleFactor  ) );

  light->setDiffuseColour (  aColor.red()/255.0,aColor.green()/255.0, aColor.blue()/255.0  );
  light->setSpecularColour ( aColor.red()/255.0,aColor.green()/255.0, aColor.blue()/255.0 	 );

  light->setPosition ( aPosition[0]*scaleFactor, 
		       aPosition[1]*scaleFactor, 
		       aPosition[2]*scaleFactor );

  light->setCastShadows(aCast);
}

/**
 *  Exports the scene to an xml file
 *  @param aFileName name of the file that will contain 
 *  the xml version of the scene (do not give the extention)
 */
void DGtal::ViewerOgre3D::exportToXml(std::string aFileName )
{
  DGtal::XMLExporter anExporter;
  anExporter.exportToFile(mySceneMgr, aFileName);
}



/**
 *  Exports the scene to a vrml file
 *  @param aFileName name of the file that will contain 
 *  the vrml version of the scene (do not give the extention)
 */
void DGtal::ViewerOgre3D::exportToVrml(std::string aFileName )
{
  DGtal::VRMLExporter anExporter;
  anExporter.exportToFile(mySceneMgr, aFileName);
}


/**
 * Returns a good position for the camera 
 */
Ogre::Vector3 DGtal::ViewerOgre3D::goodCameraPosition()
{
  return (getLeftestPosition()+ getUpperPosition() +Ogre::Vector3(30.0,30.0,30.0));
}


/**
 * Changes the visibility of the text
 */
void DGtal::ViewerOgre3D::flipTextVisibility()
{
  myMode->flipVisibility();
}

/**
 * This method validates the user seletion 
 */
void DGtal::ViewerOgre3D::confirmSelection()
{
  if ( mySelectedDGtalNode!=NULL )
    {
      myInputManager->stopRendering();
    }
}


/**
 *  Tells if the viewer is in selection mode
 */
bool DGtal::ViewerOgre3D::isInSelectionMode()
{ 
  return mySelectionMode;
}
