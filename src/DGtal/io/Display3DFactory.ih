/**
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file Display3DFactory.ih
 * @author Martial Tola <http://liris.cnrs.fr/martial.tola/>
 * @date mercredi 21 septembre 2011
 *
 * @brief
 *
 * Implementation of inline methods defined in Display3DFactory.h
 *
 * This file is part of the DGtal library.
 */

#include "DGtal/helpers/StdDefs.h"
#include "DGtal/images/ImageHelper.h"

///////////////////////////////////////////////////////////////////////////////
// Implementation of inline methods //

//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions and external operators //

// SphericalAccumulator
template <typename Space, typename KSpace>
template <typename TV>
inline
void
DGtal::Display3DFactory<Space,KSpace>::draw( Display3D<Space, KSpace> & display,
					     const DGtal::SphericalAccumulator<TV> & aAccumulator,
					     const typename DGtal::SphericalAccumulator<TV>::RealVector &shift,
					     const double radius)
{
  DGtal::Color saveFillColor = display.getFillColor();
  typedef typename DGtal::SphericalAccumulator<TV>::Size Size;
  typename DGtal::SphericalAccumulator<TV>::RealVector a,b,c,d;
  Size i,j;
  DGtal::int32_t m = 1, M=0;
  for(typename DGtal::SphericalAccumulator<TV>::ConstIterator it = aAccumulator.begin(),
        itend= aAccumulator.end(); it != itend; ++it)
    {
      aAccumulator.binCoordinates(it, i,j);
      if (aAccumulator.isValidBin(i,j))
        {
          if (aAccumulator.count(i,j) > M) M=aAccumulator.count(i,j);
          if (aAccumulator.count(i,j) < m) m=aAccumulator.count(i,j);
        }
    }
  HueShadeColorMap<typename DGtal::SphericalAccumulator<TV>::Quantity> cmap(m,M+1);

  for(typename DGtal::SphericalAccumulator<TV>::ConstIterator it = aAccumulator.begin(),
        itend= aAccumulator.end(); it != itend; ++it)
    {
      aAccumulator.binCoordinates(it, i,j);
      if (aAccumulator.isValidBin(i,j))
        {
          aAccumulator.binCoordinates(it, i,j);
          aAccumulator.getBinGeometry(i,j,a,b,c,d);
          a+= shift;
          b+= shift;
          c+= shift;
          d+= shift;
          a = a*radius;
          b = b*radius;
          c = c*radius;
          d = d*radius;

          display.setFillColor( cmap(aAccumulator.count(i,j)));
          display.addQuad(a, b, c, d);
        }
    }
  display.setFillColor( saveFillColor);
}
// SphericalAccumulator



// Mesh
template <typename Space, typename KSpace>
template <typename TPoint>
inline
void DGtal::Display3DFactory<Space,KSpace>::draw( Display3D<Space, KSpace> & display,
						  const DGtal::Mesh<TPoint> & aMesh )
{
  std::string mode = display.getMode( aMesh.className() );
  if ( mode == "Faces" || mode=="")
    drawAsFaces( display, aMesh );
}

template <typename Space, typename KSpace>
template <typename TPoint>
inline
void DGtal::Display3DFactory<Space,KSpace>::drawAsFaces( Display3D<Space, KSpace> & display,
							 const DGtal::Mesh<TPoint> & aMesh )
{
  DGtal::Color fillColorSave = display.getFillColor();
  bool useGlobalColor =  !aMesh.isStoringFaceColors();
  display.createNewQuadList(aMesh.className());
  for(unsigned int i=0; i< aMesh.nbFaces(); i++)
    {
      typename Mesh<TPoint>::MeshFace aFace = aMesh.getFace(i);
      unsigned int aNum = aFace.size();
      if(!useGlobalColor){
        display.setFillColor(aMesh.getFaceColor(i));
      }
      if(aNum==4)
        {
          TPoint p1 = aMesh.getVertex(aFace.at(0));
          TPoint p2 = aMesh.getVertex(aFace.at(1));
          TPoint p3 = aMesh.getVertex(aFace.at(2));
          TPoint p4 = aMesh.getVertex(aFace.at(3));

          display.addQuad(p1, p2, p3, p4);
        }else if(aNum==3)
        {
          TPoint p1 = aMesh.getVertex(aFace.at(0));
          TPoint p2 = aMesh.getVertex(aFace.at(1));
          TPoint p3 = aMesh.getVertex(aFace.at(2));

          display.addTriangle(p1, p2,p3);
        }else if(aNum>4)
        {
          std::vector<typename Display3D<Space, KSpace>::RealPoint> vectPoly;
          for(unsigned int j=0; j< aFace.size(); j++)
            {
              typename Display3D<Space, KSpace>::RealPoint point(aMesh.getVertex(aFace.at(j)));
              vectPoly.push_back(point);
            }
          display.addPolygon(vectPoly);
        }else
        {
          trace.warning()<< "Face not valid, only "<< aNum << "vertex... "<< std::endl;
        }
    }
  display.setFillColor(fillColorSave);
}
// Mesh


// StandardDSS6Computer
template <typename Space, typename KSpace>
template <typename TIterator, typename TInteger, int connectivity>
inline
void DGtal::Display3DFactory<Space,KSpace>::drawAsBalls( Display3D<Space, KSpace> & display,
							 const DGtal::StandardDSS6Computer<TIterator,TInteger,connectivity> & a )
{
  typedef TIterator ConstIterator;
  typedef typename IteratorCirculatorTraits<ConstIterator>::Value Point3d;

  // Draw points
  display << CustomColors3D( display.getLineColor(), display.getFillColor() );
  for (ConstIterator i = a.begin(); i != a.end(); ++i)
    {
      display << *i;
    }

  // Draw a linking polygonal line if the voxels are drawn as points.
  if(display.getMode("PointVector")=="Grid")
    {
      ConstIterator k = a.begin();
      Point3d prevp = *k;
      DGtal::Z3i::RealPoint rprevp = display.embed( prevp);
      ++k;
      for ( ; k != a.end(); ++k) {
        Point3d p = *k;
        DGtal::Z3i::RealPoint rp = display.embed( p );

        display.addLine(rprevp,rp);
        rprevp = rp;
      }
    }
}

template <typename Space, typename KSpace>
template <typename TIterator, typename TInteger, int connectivity>
inline
void
DGtal::Display3DFactory<Space,KSpace>::drawAsBoundingBox( Display3D<Space, KSpace> & display,
							  const DGtal::StandardDSS6Computer<TIterator,TInteger,connectivity> & a )
{

  typedef TIterator ConstIterator;

  typedef typename IteratorCirculatorTraits<ConstIterator>::Value Point3d;
  typedef DGtal::PointVector<3,double> PointD3d;

  typedef typename IteratorCirculatorTraits<ConstIterator>::Value Vector3d;
  typedef DGtal::PointVector<3,double> VectorD3d;

  typedef TInteger Integer;

  //get DSS parameters
  Vector3d v; //direction vector
  PointD3d mu; //intercept
  PointD3d omega; //thickness
  a.getParameters(v,mu,omega);

  //casting coordinates of v in double
  VectorD3d u = VectorD3d(NumberTraits<Integer>::castToDouble(v[0]),
                          NumberTraits<Integer>::castToDouble(v[1]),
                          NumberTraits<Integer>::castToDouble(v[2]) );
  //L2 norm of u
  double n = u[0]*u[0] + u[1]*u[1] + u[2]*u[2];

  //first and last points
  Point3d first = *a.begin();
  Point3d last = *(--a.end());
  PointD3d f = PointD3d(NumberTraits<Integer>::castToDouble(first[0]),
                        NumberTraits<Integer>::castToDouble(first[1]),
                        NumberTraits<Integer>::castToDouble(first[2]) );
  PointD3d l = PointD3d(NumberTraits<Integer>::castToDouble(last[0]),
                        NumberTraits<Integer>::castToDouble(last[1]),
                        NumberTraits<Integer>::castToDouble(last[2]) );

  if (n != 0) {

    //last coefficient of the normal plane to the DSS direction
    //passing trough f and l
    double df = -u[0]*f[0] -u[1]*f[1] -u[2]*f[2];
    double dl = -u[0]*l[0] -u[1]*l[1] -u[2]*l[2];

    //omega masks
    PointD3d omega1, omega2;
    if (omega[0] == 0) {
      omega1 = PointD3d(0,omega[1],0);
      omega2 = PointD3d(0,0,omega[2]);
    } else {
      if (omega[1] == 0) {
        omega1 = PointD3d(omega[0],0,0);
        omega2 = PointD3d(0,0,omega[2]);
      } else {//omega[2] == 0
        omega1 = PointD3d(omega[0],0,0);
        omega2 = PointD3d(0,omega[1],0);
      }
    }

    double m1 = u[0]*mu[0] + u[1]*mu[1] + u[2]*mu[2];
    double m2 = u[0]*(mu[0]+omega1[0]) + u[1]*(mu[1]+omega1[1]) + u[2]*(mu[2]+omega1[2]);
    double m3 = u[0]*(mu[0]+omega2[0]) + u[1]*(mu[1]+omega2[1]) + u[2]*(mu[2]+omega2[2]);
    double m4 = u[0]*(mu[0]+omega[0]) + u[1]*(mu[1]+omega[1]) + u[2]*(mu[2]+omega[2]);

    //4 lines
    PointD3d pf = PointD3d( mu[0] - ( (m1+df)*u[0] )/n,
                            mu[1] - ( (m1+df)*u[1] )/n,
                            mu[2] - ( (m1+df)*u[2] )/n );
    DGtal::Z3i::RealPoint rpf = display.embed( pf );
    PointD3d pl = PointD3d( mu[0] - ( (m1+dl)*u[0] )/n,
                            mu[1] - ( (m1+dl)*u[1] )/n,
                            mu[2] - ( (m1+dl)*u[2] )/n );
    DGtal::Z3i::RealPoint rpl = display.embed( pl );

    display.addLine(rpf, rpl);

    PointD3d pf2 = PointD3d((mu[0]+omega1[0]) - ( (m2+df)*u[0] )/n,
                            (mu[1]+omega1[1]) - ( (m2+df)*u[1] )/n,
                            (mu[2]+omega1[2]) - ( (m2+df)*u[2] )/n );
    DGtal::Z3i::RealPoint rpf2 = display.embed( pf2 );
    PointD3d pl2 = PointD3d((mu[0]+omega1[0]) - ( (m2+dl)*u[0] )/n,
                            (mu[1]+omega1[1]) - ( (m2+dl)*u[1] )/n,
                            (mu[2]+omega1[2]) - ( (m2+dl)*u[2] )/n );
    DGtal::Z3i::RealPoint rpl2 = display.embed( pl2 );

    display.addLine(rpf2, rpl2);

    PointD3d pf3 = PointD3d((mu[0]+omega2[0]) - ( (m3+df)*u[0] )/n,
                            (mu[1]+omega2[1]) - ( (m3+df)*u[1] )/n,
                            (mu[2]+omega2[2]) - ( (m3+df)*u[2] )/n );
    DGtal::Z3i::RealPoint rpf3 = display.embed( pf3 );
    PointD3d pl3 = PointD3d((mu[0]+omega2[0]) - ( (m3+dl)*u[0] )/n,
                            (mu[1]+omega2[1]) - ( (m3+dl)*u[1] )/n,
                            (mu[2]+omega2[2]) - ( (m3+dl)*u[2] )/n );
    DGtal::Z3i::RealPoint rpl3 = display.embed( pl3 );

    display.addLine(rpf3, rpl3);

    PointD3d pf4 = PointD3d((mu[0]+omega[0]) - ( (m4+df)*u[0] )/n,
                            (mu[1]+omega[1]) - ( (m4+df)*u[1] )/n,
                            (mu[2]+omega[2]) - ( (m4+df)*u[2] )/n );
    DGtal::Z3i::RealPoint rpf4 = display.embed( pf4 );
    PointD3d pl4 = PointD3d((mu[0]+omega[0]) - ( (m4+dl)*u[0] )/n,
                            (mu[1]+omega[1]) - ( (m4+dl)*u[1] )/n,
                            (mu[2]+omega[2]) - ( (m4+dl)*u[2] )/n );
    DGtal::Z3i::RealPoint rpl4 = display.embed( pl4 );

    display.addLine(rpf4, rpl4);

    //two end facets
    display.addQuad(rpf,rpf2,rpf4, rpf3);
    display.addQuad(rpl, rpl2, rpl4,rpl3);
  }
}

template <typename Space, typename KSpace>
template <typename TIterator, typename TInteger, int connectivity>
inline
void DGtal::Display3DFactory<Space,KSpace>::draw( Display3D<Space, KSpace> & display,
						  const DGtal::StandardDSS6Computer<TIterator,TInteger,connectivity> & a )
{
  std::string mode = display.getMode( a.className() );
  if ( mode == "BoundingBox" )
    drawAsBoundingBox( display, a );
  else if ( mode == "Points" )
    drawAsBalls( display, a );
  else if ( ( mode == "" ) )
    {
      drawAsBalls( display, a );
    }
}
// StandardDSS6Computer


// DigitalSetBySTLSet
template <typename Space, typename KSpace>
template<typename Domain, typename Compare>
inline
void DGtal::Display3DFactory<Space,KSpace>::drawAsPavingTransparent( Display3D<Space, KSpace> & display,
								     const DGtal::DigitalSetBySTLSet<Domain, Compare> & s )
{
  typedef typename Domain::Point Point;
  typedef typename std::set<Point>::const_iterator ConstIterator;

  ASSERT(Domain::Space::dimension == 3);

  display.createNewCubeList( s.className());
  for ( ConstIterator it = s.begin();
        it != s.end();
        ++it )
    {
      DGtal::Z3i::RealPoint rp = display.embed((*it) );
      display.addCube(rp);
    }
}

template <typename Space, typename KSpace>
template<typename Domain, typename Compare>
inline
void DGtal::Display3DFactory<Space,KSpace>::drawAsPaving( Display3D<Space, KSpace> & display,
							  const DGtal::DigitalSetBySTLSet<Domain, Compare> & s )
{
  typedef typename Domain::Point Point;
  typedef typename std::set<Point>::const_iterator ConstIterator;

  ASSERT(Domain::Space::dimension == 3);

  display.createNewCubeList( s.className());
  for ( ConstIterator it = s.begin();
        it != s.end();
        ++it )
    {
      DGtal::Z3i::RealPoint rp = display.embed((*it) );
      display.addCube(rp);
    }
}

template <typename Space, typename KSpace>
template<typename Domain, typename Compare>
inline
void DGtal::Display3DFactory<Space,KSpace>::drawAsGrid( Display3D<Space, KSpace> & display,
							const DGtal::DigitalSetBySTLSet<Domain, Compare> & s )
{
  typedef typename Domain::Point Point;
  typedef typename std::set<Point>::const_iterator ConstIterator;

  ASSERT(Domain::Space::dimension == 3);

  for ( ConstIterator it = s.begin();
        it != s.end();
        ++it )
    {
      DGtal::Z3i::RealPoint rp = display.embed((*it) );
      display.addBall(rp);
    }
}

template <typename Space, typename KSpace>
template<typename Domain, typename Compare>
inline
void DGtal::Display3DFactory<Space,KSpace>::draw( Display3D<Space, KSpace> & display,
						  const DGtal::DigitalSetBySTLSet<Domain, Compare> & s )
{
  ASSERT(Domain::Space::dimension == 3);

  std::string mode = display.getMode( s.className() );
  ASSERT( (mode=="Paving" || mode=="PavingTransp" || mode=="Grid" || mode=="Both" || mode=="") );

  if ( mode == "Paving" || ( mode == "" ) )
    drawAsPaving( display, s );
  else if ( mode == "PavingTransp" )
    drawAsPavingTransparent( display, s );
  else if ( mode == "Grid" )
    drawAsGrid( display, s );
  else if ( ( mode == "Both" ) )
    {
      drawAsPaving( display, s );
      drawAsGrid( display, s );
    }
}
// DigitalSetBySTLSet


// DigitalSetBySTLVector
template <typename Space, typename KSpace>
template<typename Domain>
inline
void DGtal::Display3DFactory<Space,KSpace>::drawAsPavingTransparent( Display3D<Space, KSpace> & display,
								     const DGtal::DigitalSetBySTLVector<Domain> & v )
{
  typedef typename Domain::Point Point;
  typedef typename std::vector<Point>::const_iterator ConstIterator;

  ASSERT(Domain::Space::dimension == 3);

  display.createNewCubeList( v.className());
  for ( ConstIterator it = v.begin();
        it != v.end();
        ++it )
    {
      DGtal::Z3i::RealPoint rp = display.embed((*it) );
      display.addCube(rp);
    }
}

template <typename Space, typename KSpace>
template<typename Domain>
inline
void DGtal::Display3DFactory<Space,KSpace>::drawAsPaving( Display3D<Space, KSpace> & display,
							  const DGtal::DigitalSetBySTLVector<Domain> & v )
{
  typedef typename Domain::Point Point;
  typedef typename std::vector<Point>::const_iterator ConstIterator;

  ASSERT(Domain::Space::dimension == 3);

  display.createNewCubeList( v.className());
  for ( ConstIterator it = v.begin();
        it != v.end();
        ++it )
    {
      DGtal::Z3i::RealPoint rp = display.embed((*it) );
      display.addCube(rp);
    }
}

template <typename Space, typename KSpace>
template<typename Domain>
inline
void DGtal::Display3DFactory<Space,KSpace>::drawAsGrid( Display3D<Space, KSpace> & display,
							const DGtal::DigitalSetBySTLVector<Domain> & v )
{
  typedef typename Domain::Point Point;
  typedef typename std::vector<Point>::const_iterator ConstIterator;

  ASSERT(Domain::Space::dimension == 3);

  for ( ConstIterator it = v.begin();
        it != v.end();
        ++it )
    {
      DGtal::Z3i::RealPoint rp = display.embed((*it) );
      display.addBall(rp);
    }
}

template <typename Space, typename KSpace>
template<typename Domain>
inline
void DGtal::Display3DFactory<Space,KSpace>::draw( Display3D<Space, KSpace> & display,
						  const DGtal::DigitalSetBySTLVector<Domain> & v )
{
  ASSERT(Domain::Space::dimension == 3);

  std::string mode = display.getMode( v.className() );
  ASSERT( (mode=="Paving" || mode=="PavingTransp" || mode=="Grid" || mode=="Both" || mode=="") );

  if ( mode == "Paving" || ( mode == "" ) )
    drawAsPaving( display, v );
  else if ( mode == "PavingTransp" )
    drawAsPavingTransparent( display, v );
  else if ( mode == "Grid" )
    drawAsGrid( display, v );
  else if ( ( mode == "Both" ) )
    {
      drawAsPaving( display, v);
      drawAsGrid( display, v );
    }
}
// DigitalSetBySTLVector


// HyperRectDomain
template <typename Space, typename KSpace>
template <typename SpaceDom>
inline
void DGtal::Display3DFactory<Space,KSpace>::drawAsBoundingBox( Display3D<Space, KSpace> & display,
							       const DGtal::HyperRectDomain<SpaceDom> & h )
{
  DGtal::Color fillColorSave = display.getFillColor();
  ASSERT(Space::dimension == 2 || Space::dimension == 3 || "drawAsBoundingBox-NOT-YET-IMPLEMENTED-in-ND");

  DGtal::Z3i::RealPoint upperBound;
  DGtal::Z3i::RealPoint lowerBound;

  if (SpaceDom::dimension == 3)
    {
      upperBound = display.embed( DGtal::Z3i::Point(h.myUpperBound[0], h.myUpperBound[1], h.myUpperBound[2]));
      lowerBound = display.embed( DGtal::Z3i::Point(h.myLowerBound[0], h.myLowerBound[1], h.myLowerBound[2]));
    }
  if (SpaceDom::dimension == 2)
    {
      upperBound = display.embed( DGtal::Z3i::Point(h.myUpperBound[0], h.myUpperBound[1], 0));
      lowerBound = display.embed( DGtal::Z3i::Point(h.myLowerBound[0], h.myLowerBound[1], 0));
    }


  display.setFillColor(DGtal::Color(250,250,250,10));
  double shiftSize=0.01;
  if (SpaceDom::dimension == 3)
    {
      //Z upper face
      display.addQuad(DGtal::Z3i::RealPoint(upperBound[0]+(0.5+shiftSize),
					    upperBound[1]+(0.5+shiftSize),
					    upperBound[2]+(0.5+shiftSize)),
                      DGtal::Z3i::RealPoint(lowerBound[0]-(0.5+shiftSize),
					    upperBound[1]+(0.5+shiftSize),
					    upperBound[2]+(0.5+shiftSize)),
                      DGtal::Z3i::RealPoint(lowerBound[0]-(0.5+shiftSize),
					    lowerBound[1]-(0.5+shiftSize),
					    upperBound[2]+(0.5+shiftSize)),
                      DGtal::Z3i::RealPoint(upperBound[0]+(0.5+shiftSize),
					    lowerBound[1]-(0.5+shiftSize),
					    upperBound[2]+(0.5+shiftSize)));
      //Z lower face
      display.addQuad(DGtal::Z3i::RealPoint(upperBound[0]+(0.5+shiftSize),
					    upperBound[1]+(0.5+shiftSize),
					    lowerBound[2]-(0.5+shiftSize)),
                      DGtal::Z3i::RealPoint(upperBound[0]+(0.5+shiftSize),
					    lowerBound[1]-(0.5+shiftSize),
					    lowerBound[2]-(0.5+shiftSize)),
                      DGtal::Z3i::RealPoint(lowerBound[0]-(0.5+shiftSize),
					    lowerBound[1]-(0.5+shiftSize),
					    lowerBound[2]-(0.5+shiftSize)),
                      DGtal::Z3i::RealPoint(lowerBound[0]-(0.5+shiftSize),
					    upperBound[1]+(0.5+shiftSize),
					    lowerBound[2]-(0.5+shiftSize)));
      //Y upper face
      display.addQuad(DGtal::Z3i::RealPoint(upperBound[0]+(0.5+shiftSize),
					    upperBound[1]+(0.5+shiftSize),
					    upperBound[2]+(0.5+shiftSize)),
                      DGtal::Z3i::RealPoint(upperBound[0]+(0.5+shiftSize),
					    upperBound[1]+(0.5+shiftSize),
					    lowerBound[2]-(0.5+shiftSize)),
                      DGtal::Z3i::RealPoint(lowerBound[0]-(0.5+shiftSize),
					    upperBound[1]+(0.5+shiftSize),
					    lowerBound[2]-(0.5+shiftSize)),
                      DGtal::Z3i::RealPoint(lowerBound[0]-(0.5+shiftSize),
					    upperBound[1]+(0.5+shiftSize),
					    upperBound[2]+(0.5+shiftSize)));
      //Y lower face
      display.addQuad(DGtal::Z3i::RealPoint(upperBound[0]+(0.5+shiftSize),
					    lowerBound[1]-(0.5+shiftSize),
					    upperBound[2]+(0.5+shiftSize)),
                      DGtal::Z3i::RealPoint(lowerBound[0]-(0.5+shiftSize),
					    lowerBound[1]-(0.5+shiftSize),
					    upperBound[2]+(0.5+shiftSize)),
                      DGtal::Z3i::RealPoint(lowerBound[0]-(0.5+shiftSize),
					    lowerBound[1]-(0.5+shiftSize),
					    lowerBound[2]-(0.5+shiftSize)),
                      DGtal::Z3i::RealPoint(upperBound[0]+(0.5+shiftSize),
					    lowerBound[1]-(0.5+shiftSize),
					    lowerBound[2]-(0.5+shiftSize)));
      // X upper face
      display.addQuad(DGtal::Z3i::RealPoint(upperBound[0]+(0.5+shiftSize),
					    upperBound[1]+(0.5+shiftSize),
					    upperBound[2]+(0.5+shiftSize)),
                      DGtal::Z3i::RealPoint(upperBound[0]+(0.5+shiftSize),
					    lowerBound[1]-(0.5+shiftSize),
					    upperBound[2]+(0.5+shiftSize)),
                      DGtal::Z3i::RealPoint(upperBound[0]+(0.5+shiftSize),
					    lowerBound[1]-(0.5+shiftSize),
					    lowerBound[2]-(0.5+shiftSize)),
                      DGtal::Z3i::RealPoint(upperBound[0]+(0.5+shiftSize),
					    upperBound[1]+(0.5+shiftSize),
					    lowerBound[2]-(0.5+shiftSize)));
      // X lower face
      display.addQuad(DGtal::Z3i::RealPoint(lowerBound[0]-(0.5+shiftSize),
					    upperBound[1]+(0.5+shiftSize),
					    upperBound[2]+(0.5+shiftSize)),
                      DGtal::Z3i::RealPoint(lowerBound[0]-(0.5+shiftSize),
					    upperBound[1]+(0.5+shiftSize),
					    lowerBound[2]-(0.5+shiftSize)),
                      DGtal::Z3i::RealPoint(lowerBound[0]-(0.5+shiftSize),
					    lowerBound[1]-(0.5+shiftSize),
					    lowerBound[2]-(0.5+shiftSize)),
                      DGtal::Z3i::RealPoint(lowerBound[0]-(0.5+shiftSize),
					    lowerBound[1]-(0.5+shiftSize),
					    upperBound[2]+(0.5+shiftSize)));
    }
  display.setFillColor( fillColorSave);
}

template <typename Space, typename KSpace>
template <typename SpaceDom>
inline
void DGtal::Display3DFactory<Space,KSpace>::drawAsGrid( Display3D<Space, KSpace> & display,
							const DGtal::HyperRectDomain<SpaceDom> & h )
{
  typedef typename Space::Integer Integer;

  ASSERT(Space::dimension == 3 || "drawAsGrid-NOT-YET-IMPLEMENTED-in-ND");

  if (Space::dimension == 3)
    {
      // Face XY
      for (int64_t z = NumberTraits<Integer>::castToInt64_t(h.myLowerBound[2]);
           z <= NumberTraits<Integer>::castToInt64_t(h.myUpperBound[2]); z++)
        {
          for (int64_t x = NumberTraits<Integer>::castToInt64_t(h.myLowerBound[0]);
               x <= NumberTraits<Integer>::castToInt64_t(h.myUpperBound[0]); x++)
            {
              DGtal::Z3i::RealPoint rp1 = display.embed( DGtal::Z3i::Point(x, h.myLowerBound[1], z) );
              DGtal::Z3i::RealPoint rp2 = display.embed( DGtal::Z3i::Point(x, h.myUpperBound[1], z) );

              display.addLine( rp1, rp2);
            }
          for (int64_t y = NumberTraits<Integer>::castToInt64_t(h.myLowerBound[1]);
               y <= NumberTraits<Integer>::castToInt64_t(h.myUpperBound[1]); y++)
            {
              DGtal::Z3i::RealPoint rp1 = display.embed( DGtal::Z3i::Point(h.myLowerBound[0], y, z) );
              DGtal::Z3i::RealPoint rp2 = display.embed( DGtal::Z3i::Point(h.myUpperBound[0], y, z) );

              display.addLine( rp1, rp2 );
            }
        }

      // Faces XZ
      for (int64_t y = NumberTraits<Integer>::castToInt64_t(h.myLowerBound[1]);
           y <= NumberTraits<Integer>::castToInt64_t(h.myUpperBound[1]); y++)
        {
          for (int64_t x = NumberTraits<Integer>::castToInt64_t(h.myLowerBound[0]);
               x <= NumberTraits<Integer>::castToInt64_t(h.myUpperBound[0]); x++)
            {
              DGtal::Z3i::RealPoint rp1 = display.embed( DGtal::Z3i::Point(x, y, h.myLowerBound[2]) );
              DGtal::Z3i::RealPoint rp2 = display.embed( DGtal::Z3i::Point(x, y, h.myLowerBound[2]) );

              display.addLine( rp1, rp2);
            }
          for (int64_t z = NumberTraits<Integer>::castToInt64_t(h.myLowerBound[2]);
               z <= NumberTraits<Integer>::castToInt64_t(h.myUpperBound[2]); z++)
            {
              DGtal::Z3i::RealPoint rp1 = display.embed( DGtal::Z3i::Point(h.myLowerBound[0], y, z) );
              DGtal::Z3i::RealPoint rp2 = display.embed( DGtal::Z3i::Point(h.myUpperBound[0], y, z) );

              display.addLine( rp1, rp2);
            }
        }

      // Faces YZ
      for (int64_t x = NumberTraits<Integer>::castToInt64_t(h.myLowerBound[0]);
           x <= NumberTraits<Integer>::castToInt64_t(h.myUpperBound[0]); x++)
        {
          for (int64_t y = NumberTraits<Integer>::castToInt64_t(h.myLowerBound[1]);
               y <= NumberTraits<Integer>::castToInt64_t(h.myUpperBound[1]); y++)
            {
              DGtal::Z3i::RealPoint rp1 = display.embed( DGtal::Z3i::Point(x, y, h.myLowerBound[2]) );
              DGtal::Z3i::RealPoint rp2 = display.embed( DGtal::Z3i::Point(x, y, h.myUpperBound[2]) );

              display.addLine( rp1, rp2);
            }
          for (int64_t z = NumberTraits<Integer>::castToInt64_t(h.myLowerBound[2]);
               z <= NumberTraits<Integer>::castToInt64_t(h.myUpperBound[2]); z++)
            {
              DGtal::Z3i::RealPoint rp1 = display.embed( DGtal::Z3i::Point(x, h.myLowerBound[1], z) );
              DGtal::Z3i::RealPoint rp2 = display.embed( DGtal::Z3i::Point(x, h.myLowerBound[1], z) );

              display.addLine( rp1, rp2);
            }
        }
    }
}

template <typename Space, typename KSpace>
template <typename SpaceDom>
inline
void DGtal::Display3DFactory<Space,KSpace>::drawAsPavingBalls( Display3D<Space, KSpace> & display,
							       const DGtal::HyperRectDomain<SpaceDom> & h )
{
  DGtal::Color fillColorSave = display.getFillColor();
  typedef typename Space::Integer Integer;

  ASSERT(Space::dimension == 3 || "drawAsPavingPoints-NOT-YET-IMPLEMENTED-in-ND");
  if (Space::dimension == 3)
    {
      // Face XY
      for (int64_t z = NumberTraits<Integer>::castToInt64_t(h.myLowerBound[2]);
           z <= NumberTraits<Integer>::castToInt64_t(h.myUpperBound[2]); z++)
        {
          for (int64_t x = NumberTraits<Integer>::castToInt64_t(h.myLowerBound[0]);
               x <= NumberTraits<Integer>::castToInt64_t(h.myUpperBound[0]); x++)
            {

              for (int64_t y = NumberTraits<Integer>::castToInt64_t(h.myLowerBound[1]);
                   y <= NumberTraits<Integer>::castToInt64_t(h.myUpperBound[1]); y++)
                {
                  DGtal::Z3i::RealPoint rp = display.embed( DGtal::Z3i::Point(x, y, z) );
                  display.setFillColor(DGtal::Color(255, 0 ,0));
                  display.addBall(rp);
                }
            }
        }
    }
  display.setFillColor(fillColorSave);
}

template <typename Space, typename KSpace>
template <typename SpaceDom>
inline
void DGtal::Display3DFactory<Space,KSpace>::drawAsPaving( Display3D<Space, KSpace> & display,
							  const DGtal::HyperRectDomain<SpaceDom> & h )
{
  DGtal::Color fillColorSave = display.getFillColor();
  typedef typename Space::Integer Integer;

  ASSERT(Space::dimension == 3 || "drawAsPaving-NOT-YET-IMPLEMENTED-in-ND");

  if (Space::dimension == 3)
    {
      // Face XY
      for (int64_t z = NumberTraits<Integer>::castToInt64_t(h.myLowerBound[2]);
           z <= NumberTraits<Integer>::castToInt64_t(h.myUpperBound[2]); z++)
        {
          for (int64_t x = NumberTraits<Integer>::castToInt64_t(h.myLowerBound[0]);
               x <= NumberTraits<Integer>::castToInt64_t(h.myUpperBound[0]); x++)
            {
              for (int64_t y = NumberTraits<Integer>::castToInt64_t(h.myLowerBound[1]);
                   y <= NumberTraits<Integer>::castToInt64_t(h.myUpperBound[1]); y++)
                {
                  DGtal::Z3i::RealPoint rp = display.embed( DGtal::Z3i::Point(x, y, z) );
                  rp[0]+=0.5;
                  rp[1]+=0.5;
                  rp[2]+=0.5;
                  //a transparent color for the paving
                  display.setFillColor( Color(255, 255 ,255, 15));
                  display.addCube(rp, 1.0);
                }
            }
        }
    }
  display.setFillColor(fillColorSave);
}


template <typename Space, typename KSpace>
template <typename SpaceDom>
inline
void
DGtal::Display3DFactory<Space,KSpace>::draw( Display3D<Space, KSpace> & display, const DGtal::HyperRectDomain<SpaceDom> & aDomain )
{
  std::string mode = display.getMode( aDomain.className() );

  ASSERT((mode=="" || mode=="Grid" || mode=="Paving"|| mode=="PavingPoints"|| mode=="PavingGrids" ||
          mode=="BoundingBox")||
         ("DGtal::Display3DFactory<Space,KSpace>::draw( Display3DD<Space, KSpace> & display, const DGtal::HyperRectDomain<Space> & aDomain ): Unknown mode "+mode)=="");

  /*
    if ( mode == "BoundingBox" )
    {
    display.createNewLineList(aDomain.className());
    drawAsBoundingBox( display, aDomain );
    }else if( ( mode == "" ) || (mode == "Grid"))
    {
    display.createNewLineList(aDomain.className());
    drawAsGrid( display, aDomain );
    }
    else if ( mode == "Paving" )
    {
    display.createNewCubeList( aDomain.className());
    }
  */

  ASSERT((Space::dimension==3)|| (Space::dimension==2));
  ASSERT((Space::dimension!=3) || (mode=="" || mode=="Grid" || mode=="Paving"|| mode=="PavingPoints"|| mode=="PavingGrids" ||
				   mode=="BoundingBox")||
         ("DGtal::Display3DFactory<Space,KSpace>::draw( Display3D<Space, KSpace> & display, const DGtal::HyperRectDomain<Space> & aDomain ): Unknown mode "+mode)=="");
  ASSERT((Space::dimension!=2) || (mode=="" || mode=="BoundingBox" || mode=="Grid") ||
         ("DGtal::Display3DFactory<Space,KSpace>::draw( Display3D<Space, KSpace> & display, const DGtal::HyperRectDomain<Space> & aDomain ): Unknown mode "+mode)=="");

  if(Space::dimension == 2)
    {
      if (mode=="")
        mode="BoundingBox";
    }else if ( mode == "BoundingBox" )
    {
      display.createNewLineList(aDomain.className());
      drawAsBoundingBox( display, aDomain );
    }else if(( mode == "" ) || (mode == "Grid"))
    {
      display.createNewLineList(aDomain.className());
      drawAsGrid( display, aDomain );
    } else if ( mode == "Paving" )
    {
      display.createNewCubeList(aDomain.className());
      drawAsPaving( display, aDomain );
    } else if ( mode == "PavingPoints" )
    {
      display.createNewBallList(aDomain.className());
      drawAsPavingBalls( display, aDomain );
    }else if ( mode == "PavingGrids" )
    {
      display.createNewLineList(aDomain.className());
      display.createNewCubeList( aDomain.className());
      drawAsGrid( display, aDomain );
      drawAsPaving( display, aDomain );
    }
}
// HyperRectDomain


// KhalimskyCell
template <typename Space, typename KSpace>
inline
void DGtal::Display3DFactory<Space,KSpace>::draw( Display3D<Space, KSpace> & display,
                                                  const typename KSpace::Cell & k )
{
  ASSERT(Space::dimension == 3);
  DGtal::Color fillColorSave = display.getFillColor();
  std::string mode = display.getMode( k.className() );
  ASSERT((mode=="" || mode=="Highlighted" || mode=="Transparent"|| mode=="Basic"|| mode=="Illustration"||mode=="IllustrationCustomColor")||
         ("DGtal::Display3DFactory<Space,KSpace>::draw( Display3D<Space, KSpace> & display, const DGtal::KhalimskyCell<dim, TInteger> & k ): Unknown mode "+mode)=="");
  // used to display surfels located at a same position.
  double factorVolSurfel=1.0;
  if(mode=="Highlighted")
    {
      factorVolSurfel = 1.1;
      display.setFillColor(DGtal::Color(255, 50, 50, 255));
    }else if(mode=="Transparent")
    {
      display.setFillColor(DGtal::Color(180, 180, 250, 25));
    }

  DGtal::Z3i::RealPoint rp = display.embedK( k );
  bool xodd = ( NumberTraits<typename KSpace::Integer>::castToInt64_t(k.myCoordinates[ 0 ]) & 1 );
  bool yodd = ( NumberTraits<typename KSpace::Integer>::castToInt64_t(k.myCoordinates[ 1 ]) & 1 );
  bool zodd = ( NumberTraits<typename KSpace::Integer>::castToInt64_t(k.myCoordinates[ 2 ]) & 1 );
  unsigned int spaceDim= (xodd ? 1:0) + (yodd ? 1:0) + (zodd ? 1:0);

  switch (spaceDim) {
  case 0:

    if(mode!="" && mode!="Basic" && mode!="IllustrationCustomColor")
      {
        display.setFillColor(DGtal::Color(200, 200, 20, 255));
      }

    display.addBall(rp, 0.05);
    break;
  case 1:
    if(mode!=""&& mode!="Basic" && mode!="IllustrationCustomColor")
      {
        display.setFillColor(DGtal::Color(255, 255, 50, 255));
      }


    display.addCylinder(DGtal::Z3i::RealPoint(rp[0]- (xodd? 0.5:0 ), rp[1]- (yodd? 0.5:0 ), rp[2]- (zodd? 0.5:0 )),
			DGtal::Z3i::RealPoint(rp[0]+ (xodd? 0.5:0 ), rp[1]+ (yodd? 0.5:0 ), rp[2]+ (zodd? 0.5:0 )));
    break;
  case 2:
    if(mode!="" && mode!="Basic" && mode!="IllustrationCustomColor")
      {
        display.setFillColor(DGtal::Color(20, 200, 200, 255));
      }
    if(mode=="Basic")
      {
        display.addQuadFromSurfelCenter(DGtal::Z3i::RealPoint(rp[0]+(xodd? 0:0.5 ), rp[1]+(yodd? 0:0.5 ), rp[2]+(zodd? 0:0.5 )),
                                        ! xodd, !yodd, !zodd);
      }
    else
      display.addPrism(DGtal::Z3i::RealPoint(rp[0]+(xodd? 0:0.5 ), rp[1]+(yodd? 0:0.5 ), rp[2]+(zodd? 0:0.5 )),
                             ! xodd, !yodd, !zodd, factorVolSurfel,1.0, false, false);
    break;
  case 3:
    if(mode!="" && mode!="Basic" && mode!="IllustrationCustomColor")
      {
        display.setFillColor(DGtal::Color(255, 180, 250, 255));
      }
    if(mode=="Illustration"|| mode=="IllustrationCustomColor")
      {
        display.createNewCubeList("khalimsky cell");
        display.addCube(rp,0.80);
      }else{
      display.createNewCubeList("khalimsky cell");
      display.addCube(rp,0.90);
    }
    break;
  }
  display.setFillColor(fillColorSave);
}
// KhalimskyCell


// SignedKhalimskyCell
template <typename Space, typename KSpace>
inline
void DGtal::Display3DFactory<Space,KSpace>::draw( Display3D<Space, KSpace> & display,
                                                  const typename KSpace::SCell & sk )
{

  ASSERT(Space::dimension == 3);
  DGtal::Color fillColorSave = display.getFillColor();
  std::string mode = display.getMode( sk.className() );
  ASSERT((mode=="" || mode=="Highlighted" || mode=="Transparent" || mode=="Basic" || mode=="Illustration" || mode=="IllustrationCustomColor")||
         ("DGtal::Display3DFactory<Space,KSpace>::draw( Display3D<Space, KSpace> & display, const DGtal::SignedKhalimskyCell<dim, TInteger> & sk ): Unknown mode "+mode)=="");
  // used to display surfels located at a same position.
  double factorVolSurfel=1.0;
  if(mode=="Highlighted")
    {
      factorVolSurfel = 1.2;
      display.setFillColor(DGtal::Color(255, 50, 50, 255));
    }else if(mode=="Transparent")
    {
      display.setFillColor(DGtal::Color(180, 180, 250, 25));
    }

  DGtal::Z3i::RealPoint rps = display.embedKS( sk );
  bool xodd = ( sk.myCoordinates[ 0 ] & 1 );
  bool yodd = ( sk.myCoordinates[ 1 ] & 1 );
  bool zodd = ( sk.myCoordinates[ 2 ] & 1 );
  unsigned int spaceDim= (xodd ? 1:0) + (yodd ? 1:0) + (zodd ? 1:0);
  // pointel

  switch (spaceDim)
    {
    case 0:
      if(mode!="" && mode!="Basic" && mode!="IllustrationCustomColor")
        {
          if( sk.myPositive)
            display.setFillColor(DGtal::Color(20, 20, 250, 255));
          else
            display.setFillColor(DGtal::Color(20, 20, 150, 255));
        }
      display.addBall(rps, 0.05);
      break;
    case 1:
      if(mode!="" && mode!="Basic" && mode!="IllustrationCustomColor")
        {
          display.setFillColor(  DGtal::Color(255, 50, 50, 255));
        }
      if (sk.myPositive)
        {
          display.addCone(DGtal::Z3i::RealPoint(rps[0]- (xodd? 0.5:0 ), rps[1]- (yodd? 0.5:0 ), rps[2]- (zodd? 0.5:0 )),
			  DGtal::Z3i::RealPoint(rps[0]+ (xodd? 0.5:0 ), rps[1]+ (yodd? 0.5:0 ), rps[2]+ (zodd? 0.5:0 )));
        }
      else
        {
          display.addCone(DGtal::Z3i::RealPoint(rps[0]+ (xodd? 0.5:0 ), rps[1]+ (yodd? 0.5:0 ), rps[2]+ (zodd? 0.5:0 )),
			  DGtal::Z3i::RealPoint(rps[0]- (xodd? 0.5:0 ),rps[1]- (yodd? 0.5:0 ), rps[2]- (zodd? 0.5:0 )));
        }
      break;
    case 2:
      if(mode=="Basic")
        {
          display.addQuadFromSurfelCenter(DGtal::Z3i::RealPoint(rps[0]+(xodd? 0:0.5 ), rps[1]+(yodd? 0:0.5 ), rps[2]+(zodd? 0:0.5 )),
                                          ! xodd, !yodd, !zodd );          
        }else
        display.addPrism(DGtal::Z3i::RealPoint(rps[0]+(xodd? 0:0.5 ), rps[1]+(yodd? 0:0.5 ), rps[2]+(zodd? 0:0.5 )),
                               ! xodd, !yodd, !zodd, factorVolSurfel,1.0, true, sk.myPositive );
      break;
    case 3:
      if(mode!="" && mode!="IllustrationCustomColor")
        {
          if( sk.myPositive)
            {
              display.setFillColor(DGtal::Color(200, 20, 20, 255));
            }else
            {
              display.setFillColor(DGtal::Color(20, 200, 20, 255));
            }
        }
      if(mode=="Illustration"|| mode=="IllustrationCustomColor")
        {
          //KSCube
          display.createNewCubeList("signed khalimsky cell");
          display.addCube(rps, 0.80);
        }else
        {
          display.createNewCubeList("signed khalimsky cell");
          display.addCube(rps, 0.90 );
        }
      break;
    }
  display.setFillColor(fillColorSave);
}
// SignedKhalimskyCell



// Object
template <typename Space, typename KSpace>
template <typename TDigitalTopology, typename TDigitalSet>
inline
void DGtal::Display3DFactory<Space,KSpace>::drawWithAdjacencies( Display3D<Space, KSpace> & display,
								 const DGtal::Object<TDigitalTopology, TDigitalSet> & o )
{
  typedef typename TDigitalSet::Point Point;

  typedef typename TDigitalSet::Domain Domain;
  typedef
    typename DigitalSetSelector < Domain,
                                  SMALL_DS + HIGH_ITER_DS >::Type SmallSet;
  typedef Object<TDigitalTopology, SmallSet> SmallObject;

  Point p;
  for (typename TDigitalSet::ConstIterator it = o.pointSet().begin();
       it != o.pointSet().end();
       ++it)
    {
      //Brute-force scan of the neighborhood.
      SmallObject neig = o.properNeighborhood(*it);
      for (typename SmallObject::DigitalSet::ConstIterator it2 = neig.pointSet().begin();
           it2 != neig.pointSet().end();
           ++it2)
        {
          p = (*it2) - (*it);
          draw(display, p, (*it));
        }
    }
}

template <typename Space, typename KSpace>
template <typename TDigitalTopology, typename TDigitalSet>
inline
void DGtal::Display3DFactory<Space,KSpace>::draw( Display3D<Space, KSpace> & display,
						  const DGtal::Object<TDigitalTopology, TDigitalSet> & o )
{
  std::string mode = display.getMode( o.className() );
  if ( mode == "Basic" || mode == "" )
    draw( display, o.pointSet() );
  else if ( mode == "PavingTransp" )
    {
      drawAsPavingTransparent( display, o.pointSet() );

    }
  else if ( mode == "DrawAdjacencies" )
    {
      draw( display, o.pointSet() );
      drawWithAdjacencies( display, o );
    }
  else
    ASSERT(false && (("DGtal::Display3DFactory<Space,KSpace>::draw( Display3D<Space, KSpace> & display, const DGtal::Object<TDigitalTopology, TDigitalSet> & o ): Unknown mode " + mode) == ""));
}
// Object


// PointVector
template <typename Space, typename KSpace>
template<DGtal::Dimension dim, typename TComponent>
inline
void DGtal::Display3DFactory<Space,KSpace>::drawAsGrid( Display3D<Space, KSpace> & display,
							const DGtal::PointVector<dim,TComponent> & p )
{
  DGtal::Color fillColorSave = display.getFillColor();
  ASSERT(dim == 3);
  DGtal::Z3i::RealPoint rp = display.embed( p );
  display.setFillColor(display.getLineColor());
  display.addBall( rp);
  display.setFillColor(fillColorSave);
}

template <typename Space, typename KSpace>
template<DGtal::Dimension dim, typename TComponent>
inline
void DGtal::Display3DFactory<Space,KSpace>::drawAsPaving( Display3D<Space, KSpace> & display,
							  const DGtal::PointVector<dim,TComponent> & p )
{
  ASSERT(dim == 3);

  DGtal::Z3i::RealPoint rp = display.embed( p );
  display.addCube(rp);
}

template <typename Space, typename KSpace>
template<DGtal::Dimension dim, typename TComponent>
inline
void DGtal::Display3DFactory<Space,KSpace>::drawAsPavingWired( Display3D<Space, KSpace> & display,
							       const DGtal::PointVector<dim,TComponent> & p )
{
  DGtal::Color lineColorSave = display.getLineColor();
  ASSERT(dim == 3);

  DGtal::Z3i::RealPoint rp = display.embed( p );
  display.addCube(rp);
  display.setLineColor(DGtal::Color(0,0,0));
  display.addLine(DGtal::Z3i::RealPoint(rp[0]-0.5, rp[1]-0.5, rp[2]-0.5),
		  DGtal::Z3i::RealPoint(rp[0]+0.5, rp[1]-0.5, rp[2]-0.5));
  display.addLine(DGtal::Z3i::RealPoint(rp[0]+0.5, rp[1]-0.5, rp[2]-0.5),
		  DGtal::Z3i::RealPoint(rp[0]+0.5, rp[1]+0.5, rp[2]-0.5));
  display.addLine(DGtal::Z3i::RealPoint(rp[0]+0.5, rp[1]+0.5, rp[2]-0.5),
		  DGtal::Z3i::RealPoint(rp[0]-0.5, rp[1]+0.5, rp[2]-0.5));
  display.addLine(DGtal::Z3i::RealPoint(rp[0]-0.5, rp[1]+0.5, rp[2]-0.5),
		  DGtal::Z3i::RealPoint(rp[0]-0.5, rp[1]-0.5, rp[2]-0.5));

  display.addLine(DGtal::Z3i::RealPoint(rp[0]-0.5, rp[1]-0.5, rp[2]+0.5),
		  DGtal::Z3i::RealPoint(rp[0]+0.5, rp[1]-0.5, rp[2]+0.5));
  display.addLine(DGtal::Z3i::RealPoint(rp[0]+0.5, rp[1]-0.5, rp[2]+0.5),
		  DGtal::Z3i::RealPoint(rp[0]+0.5, rp[1]+0.5, rp[2]+0.5));
  display.addLine(DGtal::Z3i::RealPoint(rp[0]+0.5, rp[1]+0.5, rp[2]+0.5),
		  DGtal::Z3i::RealPoint(rp[0]-0.5, rp[1]+0.5, rp[2]+0.5));
  display.addLine(DGtal::Z3i::RealPoint(rp[0]-0.5, rp[1]+0.5, rp[2]+0.5),
		  DGtal::Z3i::RealPoint(rp[0]-0.5, rp[1]-0.5, rp[2]+0.5));

  display.addLine(DGtal::Z3i::RealPoint(rp[0]-0.5, rp[1]-0.5, rp[2]-0.5),
		  DGtal::Z3i::RealPoint(rp[0]-0.5, rp[1]-0.5, rp[2]+0.5));
  display.addLine(DGtal::Z3i::RealPoint(rp[0]+0.5, rp[1]-0.5, rp[2]-0.5),
		  DGtal::Z3i::RealPoint(rp[0]+0.5, rp[1]-0.5, rp[2]+0.5));
  display.addLine(DGtal::Z3i::RealPoint(rp[0]+0.5, rp[1]+0.5, rp[2]-0.5),
		  DGtal::Z3i::RealPoint(rp[0]+0.5, rp[1]+0.5, rp[2]+0.5));
  display.addLine(DGtal::Z3i::RealPoint(rp[0]-0.5, rp[1]+0.5, rp[2]-0.5),
		  DGtal::Z3i::RealPoint(rp[0]-0.5, rp[1]+0.5, rp[2]+0.5));
  display.setLineColor(lineColorSave);
}

template <typename Space, typename KSpace>
template<DGtal::Dimension dim, typename TComponent>
inline
void DGtal::Display3DFactory<Space,KSpace>::draw( Display3D<Space, KSpace> & display,
						  const DGtal::PointVector<dim,TComponent> & p )
{
  DGtal::Color fillColorSave = display.getFillColor();
  ASSERT(dim == 3);

  std::string mode = display.getMode( p.className() );
  ASSERT( (mode=="Paving" || mode=="Grid" || mode=="Both" || mode=="PavingWired"|| mode=="") );

  if ( mode == "Paving" || ( mode == "" ) )
    drawAsPaving( display, p );
  else if ( mode == "Grid" )
    drawAsGrid( display, p );
  else if ( ( mode == "Both" ) )
    {
      drawAsPaving( display, p );
      drawAsGrid( display, p );
    }
  else if( mode=="PavingWired")
    {
      drawAsPavingWired( display, p );
    }
  display.setFillColor(fillColorSave);
}

template <typename Space, typename KSpace>
template<DGtal::Dimension dim, typename TComponent>
inline
void DGtal::Display3DFactory<Space,KSpace>::draw( Display3D<Space, KSpace> & display,
						  const DGtal::PointVector<dim,TComponent> & p,
						  const DGtal::PointVector<dim,TComponent> & aPoint )
{
  ASSERT(dim == 3);

  DGtal::Z3i::RealPoint rp = display.embed(p );
  DGtal::Z3i::RealPoint rpa = display.embed(aPoint );
  display.addLine(rpa, DGtal::Z3i::RealPoint( rpa[0] + rp[0], rpa[1] + rp[1], rpa[2] + rp[2]));
}
// PointVector


// GridCurve
template <typename Space, typename KSpace>
inline
void DGtal::Display3DFactory<Space,KSpace>::draw( Display3D<Space, KSpace> & display,
						  const DGtal::GridCurve<KSpace> & gc)
{
  typedef typename DGtal::GridCurve<KSpace>::SCellsRange Range;
  Range r = gc.getSCellsRange();
  for ( typename Range::ConstIterator it = r.begin(), itEnd = r.end();
        it != itEnd; ++it )
    {
      draw( display, *it );
    }
}
// GridCurve

// SCellsRange
template <typename Space, typename KSpace>
template <typename TIterator, typename TSCell>
inline
void DGtal::Display3DFactory<Space,KSpace>::draw( Display3D<Space, KSpace> & display,
						  const DGtal::ConstRangeAdapter<TIterator, DGtal::DefaultFunctor, TSCell> & object )
{
  typedef DGtal::ConstRangeAdapter<TIterator, DGtal::DefaultFunctor, TSCell> Range;
  typedef typename Range::ConstIterator ConstIterator;

  ConstIterator it ( object.begin() );
  ConstIterator itEnd ( object.end() );
  for( ; it != itEnd; ++it)
    {
      draw( display, *it);
    }
}
// SCellsRange

// PointsRange
template <typename Space, typename KSpace>
template <typename TIterator>
inline
void DGtal::Display3DFactory<Space,KSpace>::draw( Display3D<Space, KSpace> & display,
						  const DGtal::ConstRangeAdapter<TIterator, SCellToPoint<KSpace>, typename KSpace::Point> & object )
{
  typedef ConstRangeAdapter<TIterator, SCellToPoint<KSpace>, typename KSpace::Point> Range;
  typedef typename Range::ConstIterator ConstIterator;

  ConstIterator it ( object.begin() );
  ConstIterator itEnd ( object.end() );
  for( ; it != itEnd; ++it)
    {
      display << SetMode3D(it->className(),"Paving");
      display << *it;
    }
}
// PointsRange

// MidPointsRange
template <typename Space, typename KSpace>
template <typename TIterator>
inline
void DGtal::Display3DFactory<Space,KSpace>::draw( Display3D<Space, KSpace> & display,
                          const DGtal::ConstRangeAdapter<TIterator, CanonicSCellEmbedder<KSpace>,
						  typename KSpace::Space::RealPoint> & object )
{
  typedef typename KSpace::Space::RealPoint RPoint;
  typedef ConstRangeAdapter<TIterator, CanonicSCellEmbedder<KSpace>, RPoint > Range;
  typedef typename Range::ConstIterator ConstIterator;

  ConstIterator it ( object.begin() );
  ConstIterator itEnd ( object.end() );
  for( ; it != itEnd; ++it)
    {
      display << SetMode3D(it->className(),"Grid");
      display << *it;
    }
}
// MidPointsRange

// ArrowsRange
template <typename Space, typename KSpace>
template <typename TIterator>
inline
void DGtal::Display3DFactory<Space,KSpace>::draw( Display3D<Space, KSpace> & display,
						  const DGtal::ConstRangeAdapter<TIterator, SCellToArrow<KSpace>,
						  std::pair<typename KSpace::Point, typename KSpace::Vector> > & object )
{
  typedef typename KSpace::Point Point;
  typedef typename KSpace::Vector Vector;
  typedef std::pair<Point, Vector> Arrow;
  typedef ConstRangeAdapter<TIterator, SCellToArrow<KSpace>, Arrow > Range;
  typedef typename Range::ConstIterator ConstIterator;

  ConstIterator it ( object.begin() );
  ConstIterator itEnd ( object.end() );
  for( ; it != itEnd; ++it)
    { //display the associated cell
      draw( display, *(it.base()) );
    }
}
// ArrowsRange

// InnerPointsRange
template <typename Space, typename KSpace>
template <typename TIterator>
inline
void DGtal::Display3DFactory<Space,KSpace>::draw( Display3D<Space, KSpace> & display,
						  const DGtal::ConstRangeAdapter<TIterator, SCellToInnerPoint<KSpace>, typename KSpace::Point> & object )
{
  typedef ConstRangeAdapter<TIterator, SCellToInnerPoint<KSpace>, typename KSpace::Point> Range;
  typedef typename Range::ConstIterator ConstIterator;

  ConstIterator it ( object.begin() );
  ConstIterator itEnd ( object.end() );
  for( ; it != itEnd; ++it)
    {
      display << SetMode3D(it->className(),"Paving");
      display << CustomColors3D(Color(0, 0, 255,0),Color(0, 0, 200, 100));
      display << *it;
    }
}
// InnerPointsRange

// OuterPointsRange
template <typename Space, typename KSpace>
template <typename TIterator>
inline
void DGtal::Display3DFactory<Space,KSpace>::draw( Display3D<Space, KSpace> & display,
						  const DGtal::ConstRangeAdapter<TIterator, SCellToOuterPoint<KSpace>, typename KSpace::Point> & object )
{
  typedef ConstRangeAdapter<TIterator, SCellToOuterPoint<KSpace>, typename KSpace::Point> Range;
  typedef typename Range::ConstIterator ConstIterator;

  ConstIterator it ( object.begin() );
  ConstIterator itEnd ( object.end() );
  for( ; it != itEnd; ++it)
    {
      display << SetMode3D(it->className(),"Paving");
      display << CustomColors3D(Color(0, 255, 0 ,0),Color(0, 200, 0, 100));
      display << *it;
    }
}
// OuterPointsRange

// IncidentPointsRange
template <typename Space, typename KSpace>
template <typename TIterator>
inline
void DGtal::Display3DFactory<Space,KSpace>::draw( Display3D<Space, KSpace> & display,
						  const DGtal::ConstRangeAdapter<TIterator, SCellToIncidentPoints<KSpace>,
						  std::pair<typename KSpace::Point, typename KSpace::Point > > & object )
{
  typedef std::pair<typename KSpace::Point, typename KSpace::Point > Pair;
  typedef ConstRangeAdapter<TIterator, SCellToIncidentPoints<KSpace>, Pair> Range;
  typedef typename Range::ConstIterator ConstIterator;

  ConstIterator it ( object.begin() );
  ConstIterator itEnd ( object.end() );
  for( ; it != itEnd; ++it)
    {
      Pair pair( *it );
      display << SetMode3D(pair.first.className(),"Paving");
      display << CustomColors3D(Color(0, 0, 255,0),Color(0, 0, 200, 100));
      display << pair.first;
      display << CustomColors3D(Color(0, 255, 0 ,0),Color(0, 200, 0, 100));
      display << pair.second;
    }
}
// IncidentPointsRange

template <typename Space, typename KSpace>
inline
void DGtal::Display3DFactory<Space,KSpace>::draw( Display3D<Space, KSpace> & display,
						  const DGtal::SetMode3D & sm3d )
{
  if (   display.myModes[ sm3d.myClassname ] != sm3d.myMode )
    {
      display.createNewLineList("SetMode3D");
      display.createNewBallList("SetMode3D");
      display.createNewCubeList("SetMode3D");
      display.createNewQuadList("SetMode3D");
      display.createNewTriangleList("SetMode3D");
      display.createNewPolygonList("SetMode3D");
      display.myModes[ sm3d.myClassname ] = sm3d.myMode;
    }
}

template< typename Space, typename KSpace>
inline
void DGtal::Display3DFactory<Space,KSpace>::draw( Display3D<Space, KSpace> & display,
						  const DGtal::CustomStyle3D & cs3d )
{
  if (display.myStyles[ cs3d.myClassname ] != cs3d.myStyle )
    {
      display.myStyles[ cs3d.myClassname ] = cs3d.myStyle;
      display.createNewLineList("CustomStyle3D");
      display.createNewBallList("CustomStyle3D");
      display.createNewCubeList("CustomStyle3D");
      display.createNewQuadList("CustomStyle3D");
      display.createNewTriangleList("CustomStyle3D");
      display.createNewPolygonList("CustomStyle3D");
    }
}

template< typename Space, typename KSpace>
inline
void DGtal::Display3DFactory<Space,KSpace>::draw( Display3D<Space, KSpace> & display, const DGtal::CustomColors3D & cc3d )
{
  if ((display.getFillColor() != cc3d.myFillColor ) ||
      ((display.getLineColor() != cc3d.myPenColor )))
    {
      display.setFillColor(cc3d.myFillColor);
      display.setLineColor(cc3d.myPenColor);
      display.createNewLineList("CustomColors3D");
      display.createNewBallList("CustomColors3D");
      display.createNewCubeList("CustomColors3D");
      display.createNewQuadList("CustomColors3D");
      display.createNewTriangleList("CustomColors3D");
      display.createNewPolygonList("CustomColors3D");
    }
}


template< typename Space, typename KSpace>
inline
void DGtal::Display3DFactory<Space,KSpace>::draw( Display3D<Space, KSpace> & display,
						  const DGtal::ClippingPlane & cl )
{
  display.addClippingPlane(cl.myA, cl.myB, cl.myC, cl.myD, cl.myDrawPlane);
}

template< typename Space, typename KSpace>
inline
void DGtal::Display3DFactory<Space,KSpace>::draw( Display3D<Space, KSpace> & display, const DGtal::TransformedPrism & aTransformedPrism)
{

  DGtal::Color fillColorSave = display.getFillColor();
  std::string mode = display.getMode( aTransformedPrism.mySurfel.className() );
  ASSERT((mode=="" || mode=="Highlighted" || mode=="Transparent" || mode=="Basic" || mode=="Illustration")||
         ("DGtal::Display3DFactory<Space,KSpace>::draw( Display3D<Space, KSpace> & display, const DGtal::ShiftedKSSurfel & aTransformedPrism ): Unknown mode "+mode)=="");
  // used to display surfels located at a same position.
  double factorVolSurfel=1.0;
  if(mode=="Highlighted")
    {
      factorVolSurfel = 1.2;
      display.setFillColor(DGtal::Color(255, 50, 50, 255));
    }else if(mode=="Transparent")
    {
      display.setFillColor(DGtal::Color(180, 180, 250, 25));
    }else if(mode=="Basic")
    {
      // basicMode=true;
    }
  DGtal::Z3i::RealPoint rps = display.embedKS(aTransformedPrism );

  bool xodd = ( aTransformedPrism.mySurfel.myCoordinates[ 0 ] & 1 );
  bool yodd = ( aTransformedPrism.mySurfel.myCoordinates[ 1 ] & 1 );
  bool zodd = ( aTransformedPrism.mySurfel.myCoordinates[ 2 ] & 1 );

  unsigned int spaceDim= (xodd ? 1:0) + (yodd ? 1:0) + (zodd ? 1:0);
  ASSERT(spaceDim==2);

  //display.addSurfelPrism(rps[0], rps[1], rps[2],! xodd, !yodd, !zodd, factorVolSurfel, aTransformedSurfelPrism.mySizeFactor, true, aTransformedSurfelPrism.mySurfel.myPositive );
  display.addPrism(DGtal::Z3i::RealPoint(rps[0]+(xodd? 0:0.5 ), rps[1]+(yodd? 0:0.5 ), rps[2]+(zodd? 0:0.5 )),! xodd, !yodd, !zodd, factorVolSurfel,1.0, true, aTransformedPrism.mySurfel.myPositive );
  display.setFillColor(fillColorSave);

}




// //
///////////////////////////////////////////////////////////////////////////////
