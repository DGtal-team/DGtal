/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file   Display2DFactory.ih
 * @author Martial Tola <http://liris.cnrs.fr/martial.tola/>
 * @date   mercredi 28 septembre 2011
 * 
 * @brief
 *
 * Implementation of inline methods defined in Display2DFactory.h
 *
 * This file is part of the DGtal library.
 */

///////////////////////////////////////////////////////////////////////////////
// Implementation of inline methods                                          //


///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions and external operators                 //


// AngleLinearMinimizer
inline
void DGtal::Display2DFactory::draw( DGtal::Board2D & board,
           const DGtal::AngleLinearMinimizer & a )
{
  double distance=5.0;
  board.setLineWidth(3.0);
  board.setPenColor(Color(20,20,200));
  // now with accessor
  for(int i=0; i< (int)a.size(); i++){
    board.drawArc(0.0, 0.0, distance, a.ro(i).min, a.ro(i).max, false, 1);
    board.drawDot(cos(a.ro(i).value)*distance, sin(a.ro(i).value)*distance );
    distance+=a.ro(i).distToNext;
  }
  distance=5.0;
  double distanceNext;
  // now with accessor
  for(int i=0; i< (int) (a.size()-1); i++){
    distanceNext= distance+ a.ro(i).distToNext;
    board.setPenColor(Color(200,20,20));
    board.drawLine(cos(a.ro(i).value)*distance, sin(a.ro(i).value)*distance, 
                   cos(a.ro(i+1).value)*distanceNext, sin(a.ro(i+1).value)*distanceNext);
    distance=distanceNext;
  } 
}
// AngleLinearMinimizer


// ArithmeticalDSS
template <typename TIterator, typename TInteger, int connectivity>
inline
void DGtal::Display2DFactory::drawAsBoundingBox( DGtal::Board2D & aBoard, 
           const DGtal::ArithmeticalDSS<TIterator,TInteger,connectivity> & a )
{
  typedef DGtal::PointVector<2,double> PointD;
  
  //draw bounding box
  PointD topLeft = a.project(*a.myF, a.myUf);
  PointD bottomLeft = a.project(*a.myF, a.myLf);
  PointD bottomRight = a.project(*a.myL, a.myLf);
  PointD topRight = a.project(*a.myL, a.myUf);
  

  LibBoard::Point topLeftBoard(topLeft[0],topLeft[1]);
  LibBoard::Point bottomLeftBoard(bottomLeft[0],bottomLeft[1]);
  LibBoard::Point bottomRightBoard(bottomRight[0],bottomRight[1]);
  LibBoard::Point topRightBoard(topRight[0],topRight[1]);
  
  vector<LibBoard::Point> bb;
  bb.push_back(topLeftBoard);
  bb.push_back(bottomLeftBoard);
  bb.push_back(bottomRightBoard);
  bb.push_back(topRightBoard);
  
  aBoard.drawClosedPolyline(bb);
}
  
template <typename TIterator, typename TInteger, int connectivity>
inline
void DGtal::Display2DFactory::drawAsDigitalPoints( DGtal::Board2D & aBoard, 
           const DGtal::ArithmeticalDSS<TIterator,TInteger,connectivity> & a )
{
  typedef TIterator ConstIterator;
  typedef typename IteratorCirculatorTraits<ConstIterator>::Value Point; 
  
  ConstIterator itend = a.myL; ++itend;

  // Draw a linking polygonal line if the pixels are drawn as points. 
  if(aBoard.getMode("PointVector")=="Grid" || aBoard.getMode("PointVector")=="")
    {
      vector<LibBoard::Point> contour;
      for (ConstIterator i = a.myF; i != itend; ++i) {
        Point p = *i;
        double xp = NumberTraits<TInteger>::castToDouble(p[0]);
        double yp = NumberTraits<TInteger>::castToDouble(p[1]);
        contour.push_back(LibBoard::Point(xp,yp));
      }
      aBoard.drawPolyline(contour);
    }

  // Draw points
  for (ConstIterator i = a.myF; i != itend; ++i) {
    Point p = *i;
    aBoard << p;
  }
}
  
template <typename TIterator, typename TInteger, int connectivity>
inline
void DGtal::Display2DFactory::draw( DGtal::Board2D & board, 
	   const DGtal::ArithmeticalDSS<TIterator,TInteger,connectivity> & a )
{
  std::string mode = board.getMode( a.className() );
  if ( mode == "BoundingBox" )
    drawAsBoundingBox( board, a );
  else if ( mode == "Points" )
    drawAsDigitalPoints( board, a );
  else if ( ( mode == "" ) )
    {
      drawAsDigitalPoints( board, a );
      drawAsBoundingBox( board, a );
    }
  else
    ASSERT(false && ("draw( DGtal::Board2D & board, const DGtal::ArithmeticalDSS<TIterator,TInteger,connectivity> & a ): Unknown mode "+mode)==""  );

}
// ArithmeticalDSS


// CircleFrom2Points
template <typename TPoint>
inline
void DGtal::Display2DFactory::draw(Board2D & aBoard, const DGtal::CircleFrom2Points<TPoint> & cf2p)
{
    // now with accessor
    CircleFrom3Points<TPoint> c(cf2p.pole(),cf2p.p(),cf2p.q()); 
    drawArc(aBoard,c,cf2p.p(),cf2p.q(),true);  
}
// CircleFrom2Points


// CircleFrom3Points
template <typename Point>
inline
void DGtal::Display2DFactory::drawArc(Board2D & aBoard, const DGtal::CircleFrom3Points<Point> & cf3p, const Point& aPoint1, const Point& aPoint2, bool anOrientation)
{
  typedef typename Point::Coordinate Coordinate;
  typedef Point Vector;
  
  double cx = 0, cy = 0, radius = 1;
  try
  {
    //circle parameters
    cf3p.getParameters(cx, cy, radius);
    //angle parameters
    double alpha1 = std::atan2( NumberTraits<Coordinate>::castToDouble(aPoint1[1])-cy, 
                                NumberTraits<Coordinate>::castToDouble(aPoint1[0])-cx );
    alpha1 = (alpha1<0)?(alpha1+2.0*M_PI):alpha1;  
    double alpha2 = std::atan2( NumberTraits<Coordinate>::castToDouble(aPoint2[1])-cy, 
                                NumberTraits<Coordinate>::castToDouble(aPoint2[0])-cx );
    alpha2 = (alpha2<0)?(alpha2+2.0*M_PI):alpha2;  
    // now with accessor
    Vector u(cf3p.p() - cf3p.q());
    Vector v(cf3p.r() - cf3p.p());
    bool orientation = ( ( (u[0] * v[1]) - (u[1] * v[0]) ) < 0 )?(!anOrientation):anOrientation;
    //drawing
    aBoard.drawArc (cx, cy, radius, alpha1, alpha2, orientation); 
  } 
  catch ( InfiniteNumberException e )
  {
    aBoard.drawLine( NumberTraits<Coordinate>::castToDouble(aPoint1[0]),
                     NumberTraits<Coordinate>::castToDouble(aPoint1[1]),
                     NumberTraits<Coordinate>::castToDouble(aPoint2[0]),
                     NumberTraits<Coordinate>::castToDouble(aPoint2[1]) );
  } 
}

template <typename Point>
inline
void DGtal::Display2DFactory::drawSector(Board2D & aBoard, const DGtal::CircleFrom3Points<Point> & cf3p, const Point& aPoint1, const Point& aPoint2, bool anOrientation)
{
  typedef typename Point::Coordinate Coordinate;
  typedef Point Vector;
  
  double cx = 0, cy = 0, radius = 1;
  try
  {
    //circle parameters
    cf3p.getParameters(cx, cy, radius);
    //angle parameters
    double alpha1 = std::atan2( NumberTraits<Coordinate>::castToDouble(aPoint1[1])-cy, 
                                NumberTraits<Coordinate>::castToDouble(aPoint1[0])-cx );
    alpha1 = (alpha1<0)?(alpha1+2.0*M_PI):alpha1;  
    double alpha2 = std::atan2( NumberTraits<Coordinate>::castToDouble(aPoint2[1])-cy, 
                                NumberTraits<Coordinate>::castToDouble(aPoint2[0])-cx );
    alpha2 = (alpha2<0)?(alpha2+2.0*M_PI):alpha2;
    // now with accessor
    Vector u(cf3p.p() - cf3p.q());
    Vector v(cf3p.r() - cf3p.p());
    bool orientation = ( ( (u[0] * v[1]) - (u[1] * v[0]) ) < 0 )?(!anOrientation):anOrientation;
    //arc drawing
    aBoard.drawArc (cx, cy, radius, alpha1, alpha2, orientation); 
    //draw the segments tied to the center
    double fx = cx + radius*std::cos(alpha1);
    double fy = cy + radius*std::sin(alpha1);
    double lx = cx + radius*std::cos(alpha2);
    double ly = cy + radius*std::sin(alpha2);
    aBoard.drawLine(fx, fy, cx, cy ); 
    aBoard.drawLine(lx, ly, cx, cy ); 

  } 
  catch ( InfiniteNumberException e )
  {
    aBoard.drawLine( NumberTraits<Coordinate>::castToDouble(aPoint1[0]),
                     NumberTraits<Coordinate>::castToDouble(aPoint1[1]),
                     NumberTraits<Coordinate>::castToDouble(aPoint2[0]),
                     NumberTraits<Coordinate>::castToDouble(aPoint2[1]) );
  } 
}

template <typename Point>
inline
void DGtal::Display2DFactory::drawAnnulus(Board2D & aBoard, const DGtal::CircleFrom3Points<Point> & cf3p, const Point& aPoint1, const Point& aPoint2, const double& w, bool anOrientation)
{
  typedef typename Point::Coordinate Coordinate;
  typedef Point Vector;
  
  double cx = 0, cy = 0, radius = 1;
  try
  {
    //circle parameters
    cf3p.getParameters(cx, cy, radius);
    //angle parameters
    double alpha1 = std::atan2( NumberTraits<Coordinate>::castToDouble(aPoint1[1])-cy, 
                                NumberTraits<Coordinate>::castToDouble(aPoint1[0])-cx );
    alpha1 = (alpha1<0)?(alpha1+2.0*M_PI):alpha1;  
    double alpha2 = std::atan2( NumberTraits<Coordinate>::castToDouble(aPoint2[1])-cy, 
                                NumberTraits<Coordinate>::castToDouble(aPoint2[0])-cx );
    alpha2 = (alpha2<0)?(alpha2+2.0*M_PI):alpha2; 
    // now with accessor
    Vector u(cf3p.p() - cf3p.q());
    Vector v(cf3p.r() - cf3p.p());
    bool orientation = ( ( (u[0] * v[1]) - (u[1] * v[0]) ) < 0 )?(!anOrientation):anOrientation;
    //inner arc
    aBoard.drawArc (cx, cy, radius-w, alpha1, alpha2, orientation); 
    //outer arc
    aBoard.drawArc (cx, cy, radius+w, alpha1, alpha2, orientation); 
    //first segment
    double ifx = cx + (radius-w)*std::cos(alpha1);
    double ify = cy + (radius-w)*std::sin(alpha1);
    double ofx = cx + (radius+w)*std::cos(alpha1);
    double ofy = cy + (radius+w)*std::sin(alpha1);
    aBoard.drawLine(ifx, ify, ofx, ofy); 
    //second segment
    double ilx = cx + (radius-w)*std::cos(alpha2);
    double ily = cy + (radius-w)*std::sin(alpha2);
    double olx = cx + (radius+w)*std::cos(alpha2);
    double oly = cy + (radius+w)*std::sin(alpha2);
    aBoard.drawLine(ilx, ily, olx, oly); 
  } 
  catch ( InfiniteNumberException e )
  {
    aBoard.drawLine( NumberTraits<Coordinate>::castToDouble(aPoint1[0]),
                     NumberTraits<Coordinate>::castToDouble(aPoint1[1]),
                     NumberTraits<Coordinate>::castToDouble(aPoint2[0]),
                     NumberTraits<Coordinate>::castToDouble(aPoint2[1]) );
  } 
}

template <typename Point>
inline
void DGtal::Display2DFactory::draw(Board2D & aBoard, const DGtal::CircleFrom3Points<Point> & cf3p, const Point& aPoint1, const Point& aPoint2, bool anOrientation)
{
  std::string mode = aBoard.getMode( cf3p.className() );
  ASSERT( (mode=="Arc" || mode=="" || mode=="Sector"|| mode=="Annulus") ||
    ("draw(Board2D & aBoard, const DGtal::CircleFrom3Points<Point> & cf3p, const Point& aPoint1, const Point& aPoint2): Unknown mode "+mode)==""  );
  
  if ( mode == "Arc"  || ( mode == "" )  )
    drawArc( aBoard, cf3p, aPoint1, aPoint2, anOrientation);
  else if ( mode == "Sector" )
    drawSector( aBoard, cf3p, aPoint1, aPoint2, anOrientation);
  else if ( mode == "Annulus" )
    drawAnnulus( aBoard, cf3p, aPoint1, aPoint2, anOrientation);
}

template <typename TPoint>
inline
void DGtal::Display2DFactory::draw(Board2D & aBoard, const DGtal::CircleFrom3Points<TPoint> & cf3p)
{
  typedef typename TPoint::Coordinate Coordinate;
  
  double cx = 0, cy = 0, radius = 1;
  try
  {
    cf3p.getParameters(cx,cy,radius);
    aBoard.drawCircle (cx,cy,radius); 
  } 
  catch ( InfiniteNumberException e )
  {
    aBoard.drawLine( NumberTraits<Coordinate>::castToDouble(cf3p.myP[0]),
                     NumberTraits<Coordinate>::castToDouble(cf3p.myP[1]),
                     NumberTraits<Coordinate>::castToDouble(cf3p.myR[0]),
                     NumberTraits<Coordinate>::castToDouble(cf3p.myR[1]) );
  } 
}
// CircleFrom3Points


// DigitalSetBySTLSet
template<typename Domain>
inline
void DGtal::Display2DFactory::draw( DGtal::Board2D & board, 
           const DGtal::DigitalSetBySTLSet<Domain> & s )
{
  typedef typename Domain::Point Point;
  typedef typename std::set<Point>::const_iterator ConstIterator;
    
  ASSERT(Domain::Space::dimension == 2);
  for(ConstIterator it =  s.begin(); it != s.end(); ++it)       
    draw(board, *it);
  
}
// DigitalSetBySTLSet


// DigitalSetBySTLVector
template<typename Domain>
inline
void DGtal::Display2DFactory::draw( DGtal::Board2D & board, 
           const DGtal::DigitalSetBySTLVector<Domain> & v )
{
  typedef typename Domain::Point Point;
  typedef typename std::vector<Point>::const_iterator ConstIterator;
    
  if (Domain::dimension == 2)
  {
    for(ConstIterator it =  v.begin(); it != v.end(); ++it)       
      draw(board, *it);
  }
  else
    ASSERT(false && ("draw-NOT-YET-IMPLEMENTED-in-ND"));
}
// DigitalSetBySTLVector


// FP
template <typename TIterator, typename TInteger, int connectivity>
inline
void DGtal::Display2DFactory::drawAsPolygon( DGtal::Board2D & aBoard, 
           const DGtal::FP<TIterator,TInteger,connectivity> & fp )
{
  typedef DGtal::PointVector<2,TInteger> Point;
  typedef std::list<Point> Polygon;
  
  typedef typename Polygon::const_iterator ConstIterator;
  
  //polyline to draw
  vector<LibBoard::Point> polyline;

  // now with accessor
  ConstIterator i = fp.polygon().begin();
  for ( ;i != fp.polygon().end();++i) {
      Point p = (*i);
      double xp = (double)NumberTraits<TInteger>::castToInt64_t(p[0]);
      double yp = (double)NumberTraits<TInteger>::castToInt64_t(p[1]);
      polyline.push_back(LibBoard::Point(xp,yp));
  }

  // now with accessor
  if (fp.flagIsClosed()) {
      Point p = (*fp.polygon().begin());
      double xp = (double)NumberTraits<TInteger>::castToInt64_t(p[0]);
      double yp = (double)NumberTraits<TInteger>::castToInt64_t(p[1]);
      polyline.push_back(LibBoard::Point(xp,yp));
  }
  aBoard.drawPolyline(polyline);
}

template <typename TIterator, typename TInteger, int connectivity>
inline
void DGtal::Display2DFactory::draw( DGtal::Board2D & board, 
           const DGtal::FP<TIterator,TInteger,connectivity> & fp )
{
  std::string mode = board.getMode( fp.className() );
  if ( mode == "Polygon" )
    drawAsPolygon( board, fp );
  else if ( ( mode == "Both" ) || ( mode == "" ) )
    {
      drawAsPolygon( board, fp );
    }
  else
    {
      mode = "draw( DGtal::Board2D & board, const DGtal::FP<TIterator,TInteger,connectivity> & fp ): Unknown mode "+mode;
      ASSERT2(false,  mode  );
    }
}
// FP


// FreemanChain
template <typename TInteger>
inline
void DGtal::Display2DFactory::drawAsGrid( DGtal::Board2D & aBoard,
           const DGtal::FreemanChain<TInteger> & f )
{
  typedef TInteger Integer;
  typedef PointVector<2, Integer> Point;
  
  vector<Point> aVContour;
  FreemanChain<TInteger>::getContourPoints(f, aVContour);
  TInteger minX, minY, maxX, maxY;
  f.computeBoundingBox(minX, minY, maxX, maxY);
  
  vector<LibBoard::Point> contour;
  for(unsigned int i=0; i< aVContour.size(); i++){
    contour.push_back(LibBoard::Point(NumberTraits<TInteger>::castToDouble(aVContour[i][0]),
              NumberTraits<TInteger>::castToDouble(aVContour[i][1])));
  }
  aBoard.drawPolyline(contour);
}

template <typename TInteger>
inline
void DGtal::Display2DFactory::drawAsInterGrid( DGtal::Board2D & aBoard,
           const DGtal::FreemanChain<TInteger> & f )
{
  typedef TInteger Integer;
  typedef PointVector<2, Integer> Point;
  
  vector<Point> aVContour;
  FreemanChain<TInteger>::getContourPoints(f, aVContour);
  TInteger minX, minY, maxX, maxY;
  f.computeBoundingBox(minX, minY, maxX, maxY);
  
  vector<LibBoard::Point> contour;
  for(unsigned int i=0; i< aVContour.size(); i++){
    contour.push_back(LibBoard::Point(NumberTraits<TInteger>::castToInt64_t(aVContour[i][0])-0.5,
              NumberTraits<TInteger>::castToInt64_t(aVContour[i][1])+0.5));
  }
  aBoard.drawPolyline(contour);
}

template <typename TInteger>
inline
void DGtal::Display2DFactory::draw( DGtal::Board2D & aBoard,
	   const DGtal::FreemanChain<TInteger> & f )
{
  std::string mode = aBoard.getMode( f.className() );
  ASSERT( (mode=="Grid" || mode=="" || mode=="InterGrid") ||
    ("draw( DGtal::Board2D & board, const DGtal::FreemanChain<TInteger> & f ): Unknown mode "+mode)==""  );
  
  if ( mode == "Grid"  || ( mode == "" )  )
    drawAsGrid( aBoard, f );
  else if ( mode == "InterGrid" )
    drawAsInterGrid( aBoard, f );
}
// FreemanChain


// GeometricalDSS
template <typename TConstIterator>
inline
void DGtal::Display2DFactory::draw(DGtal::Board2D & aBoard,
          const DGtal::GeometricalDSS<TConstIterator> & g)
{
  typedef TConstIterator ConstIterator;
  typedef typename IteratorCirculatorTraits<ConstIterator>::Value Pair; 
  typedef typename Pair::first_type Point;
    
  double alpha, beta, gamma; 
  g.getParameters(alpha, beta, gamma); 

  typedef typename Point::Coordinate Coordinate; 

  // now with accessor
  Pair firstPair( *g.begin() ); 
  double fx1 = NumberTraits<Coordinate>::castToDouble(firstPair.first[0]);
  double fx2 = NumberTraits<Coordinate>::castToDouble(firstPair.second[0]);
  double fy1 = NumberTraits<Coordinate>::castToDouble(firstPair.first[1]);
  double fy2 = NumberTraits<Coordinate>::castToDouble(firstPair.second[1]);
  double fx = (fx1+fx2)/2.0; 
  double fy = (fy1+fy2)/2.0; 
  g.projects(fx, fy, alpha, beta, gamma);

  // now with accessor
  ConstIterator it (g.end()); 
  --it;
  Pair lastPair( *it );  
  double lx1 = NumberTraits<Coordinate>::castToDouble(lastPair.first[0]);
  double lx2 = NumberTraits<Coordinate>::castToDouble(lastPair.second[0]);
  double ly1 = NumberTraits<Coordinate>::castToDouble(lastPair.first[1]);
  double ly2 = NumberTraits<Coordinate>::castToDouble(lastPair.second[1]);
  double lx = (lx1+lx2)/2.0; 
  double ly = (ly1+ly2)/2.0; 
  g.projects(lx, ly, alpha, beta, gamma);

  aBoard.drawLine(fx,fy,lx,ly);
}
// GeometricalDSS

// GeometricalDCA
template <typename TConstIterator>
inline
void DGtal::Display2DFactory::draw(DGtal::Board2D & aBoard,
          const DGtal::GeometricalDCA<TConstIterator> & g)
{

  typedef TConstIterator ConstIterator;
  typedef typename IteratorCirculatorTraits<ConstIterator>::Value Pair; 
  typedef typename Pair::first_type Point;

  if (g.isValid())
    {
      if (!g.isStraight()) 
	{
	  typedef typename Point::Coordinate Coordinate; 
      
	  //points
	  Pair firstPair( *g.begin() ); 
	  double fx1 = NumberTraits<Coordinate>::castToDouble(firstPair.first[0]);
	  double fx2 = NumberTraits<Coordinate>::castToDouble(firstPair.second[0]);
	  double fy1 = NumberTraits<Coordinate>::castToDouble(firstPair.first[1]);
	  double fy2 = NumberTraits<Coordinate>::castToDouble(firstPair.second[1]);
	  PointVector<2,double> p1( (fx1+fx2)/2.0, (fy1+fy2)/2.0 ); 
      
	  ConstIterator it (g.end()); 
	  --it;
	  Pair lastPair( *it );  
	  double lx1 = NumberTraits<Coordinate>::castToDouble(lastPair.first[0]);
	  double lx2 = NumberTraits<Coordinate>::castToDouble(lastPair.second[0]);
	  double ly1 = NumberTraits<Coordinate>::castToDouble(lastPair.first[1]);
	  double ly2 = NumberTraits<Coordinate>::castToDouble(lastPair.second[1]);
	  PointVector<2,double> p2( (lx1+lx2)/2.0, (ly1+ly2)/2.0 ); 

	  //circle
	  CircleFrom3Points<Point> separatingCircle = g.getSeparatingCircle(); 
	  double px = NumberTraits<Coordinate>::castToDouble(separatingCircle.p()[0]);
	  double py = NumberTraits<Coordinate>::castToDouble(separatingCircle.p()[1]);
	  double qx = NumberTraits<Coordinate>::castToDouble(separatingCircle.q()[0]);
	  double qy = NumberTraits<Coordinate>::castToDouble(separatingCircle.q()[1]);
	  double rx = NumberTraits<Coordinate>::castToDouble(separatingCircle.r()[0]);
	  double ry = NumberTraits<Coordinate>::castToDouble(separatingCircle.r()[1]);
	  CircleFrom3Points<PointVector<2,double> > circleToDraw; 
	  circleToDraw.init( PointVector<2,double>(px,py), 
			     PointVector<2,double>(qx,qy), 
			     PointVector<2,double>(rx,ry) ); 
      
	  //orientation
	  ASSERT( g.getGeometricalDSSPtr().get() != 0 ); 
	  bool orientation = g.getGeometricalDSSPtr()->isClockwiseOriented(); 

	  //mode
	  std::string mode = aBoard.getMode( g.className() );
	  if ( mode == "Sector" ) 
	    drawSector( aBoard, circleToDraw, p1, p2, orientation );
	  else if ( mode == "Annulus" )
	    drawAnnulus( aBoard, circleToDraw, p1, p2, orientation );
	  else 
	    drawArc( aBoard, circleToDraw, p1, p2, orientation );
	}
      else 
	{
	  ASSERT( g.getGeometricalDSSPtr().get() != 0 ); 
	  aBoard << ( *(g.getGeometricalDSSPtr()) );
	} 
    }

}
// GeometricalDCA

// GridCurve
template <typename TKSpace>
void DGtal::Display2DFactory::draw( DGtal::Board2D & aBoard, 
           const GridCurve<TKSpace> & object )
{
    typedef typename GridCurve<TKSpace>::ConstIterator ConstIterator; 
    ConstIterator it ( object.begin() ); 
    ConstIterator itEnd ( object.end() ); 
    for( ; it != itEnd; ++it)
      {
	      aBoard << *it;
      }
}
// GridCurve

// SCellsRange
template <typename TIterator, typename TSCell>
void DGtal::Display2DFactory::draw( DGtal::Board2D & aBoard, 
           const ConstRangeAdapter<TIterator, DefaultFunctor, TSCell> & object )
{
    typedef ConstRangeAdapter<TIterator, DefaultFunctor, TSCell> Range; 
    typedef typename Range::ConstIterator ConstIterator; 

    ConstIterator it ( object.begin() ); 
    ConstIterator itEnd ( object.end() ); 
    for( ; it != itEnd; ++it)
      {
	aBoard << *it;
      }
}
// SCellsRange

// PointsRange
template <typename TIterator, typename TKSpace>
void DGtal::Display2DFactory::draw( DGtal::Board2D & aBoard, 
           const ConstRangeAdapter<TIterator, SCellToPoint<TKSpace>, typename TKSpace::Point> & object )
{
    typedef ConstRangeAdapter<TIterator, SCellToPoint<TKSpace>, typename TKSpace::Point> Range; 
    typedef typename Range::ConstIterator ConstIterator; 

    ConstIterator it ( object.begin() ); 
    ConstIterator itEnd ( object.end() ); 
    for( ; it != itEnd; ++it)
      {
	aBoard << SetMode(it->className(),"Grid"); 
	aBoard << *it;
      }
}
// PointsRange

// MidPointsRange
template <typename TIterator, typename TKSpace>
void DGtal::Display2DFactory::draw( DGtal::Board2D & aBoard, 
           const ConstRangeAdapter<TIterator, SCellToMidPoint<TKSpace>, 
           typename TKSpace::Space::RealPoint> & object )
{
    typedef typename TKSpace::Space::RealPoint RPoint;
    typedef ConstRangeAdapter<TIterator, SCellToMidPoint<TKSpace>, RPoint > Range; 
    typedef typename Range::ConstIterator ConstIterator; 

    ConstIterator it ( object.begin() ); 
    ConstIterator itEnd ( object.end() ); 
    for( ; it != itEnd; ++it)
      {
	RPoint p(*it); 
	double s = 0.1; 
	aBoard.drawLine( p[0]-s, p[1]-s, p[0]+s, p[1]+s ); 
	aBoard.drawLine( p[0]-s, p[1]+s, p[0]+s, p[1]-s ); 
      }
}
// MidPointsRange

// ArrowsRange
template <typename TIterator, typename TKSpace>
void DGtal::Display2DFactory::draw( DGtal::Board2D & aBoard, 
           const ConstRangeAdapter<TIterator, SCellToArrow<TKSpace>, 
           std::pair<typename TKSpace::Point, typename TKSpace::Vector> > & object )
{
    typedef typename TKSpace::Point Point; 
    typedef typename TKSpace::Vector Vector; 
    typedef std::pair<Point, Vector> Arrow;
    typedef ConstRangeAdapter<TIterator, SCellToArrow<TKSpace>, Arrow > Range; 
    typedef typename Range::ConstIterator ConstIterator; 

    ConstIterator it ( object.begin() ); 
    ConstIterator itEnd ( object.end() ); 
    for( ; it != itEnd; ++it)
      {
	Arrow a(*it); 
	Vector shift( a.second );
	aBoard << CustomStyle( shift.className(), 
			       new CustomPen( Color::Black, Color::Black, 1.0, 
					      Board2D::Shape::SolidStyle,
					      Board2D::Shape::RoundCap,
					      Board2D::Shape::RoundJoin ) );       
	draw(aBoard, shift, a.first);
      }
}
// ArrowsRange

// InnerPointsRange
template <typename TIterator, typename TKSpace>
void DGtal::Display2DFactory::draw( DGtal::Board2D & aBoard, 
           const ConstRangeAdapter<TIterator, SCellToInnerPoint<TKSpace>, 
           typename TKSpace::Point > & object )
{
    typedef typename TKSpace::Point Point; 
    typedef ConstRangeAdapter<TIterator, SCellToInnerPoint<TKSpace>, Point > Range; 
    typedef typename Range::ConstIterator ConstIterator; 

    ConstIterator it ( object.begin() ); 
    ConstIterator itEnd ( object.end() ); 
    for( ; it != itEnd; ++it)
      {
	aBoard << SetMode( it->className(), "Both" )
	       << CustomStyle( it->className(), 
			       new CustomFillColor( Color::Blue ) )
	       << *it;
      }
}
// InnerPointsRange

// OuterPointsRange
template <typename TIterator, typename TKSpace>
void DGtal::Display2DFactory::draw( DGtal::Board2D & aBoard, 
           const ConstRangeAdapter<TIterator, SCellToOuterPoint<TKSpace>, 
           typename TKSpace::Point > & object )
{
    typedef typename TKSpace::Point Point; 
    typedef ConstRangeAdapter<TIterator, SCellToOuterPoint<TKSpace>, Point > Range; 
    typedef typename Range::ConstIterator ConstIterator; 

    ConstIterator it ( object.begin() ); 
    ConstIterator itEnd ( object.end() ); 
    for( ; it != itEnd; ++it)
      {
	aBoard << SetMode( it->className(), "Both" )
	       << CustomStyle( it->className(), 
			       new CustomFillColor( Color::Green ) )
	       << *it;
      }
}
// OuterPointsRange

// IncidentPointsRange
template <typename TIterator, typename TKSpace>
void DGtal::Display2DFactory::draw( DGtal::Board2D & aBoard, 
           const ConstRangeAdapter<TIterator, SCellToIncidentPoints<TKSpace>, 
           std::pair<typename TKSpace::Point, typename TKSpace::Point> > & object )
{
    typedef typename TKSpace::Point Point; 
    typedef std::pair<Point, Point> Pair; 
    typedef ConstRangeAdapter<TIterator, SCellToIncidentPoints<TKSpace>, Pair > Range; 
    typedef typename Range::ConstIterator ConstIterator; 

    ConstIterator it ( object.begin() ); 
    ConstIterator itEnd ( object.end() ); 
    for( ; it != itEnd; ++it)
      {
	Pair pair(*it); 
	aBoard << SetMode( pair.first.className(), "Both" )
	       << CustomStyle( pair.first.className(), 
			       new CustomFillColor( Color::Blue ) )
	       << pair.first 
	       << CustomStyle( pair.second.className(), 
			       new CustomFillColor( Color::Green ) )
	       << pair.second; 
      }
}
// IncidentPointsRange

// HyperRectDomain
template<typename TSpace>
inline
void DGtal::Display2DFactory::drawAsGrid( DGtal::Board2D & aboard, 
           const DGtal::HyperRectDomain<TSpace> & h )
{
  typedef typename TSpace::Integer Integer;
  
  ASSERT(TSpace::dimension == 2 || "drawAsGrid-NOT-YET-IMPLEMENTED-in-ND");

  if (TSpace::dimension == 2)
  {
    for (double x = NumberTraits<Integer>::castToDouble(h.myLowerBound[0]); 
   x <=  NumberTraits<Integer>::castToDouble(h.myUpperBound[0]); x++)
      aboard.drawLine(x,
          NumberTraits<Integer>::castToDouble(h.myLowerBound[1]) -
          0.5,
          x, 
          NumberTraits<Integer>::castToDouble(h.myUpperBound[1]) +
          0.5);

    for (double y =  NumberTraits<Integer>::castToDouble(h.myLowerBound[1]);
   y <=  NumberTraits<Integer>::castToDouble(h.myUpperBound[1]); y++)
      aboard.drawLine(NumberTraits<Integer>::castToDouble(h.myLowerBound[0]) -
          0.5,
          y, 
          NumberTraits<Integer>::castToDouble(h.myUpperBound[0]) +
          0.5,
          y);

    for (double x =  NumberTraits<Integer>::castToDouble(h.myLowerBound[0]); 
   x <=  NumberTraits<Integer>::castToDouble(h.myUpperBound[0]); x++)
      for (double y =  NumberTraits<Integer>::castToDouble(h.myLowerBound[1]);
     y <=  NumberTraits<Integer>::castToDouble(h.myUpperBound[1]); y++)
        aboard.fillCircle(x, y, 0.1);
  }
}

template<typename TSpace>
inline
void DGtal::Display2DFactory::drawAsPaving( DGtal::Board2D & aboard, 
           const DGtal::HyperRectDomain<TSpace> & h )
{
  typedef typename TSpace::Integer Integer;
  
  ASSERT(TSpace::dimension==2 || "drawAsPaving-NOT-YET-IMPLEMENTED-in-ND" );
  
  if (TSpace::dimension == 2)
  {
    for (DGtal::int64_t x = NumberTraits<Integer>::castToInt64_t(h.myLowerBound[0]); 
   x <= NumberTraits<Integer>::castToInt64_t(h.myUpperBound[0]); x++)
      for (DGtal::int64_t y = NumberTraits<Integer>::castToInt64_t(h.myLowerBound[1]); 
     y <= NumberTraits<Integer>::castToInt64_t(h.myUpperBound[1]); y++)
        aboard.drawRectangle(x - 0.5, y + 0.5, 1, 1);
  }
}

template<typename TSpace>
inline
void DGtal::Display2DFactory::draw( DGtal::Board2D & board, 
           const DGtal::HyperRectDomain<TSpace> & h )
{
  std::string mode = board.getMode( h.className() );
  ASSERT((mode=="" || mode=="Grid" || mode=="Paving") ||
   ("draw( DGtal::Board2D & board, const DGtal::HyperRectDomain<TSpace> & h ): Unknown mode "+mode)=="");
  
  if ( ( mode == "" ) || ( mode == "Grid" ) )
    drawAsGrid( board, h );
  else if ( mode == "Paving" )
    drawAsPaving( board, h );
  // drawAsGrid( board, h );
}
// HyperRectDomain


// ImageContainerByHashTree
template <typename C, typename Domain, typename Value, typename HashKey>
inline
void DGtal::Display2DFactory::drawImageRecursive( DGtal::Board2D & aBoard,
    const DGtal::ImageContainerByHashTree<Domain, Value, HashKey> & i,
      HashKey key,
      const double p[2],
      const double len,
      LibBoard::Board & board,
      const C& cmap )
{
  
  ASSERT ( Domain::dimension == 2 );
  
  double np[2], nlen;

  //Node* n = i.getNode ( key );
  if ( i.getNode ( key ) )
  {
    Color c;
    c = cmap ( i.getNode ( key )->getObject() );
    board.setFillColorRGBi ( c.red(), c.green(), c.blue() );

    board.drawRectangle ( p[0], p[1], len, len );
  }
  else
  {
    HashKey children[4];
    i.myMorton.childrenKeys ( key, children );

    nlen = len / 2.0;

    np[0] = p[0];
    np[1] = p[1] - nlen;
    drawImageRecursive<C>( aBoard, i, children[0], np, nlen, board, cmap );

    np[0] = p[0] + nlen;
    np[1] = p[1] - nlen;
    drawImageRecursive<C>( aBoard, i, children[1], np, nlen, board, cmap );

    np[0] = p[0];
    np[1] = p[1];
    drawImageRecursive<C>( aBoard, i, children[2], np, nlen, board, cmap );

    np[0] = p[0] + nlen;
    np[1] = p[1];
    drawImageRecursive<C>( aBoard, i, children[3], np, nlen, board, cmap );
  }
}
  
template <typename C, typename Domain, typename Value, typename HashKey>
inline
void DGtal::Display2DFactory::drawImage( Board2D & board,
                const DGtal::ImageContainerByHashTree<Domain, Value, HashKey> & i,
                const Value &minV, const Value &maxV )
{
   static const HashKey ROOT_KEY = static_cast<HashKey>(1);
  
  ASSERT ( Domain::dimension == 2 );

  C colormap ( minV, maxV );

  double p[2];
  double len;

  p[0] = i.myOrigin[0];
  p[1] = i.myOrigin[1] + i.getSpanSize();

  len = i.getSpanSize();

  drawImageRecursive<C>( board, i, ROOT_KEY, p, len, board, colormap );
}
// ImageContainerByHashTree


// ImageContainerBySTLVector
template <typename Colormap, typename D, typename V>
inline
void DGtal::Display2DFactory::drawImage( DGtal::Board2D & board,
           const DGtal::ImageContainerBySTLVector<D, V> & i,
             const V &minV,
             const V &maxV )
{
  ASSERT(D::dimension == 2);

  Colormap colormap((const unsigned char)minV, (const unsigned char)maxV);
  Color c;
  V val;
  D ldomain(i.domain());

  for (typename D::ConstIterator it =  ldomain.begin();
       it != ldomain.end(); ++it)
  {
    val = i.operator()( (*it) );
    c = colormap( (const unsigned char)val );
    board.setFillColorRGBi( c.red(), c.green(), c.blue());
    board.drawRectangle( NumberTraits<typename D::Integer>::
       castToInt64_t((*it)[0]) - 0.5, 
       NumberTraits<typename D::Integer>::
       castToInt64_t((*it)[1]) + 0.5, 1, 1);
  }
}
// ImageContainerBySTLVector


// KhalimskyCell
template < Dimension dim, typename TInteger >
inline
void DGtal::Display2DFactory::draw( DGtal::Board2D & board,
           const DGtal::KhalimskyCell<dim, TInteger> & k )
{
  ASSERT( dim == 2 );
  float x = (float) 
    ( NumberTraits<TInteger>::castToInt64_t( k.myCoordinates[0] ) >> 1 );
  float y = (float) 
    ( NumberTraits<TInteger>::castToInt64_t( k.myCoordinates[1] ) >> 1 );
  float retract = 0.05f;
  bool xodd = ( k.myCoordinates[ 0 ] & 1 );
  bool yodd = ( k.myCoordinates[ 1 ] & 1 );
  float dx = xodd ? 1.0f - 2.0f*retract : 2.0f*retract;
  float dy = yodd ? 1.0f - 2.0f*retract : 2.0f*retract;
  board.drawRectangle( !xodd ? x - retract - 0.5 : x + retract - 0.5,
           !yodd ? y + retract - 0.5 : y - retract + 0.5,
           dx, dy );
}
// KhalimskyCell


// Object
template <typename TDigitalTopology, typename TDigitalSet>
inline
void DGtal::Display2DFactory::drawWithAdjacencies( DGtal::Board2D & aBoard, 
           const DGtal::Object<TDigitalTopology, TDigitalSet> & o )
{
  typedef TDigitalSet DigitalSet;
  typedef typename DigitalSet::Point Point;
  
  typedef TDigitalTopology DigitalTopology;
  typedef typename DigitalSet::Domain Domain;
  typedef
      typename DigitalSetSelector < Domain,
      SMALL_DS + HIGH_ITER_DS >::Type SmallSet;
  typedef Object<DigitalTopology, SmallSet> SmallObject;
  
  Point p;
  
  for (typename TDigitalSet::ConstIterator it = o.pointSet().begin();
      it != o.pointSet().end();
      ++it)
  {
    //Brute-force scan of the neighborhood.
    SmallObject neig = o.properNeighborhood(*it);
    for (typename SmallObject::DigitalSet::ConstIterator it2 = neig.pointSet().begin();
        it2 != neig.pointSet().end();
        ++it2)
    {
      p = (*it2) - (*it);
      draw(aBoard, p, (*it));
    }
  }
}

template <typename TDigitalTopology, typename TDigitalSet>
inline
void DGtal::Display2DFactory::draw( DGtal::Board2D & board, 
           const DGtal::Object<TDigitalTopology, TDigitalSet> & o )
{
  std::string mode = board.getMode( o.className() );
  if ( mode == "" )
    draw( board, o.pointSet() );
  else
    if ( mode == "DrawAdjacencies" )
    {
      draw( board, o.pointSet() );
      drawWithAdjacencies( board, o );
    }
    else
      ASSERT(false && (("draw( DGtal::Board2D & board, const DGtal::Object<TDigitalTopology, TDigitalSet> & o ): Unknown mode " + mode) == ""));
}
// Object


// PointVector
template<Dimension dim, typename TComponent>
inline
void DGtal::Display2DFactory::drawAsPaving( DGtal::Board2D & board, 
           const DGtal::PointVector<dim,TComponent> & p )
{
  ASSERT(dim == 2);
  board.drawRectangle( (float) NumberTraits<TComponent>::castToInt64_t(p.myArray[0]) - 0.5f, 
            (float) NumberTraits<TComponent>::castToInt64_t(p.myArray[1]) + 0.5f, 1, 1 );     
}

template<Dimension dim, typename TComponent>
inline
void DGtal::Display2DFactory::drawAsGrid( DGtal::Board2D & board, 
           const DGtal::PointVector<dim,TComponent> & p )
{
  ASSERT(dim == 2);
  board.setPenColor(Color::Black);
  board.fillCircle((float) NumberTraits<TComponent>::castToInt64_t(p.myArray[0]), 
       (float) NumberTraits<TComponent>::castToInt64_t(p.myArray[1]),0.1);
}
  
template<Dimension dim, typename TComponent>
inline
void DGtal::Display2DFactory::draw( DGtal::Board2D & board, 
           const DGtal::PointVector<dim,TComponent> & p )
{
  std::string mode = board.getMode( p.className() );
  ASSERT( (mode=="Paving" || mode=="Grid" || mode=="Both" || mode=="") ||
    ("draw( DGtal::Board2D & board, const DGtal::PointVector<dim,TComponent> & p ): Unknown mode "+mode)==""  );

  if ( mode == "Paving"  || ( mode == "" )  )
    drawAsPaving( board, p );
  else if ( mode == "Grid" )
    drawAsGrid( board, p );
  else if ( ( mode == "Both" ))
    {
      drawAsPaving( board, p );
      drawAsGrid( board, p );
    }
}

template<Dimension dim, typename TComponent>
inline
void DGtal::Display2DFactory::draw( DGtal::Board2D & board, 
          const DGtal::PointVector<dim,TComponent> & p, 
          const DGtal::PointVector<dim,TComponent> & apoint )
{
  ASSERT(dim == 2);

  board.drawArrow((float)apoint[0], (float) apoint[1],
      (float) apoint[0] + p.myArray[0], (float)apoint[1] + p.myArray[1],
      true);
}
// PointVector


// Preimage2D
template <typename Shape>
inline
void DGtal::Display2DFactory::draw( DGtal::Board2D & aBoard,
	   const DGtal::Preimage2D<Shape> & p )
{
  typedef typename Shape::Point Point;
  typedef typename std::list<Point>::const_iterator ConstForwardIterator;
  
  // now with accessor
  Shape s( p.shape() ); 
  ConstForwardIterator i = p.pHull().begin();
  Point pt(*i);
  ++i;
  while ( i != p.pHull().end() ) {
    s.init(pt, *i);
    draw(aBoard, s); //s.setStyle(aBoard);
    pt = Point(*i);
    ++i;
  }

  i = p.qHull().begin();
  pt = Point(*i);
  ++i;
  while ( i != p.qHull().end() ) {
    s.init(pt, *i);
    draw(aBoard, s); //s.setStyle(aBoard);
    pt = Point(*i);
    ++i;
  }

  Point Pf(*p.pHull().begin());
  Point Pl(*p.pHull().rbegin());
  Point Qf(*p.qHull().begin());
  Point Ql(*p.qHull().rbegin());

  s.init(Pf, Ql);
  draw(aBoard, s); //s.setStyle(aBoard);
  s.init(Qf, Pl);
  draw(aBoard, s); //s.setStyle(aBoard);
}
// Preimage2D


// SignedKhalimskyCell
template < Dimension dim, typename TInteger >
inline
void DGtal::Display2DFactory::draw( DGtal::Board2D & board,
	   const DGtal::SignedKhalimskyCell<dim, TInteger> & sk )
{
  ASSERT( dim == 2 );
  float x = (float) 
    ( NumberTraits<TInteger>::castToInt64_t( sk.myCoordinates[0] ) >> 1 );
  float y = (float) 
    ( NumberTraits<TInteger>::castToInt64_t( sk.myCoordinates[1] ) >> 1 );
  float retract = 0.05f;
  bool xodd = ( sk.myCoordinates[ 0 ] & 1 );
  bool yodd = ( sk.myCoordinates[ 1 ] & 1 );
  float dx = xodd ? 1.0f - 2.0f*retract : 2.0f*retract;
  float dy = yodd ? 1.0f - 2.0f*retract : 2.0f*retract;
  board.drawRectangle( !xodd ? x - retract - 0.5 : x + retract - 0.5,
           !yodd ? y + retract - 0.5 : y - retract + 0.5,
           dx, dy );
}
// SignedKhalimskyCell


// StraightLineFrom2Points
template <typename TPoint>
inline
void DGtal::Display2DFactory::draw(Board2D & aBoard, const DGtal::StraightLineFrom2Points<TPoint> & slf2p)
{
  // now with accessor
  aBoard.drawLine(slf2p.p()[0],slf2p.p()[1],slf2p.q()[0],slf2p.q()[1]);
}
// StraightLineFrom2Points


//


inline
void DGtal::Display2DFactory::draw( DGtal::Board2D & board,
           const DGtal::CustomStyle & cs )
{
  board.myStyles[ cs.myClassname ] = cs.myStyle;
}

inline
void DGtal::Display2DFactory::draw( DGtal::Board2D & board, 
	   const DGtal::SetMode & sm )
{
  board.myModes[ sm.myClassname ] = sm.myMode;
}


//                                                                           //
///////////////////////////////////////////////////////////////////////////////


