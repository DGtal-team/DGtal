/* 
 * Useful to avoid writing DGtal:: in front of every class.
 */
namespace DGtal {

/**
 * @page moduleviewerogre3d ViewerOgre3D : An interactive viewer
 *
 * This part of the manual describes how to use the diffenrent modes of the viewer 
 * 

@authors Anis Benyoub, David Coeurjolly

[TOC]
 
  \section DGtalGLV_ViewerOgre ViewerOgre3D: a stream mechanism for interacting with 3D scenes



  This class ViewerOgre3D defines the stream mechanism to
  display 3d primitives (like PointVector, DigitalSetBySTLSet, Object
  ...). It permits to display 3D scenes, with different complex objects
  and give the possibility to interact with them. The Ogre dependencie must be fullfield, please refer to the 
  following links.
- \ref linux 
- \ref macos 
  
The viewer has 3 modes:

 - The first one: the view mode, you can simply visualize the DGtal objects you insert into you the scene and interact with them (turn them, scale them, etc.)

 - The second mode: the selection mode, the viewer waits for the user to select something and validate his choice, then the viewer can return the user's choice.

 - The third mode: the manipulate mode, the viewer permits to the user to watch the evolution of a DGtal object when applying on it a function.

 *
 \section DGtal_Section View mode
First to use the ViewerOgre3D stream, you need to include the following hearders:
 *
@code
 #include "DGtal/io/viewers/OGRE/ViewerOgre3D.h"
@endcode
 *	
 *
 *	

The first step to visualize 3D object with Viewer3D is to create the Viewer from the main(): 
@code
  new ViewerOgre3D();
  DGtal::ViewerOgre3D & viewer = DGtal::ViewerOgre3D::getSingleton();
@endcode


Then we can display some 3D primitives:


@snippet io/viewers/OGRE/testDomainViewer.cpp ImportDomainfile


and finnaly, if you just want to visualize your objects.
@code
viewer.start();
@endcode

*
* You should obtain the following visualisation:
*
* \image html viewerDomain1.png "Digital point visualization  with ViewerOgre3D." 
* \image latex viewerDomain1.png "Digital point visualization  with ViewerOgre3D." width=5cm
*

* By changing the background color, adding the shadows, hiding the text,the wrist, the orthonormal axis  and turning the camera you can obtain a visualization like this one: 

*
* \image html viewerDomain2.png "Digital point visualization  with ViewerOgre3D." 
* \image latex viewerDomain2.png "Digital point visualization  with ViewerOgre3D." width=5cm


\subsection DGtal_VisualizationDigitalSet Visualization of DigitalSet and digital objects

*
* The ViewerOgre3D class allows also to display directly a \c DigitalSet. The first step is to create a \c DigitalSet for example from the Shape class.
*
*
@snippet io/viewers/OGRE/testSetViewer.cpp ImportSetfile
*

*
* You should obtain the following visualisation:
*
* \image html dgtalsetogre.png "Digital point visualization  with ViewerOgre3D." 
* \image latex dgtalsetogre.png "Digital point visualization  with ViewerOgre3D." width=5cm
*
* Node that the set is blue, that's due to selection.
*
*
* \subsection  DGtalGLV_ModeEx  Mode selection: the example of digital objects in 3D  
*
* Some digital elements (like Object, PointVector, ArithmeticalDSS3d) may have several possible ways to be rendered as a graphical object. For instance, a voxel may be seen more as a small sphere or more as a unit cube. In the same idea, a digital object may or may not be represented with its adjacency relations. Otherwise said, one may wish to see the set, another may wish to see the graph.

You may choose a mode for a drawable element by outputing on the stream a SetMode object. You just have to specify the classname (the easiest way is to call the method className() on an instance of the correct type) and the desired mode (a string). An Object is sensitive to the mode "" (default, just the set is displayed).
*
@snippet io/viewers/OGRE/testPoint2Viewer.cpp ImportPoint2file
* 
*or change the  mode
*
@snippet io/viewers/OGRE/testPoint1Viewer.cpp ImportPoint1file


* You should obtain the following visualisation for the first example:
*
* \image html viewerPoint1.png "Digital point visualization  with ViewerOgre3D." 
* \image latex  viewerPoint1.png "Digital point visualization  with ViewerOgre3D." width=5cm
*

* And for the second:
*
* \image html viewerPoint2.png "Digital point visualization  with ViewerOgre3D." 
* \image latex viewerPoint2.png "Digital point visualization  with ViewerOgre3D." width=5cm
*

* Node that in each example there is a point in red (it's due to selection (see below)).

\subsection  DGtalGLV_Mode Useful modes for several 3D drawable elements 


\subsubsection DGtalGLV_ModeListing Listing of different modes

As for \c Board2D the object can be displayed with different possible mode:

- class PointVector, modes: "" / "Both", "Paving" (default), "Grid"
- class DigitalSetBySTLSet and DigitalSetBySTLVector : "",  "" / "Both", "Paving" (default), "PavingTransp", "Grid".
- class Object, modes: "", "DrawAdjacencies", "PavingTransp".
- class HyperRectDomain, modes: "" / "Grid" (default), "Paving", "PavingPoints", "PavingGrids", "BoundingBox".
- class KhalimskyCell  ,  modes: "" / "Highlighted" ,"Transparent", "Basic".
- class SignedKhalimskyCell  ,  modes: "" / "Highlighted" ,"Transparent", "Basic".




\subsubsection DGtalGLV_ModeOtherExamples Others Examples

Others mode examples are illustrated for class KhalimskyCell and class Mesh.


 \image html viewerMeshImport.png "Mesh visualization  with ViewerOgre3D." 
 \image latex viewerMeshImport.png "Mesh visualization  with ViewerOgre3D." width=5cm

 \image html viewerKhalimsky.jpg "KhalimskyCell visualization  with ViewerOgre3D." 
 \image latex viewerKhalimsky.jpg "KhalimskyCell visualization  with ViewerOgre3D." width=5cm



\subsubsection  DGtalGLV_Custom Changing the style for displaying drawable elements.

As for Board2D, it is possible to custom the way to display 3D elements by using an instance of the following classes:


-  CustomColors3D: to change the color used to display surface primitive (GL_QUADS) and the pen color (LINE/POINTS) ;



The custom color can be applied by an instance of the CustomColors3D as follow:


The 4 Colors are :


SelfIlluminationColor


AmbientIlluminationColor


DiphuseIlluminationColor


SpecularIlluminationColor


And the last parameter is the texture (Note that it should be in the same folder that the binary).
@code 
  viewer << DGtal::CustomViewerColors3D(DGtal::Color(255,0,0,100),
				DGtal::Color(255,0,0,100),DGtal::Color(255,0,0,100),
				DGtal::Color(255,0,0,100),"unselected.jpg");
  viewer << p4 << p5 ;
@endcode



\subsubsection DGtalGLV_CLipping Adding clipping planes 

It also possible through the stream mechanism to add clipping plane
with the object \c ClippingPlane. We just have to add the real plane
equation and adding as for displaying an element. 


@code 
  View << DGtal::ViewerClippingPlane ( 1, 0, 0, -4.9 );
  View << DGtal::ViewerClippingPlane ( 0, 1, 0.3, -10 );
@endcode 

\subsubsection DGtalGLV_Camera Camera parameters 

You can set some default camera parameters by using ViewerCameraPosition, ViewerCameraDirection, ViewerCameraUpVector or ViewerCameraZNearFar parameters.
@code 
  View << DGtal::ViewerCameraPosition ( 2.500000, 2.500000, 16.078199 )
  << DGtal::ViewerCameraDirection ( 0.000000, 0.000000, -1.000000 )
  << DGtal::ViewerCameraUpVector ( 0.000000, 1.000000, 0.000000 );
  View << DGtal::ViewerCameraZNearFar ( 0.1, 200 );
@endcode 



\section DGtal_mode2 Selection mode

\subsection DGtal_Interactions Basic interactions 
 This viewer permits to interact individualy with the objects that are put in the scene.
 For example, by clicking on objects, the object's texture changes and you can apply some changes by using keyboard shortcuts,  as scaling the object's container, changing the transparency...

\subsection DGtal_Instream Instream mechanism
An instream mechanism can be used to get the dgtal corresponding objects of a selected node. You need to click on the scene object, and validate it by using the S key. For example:



@snippet io/viewers/OGRE/testSelectionViewer.cpp ImportSelectionfile

This code creates a scene with a DGtalset and permits to select two points that will be removed from the initial set.


For example, if you want to select a non visible point of the DGtalset, you can scale the set by using the associated shortcut and then validate your selection by the S key.

This selection mode may, for example, permit to sculpt something starting from a cube..
 


 \image html viewerSelection1.png "Selection 1  with ViewerOgre3D." 
 \image latex viewerSelection1.png "Selection 1  with ViewerOgre3D." width=5cm

 \image html viewerSelection2.png "Selection 2  with ViewerOgre3D." 
 \image latex viewerSelection2.png "Selection 2  with ViewerOgre3D." width=5cm


 \image html viewerSelection3.png "Selection 3  with ViewerOgre3D." 
 \image latex viewerSelection3.png "Selection 3  with ViewerOgre3D." width=5cm



\section DGtal_mode3 Manipulate mode

An dynamic manipulating mode can be used to get watch a set's evolution for a custom user specified function. Here is an example:

We define our manipulating function, here it's very simple function that returns the aValue first voxels of the set:
@snippet io/viewers/OGRE/testManipulateViewer.cpp ImportManipulateFunctionfile
 Then the main code
@snippet io/viewers/OGRE/testManipulateViewer.cpp ImportManipulatefile



By using the + and - keys, we can go through the range value and watch the set's evolution.


This example remains a simple one, more complex stuff can be done using this mode.


 \image html viewerManipulate1.png "Manipulate 1  with ViewerOgre3D." 
 \image latex viewerManipulate1.png "Manipulate 1  with ViewerOgre3D." width=5cm

 \image html viewerManipulate2.png "Manipulate 2  with ViewerOgre3D." 
 \image latex viewerManipulate2.png "Manipulate 2  with ViewerOgre3D." width=5cm



\section DGtal_Dynamic Dynamic interactions
By pressing h button during visualization you can obtain the list of the viewer interactions,
@code
-------------------------------------------------------------------------------------------

Ogre DGtal viewer commands: 

	Common commands to view, manipulate and selection modes:

		 Mouse interactions:

			 Right clic and drag: Translates the scene.
			 Left clic and drag: Turns the scene around the scene center.
			 Left shift + Left clic : Selects a scene object.
			 Mouse roll: Zoom.

		 Commands without selection

			 P: Show/Hide the orthonormal basis.
			 O: Shows/Hides the wirsts.
			 G: Shows/Hides the shadow plane.
			 T: Shows/Hides the text.
			 F: Changes the background color, from black to white and the inverse operation.
			 R: Resets the camera position.
			 U: Sets full screen.
			 I: Repositions the camera at (0,0) position.
			 Left Control +: Scales up the window.
			 Left Control -: Scales down the window.
			 X: Exports the scene to XML format and saves it to scene.scene.
			 C: Takes a screen capture of the viewer and saves it to ScreenShot.png 
			 H: Shows the user help on the standard output. 
			 Escape: Shuts down the viewer.  
		 Commands when something is selected

			 M: Sizes up the selection.
			 L: Sizes down the selection.
			 N: Increases the selection's transparency.
			 B: Decreases the selection's transparency.

	Specific commands

			On view mode:

			On manipulate mode:

			 + : Gets to the upper value of the manipulating. 
			 - : Gets to the lower value of the manipulating. 
			On selection mode:

			 S : Confirms the selection.
 
	On free 3D explore: (To switch to this mode press MAJ button)



-------------------------------------------------------------------------------------------

@endcode


\section DGtal_code API help for interactions
Some interactions are possible by calling methods in your program.


\subsection DGtal_code_screenShot Take a snapshot

You can take a screenshot and choose the export format by calling this method

@code
void 	printScene (std::string name="ScreenShot.png")
@endcode


To take a snapshot named foo, in jpg format, i just have to call this method in the main program.
@code
viewer.printScene("foo.jpg");
@endcode


\subsection DGtal_code_ortho Flipping the orthonormal basis visibility
You can simply do it by calling this method:
@code
void 	changeAxisVisibility ()
@endcode

\subsection DGtal_code_wrist Flipping the wrist visibility
You can simply do it by calling this method:
@code
void 	changeWristVisibility ()
@endcode

\subsection DGtal_code_background Flipping the background color
You can change it alternatively from gray to white( and from white to gray):
@code
 void 	flipBackgroundColor ()
@endcode

\subsection DGtal_code_xml Exporting the scene to xml format
You can export this scene to xml format (the extention of the file will be .scene), and for example using the blender addon to import it into blender by calling this method :
@code
void 	exportToXml (std::string aFileName)
@endcode

To get a xml file named titanic, the code will be
@code
viewer.exportToXml("titanic");
@endcode

\subsection DGtal_code_vrml Exporting the scene to vrml format
You can export this scene to vrml format (the extention of the file will be .wrl), and for example using the blender to import it,  by calling this method :
@code
void 	exportToVrml (std::string aFileName)
@endcode

To get a xml file named titanic, the code will be
@code
viewer.exportToVrml("titanic");
@endcode


\subsection DGtal_help  Displaying the list of the diffenrent possible interactions  on the standard output
Here is the method you should call to display the help.
@code
void 	showHelp ()
@endcode


\subsection DGtal_clearing Clearing the scene
Here is the method you should call to empty the scene from all the DGtal objects.
@code
void 	clearScene ()
@endcode


\subsection DGtal_code_lights Adding lights
Here is respectivly the methods to add Point lights, Spot lights or directional light.

aColor 	the light's Color


aPosition  the light's position


aDirection   the light's direction


aCast	defines if the light cast's shadows or not 


@code
void 	addPointLight (DGtal::Color aColor, DGtal::Z3i::Point aPosition, bool aCast)
 
void 	addSpotLight (DGtal::Color aColor, DGtal::Z3i::Point aPosition, DGtal::Z3i::Point aDirection, bool aCast)
 
void 	addDirectionalLight (DGtal::Color aColor, DGtal::Z3i::Point aPosition, DGtal::Z3i::Point aDirection, bool aCast) 
@endcode

\section DGtal_developper Developper guide.
This section aims to clarify the way to develop the ogre viewer. 

\subsection DGtal_AddingObject Adding an Object

For example adding a new dgtal object support to the viewer.


2 (+1) Steps must be done:

- Adding the support in Display3DFactory.


- Adding default style support.


- (Adding the ogre primitives)



Here we will add a virtual DGtal object that we will call Foo made of DGtal voxels, with 3 draw modes.

In Ogre3DDisplayFactory.h we add the following code:

@code
      //---------------------------------------------------------------------------Foo
      
      //Generic method
      template<typename Type>
      static void draw( ViewerOgre3D & viewer, const DGtal::Foo<Type> & f );
      
      // Paving/Voxel drawing
       template<typename Type>
      static void drawAsPaving( ViewerOgre3D & viewer, const DGtal::Foo<Type> & f );
      
      //Transparent Paving/Voxel drawing
      template<typename Type>
      static void drawAsPavingTransparent( ViewerOgre3D & viewer, const DGtal::Foo<Type> & f );
      
      
      // Grid/Point drawing
      template<typename Type>
      static void drawAsGrid( ViewerOgre3D & viewer, const DGtal::Foo<Type> & f  );
@endcode

In  Ogre3DDisplayFactory.ih we add the following code:

@code

template<typename Type>
inline
void DGtal::Ogre3DDisplayFactory::draw ( ViewerOgre3D & viewer,
    const DGtal::Foo<Type> & f )
{
  ASSERT(Domain::Space::dimension == 3);
  
  std::string mode = viewer.getMode( s.className() );
  ASSERT( (mode=="Paving" || mode=="PavingTransp" || mode=="Grid" || mode=="Both" || mode=="") );

  if ( mode == "Paving" || ( mode == "" ) )
    drawAsPaving( viewer, s );
  else if ( mode == "PavingTransp" )
  {
    drawAsPavingTransparent( viewer, s );
  }
  else if ( mode == "Grid" )
    drawAsGrid( viewer, s );
  else if ( ( mode == "Both" ) )
    {
      drawAsPaving( viewer, s );
      drawAsGrid( viewer, s );
    }
}


// This is pseudo code :
// Paving/Voxel drawing
template<typename Type>
inline
void DGtal::Ogre3DDisplayFactory::drawAsPaving( ViewerOgre3D & viewer, 
						const DGtal::Foo<Type> & f )
{

  ASSERT ( Domain::Space::dimension == 3 );

  DGtalNode * theDGtalSetNode = new DGtalNode ( viewer.getSceneMgr() );
  Ogre::SceneNode * theNode = viewer.getANode();
  viewer.createMaterial(theNode->getName());

  Representation * theVirtualRepresentation = new Representation ( viewer.getSceneMgr(), theNode, theNode->getName() );

  // Going through the dgtal Object, You must make a loop here, iterator it: 
    {
      Representation * newPoint = viewer.addVoxel ( NumberTraits<Component>::castToInt64_t ( ( *it ) [0] ),
                                  NumberTraits<Component>::castToInt64_t ( ( *it ) [1] ),
                                  NumberTraits<Component>::castToInt64_t ( ( *it ) [2] ),
                                  theNode->createChildSceneNode() ,theNode->getName());


      DGtalNode * newDGtalNode = new DGtalNode ( viewer.getSceneMgr() );
      newDGtalNode->setRepresentation ( newPoint );
      typedef typename Type::Point Point;
      newPoint->setAttachedParent ( newDGtalNode );
      theDGtalSetNode->addSon ( newDGtalNode );
      newDGtalNode->setFather ( theDGtalSetNode );
      newDGtalNode->setName ( newPoint->getEntityName() );
      viewer.addToList ( newDGtalNode );
      DrawableWithOgreWrapper<Point > * aPoint = new DrawableWithOgreWrapper<Point > ( ( *it ) ) ;
      DrawableWithOgre * aDrawableObject = ( DrawableWithOgre * ) aPoint;
      newDGtalNode->setDGtalObject ( aDrawableObject );

    }

  theDGtalSetNode->setName ( theVirtualRepresentation->getName() );

  theDGtalSetNode->setRepresentation ( theVirtualRepresentation );
  theDGtalSetNode->setFather ( viewer.getRootDGtalNode() );
  viewer.getRootDGtalNode()->addSon ( theDGtalSetNode );
  viewer.addToList ( theDGtalSetNode );

  DrawableWithOgreWrapper<Foo<Type> >  * aSet = new DrawableWithOgreWrapper<Foo<Type> > ( f );
  DrawableWithOgre * theDrawableObject = ( DrawableWithOgre * ) aSet;
  theDGtalSetNode->setDGtalObject ( theDrawableObject );
}


@endcode

And that's it !

If the primitive you need in your new object isn't in the one already handled, you should add a new "addObject" method in the viewer with your primitive.

\subsection DGtal_AddingInteraction Adding an Interaction



For example if you want to add a new viewer interaction, you should add your key catch in the InputListenner.ih, for example when the user presses the 8 key.
@code

bool InputListener::keyPressed ( const OIS::KeyEvent & evt )
{
  switch ( evt.key )
    {

      case OIS::KC_ESCAPE:
        myShutdown = true;
        if ( myViewer->isInManupulatingMode() )
          {
            myViewer->abortManupulating();
          }

        return false;
        break;


      case::OIS::KC_SUBTRACT:

        if ( myViewer->isInManupulatingMode() )
          {
            myViewer->newManipulatingValue ( -1 );
          }

        break;

      case::OIS::KC_ADD:

        if ( myViewer->isInManupulatingMode() )
          {
            myViewer->newManipulatingValue ( 1 );
          }
        break;

	
//  A lot of code
   
 
       case OIS::KC_8 :
	 myViewer->newInteraction();

      default:
        break;

    }

  myCameraMan->handleKeyPress ( evt );

  return true;

}
@endcode

Then add in the Viewer you method newInterraction.

And that's it !

\subsection DGtal_ModifyingStyles Modifing styles


Modifying the default styles:

You should modify the OgreStyle3DFactory class, for example DGtalSetBySTLSet paving default style. We Can modify the 4 illuinations and the default texture.
Here is the code you must change:

@code

  struct Ogre_DefaultDrawStylePaving_DigitalSetBySTLSet : public DrawableWithViewerOgre3D
  {
    virtual void setStyle(DGtal::ViewerOgre3D & Viewer) const
    {
            Viewer.setAmbientIlluminationColor(DGtal::Color(0,255,0,255));
	    Viewer.setSpecularIlluminationColor(DGtal::Color(0,255,0,255));
	    Viewer.setDiphuseIlluminationColor(DGtal::Color(0,255,0,255));
	    Viewer.setSelfIlluminationColor(DGtal::Color(0,255,0,255));
	    Viewer.setTexture("unselected.jpg");
    }
  };
@endcode

Note that the defaut texture must be in the Ressource/media folder.
	
*/

}


