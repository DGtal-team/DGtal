
/* 
 * Useful to avoid writing DGtal:: in front of every class.
 */
namespace DGtal {

/**
   
   @page dgtal_cellular_topology Cellular grid space and topology, cells, digital surfaces
   
   Documentation written by Jacques-Olivier Lachaud and Bertrand Kerautret.
  
   This part of the manual describes how to define cellular grid space
   or cartesian cubic spaces, as well as the main objects living in
   these spaces. A part of this documentation comes from project <a
   href="https://gforge.liris.cnrs.fr/projects/imagene">ImaGene</a>. A
   lot of the ideas, concepts, algorithms, and code is also a backport
   from <a
   href="https://gforge.liris.cnrs.fr/projects/imagene">ImaGene</a>.

   -# \ref dgtal_ctopo_sec1
      -# \ref dgtal_ctopo_sec1_1
      -# \ref dgtal_ctopo_sec1_2
      -# \ref dgtal_ctopo_sec1_3
      -# \ref dgtal_ctopo_sec1_4
      -# \ref dgtal_ctopo_sec1_5
      -# \ref dgtal_ctopo_sec1_6
      -# \ref dgtal_ctopo_sec1_7
      -# \ref dgtal_ctopo_sec1_8
      -# \ref dgtal_ctopo_sec1_9
      -# \ref dgtal_ctopo_sec1_10
      -# \ref dgtal_ctopo_sec1_11
   -# \ref dgtal_ctopo_sec2
      -# \ref dgtal_ctopo_sec2_1
      -# \ref dgtal_ctopo_sec2_2
      -# \ref dgtal_ctopo_sec2_3
      -# \ref dgtal_ctopo_sec2_4

   @section dgtal_ctopo_sec1 The digital space is a cubic grid

   @subsection dgtal_ctopo_sec1_1 Images and digital spaces

   2D images are often seen as two dimensional arrays, where each cell
   is a pixel with some value (a gray level, a color). If
   \f$\mathbf{Z}\f$ is the set of integer numbers, then an image is a
   map from a rectangular subset of \f$\mathbf{Z} \times \mathbf{Z}\f$
   to some space (gray levels, colors).

   More generally, a nD image is a map from a parallelepipedic subset of
   \f$\mathbf{Z}^n\f$ to some space (gray levels, colors).

   Many algorithms need to represent positions in images (ie pixels
   and voxels), in order to represent regions in images. Often, we
   need also to measure the shape of a region, for instance its
   perimeter, or we may be interested in the interface between two
   regions. In these cases, it is often convenient (and generally it
   is also the theoretic way) to represent other elements in digital
   spaces, such as paths in-between regions, the thin boundary or
   surface of a region, etc. We need in this case to represent not
   only the "squares" (pixels) or "cubes" (voxels) of images, but also
   their faces, edges, vertices.

   We therefore model not only n-dimensional cells (the hypercubes in
   nD), but also all the lower dimensional cells of the space. For
   instance, in 2D, we have:

   - 2-dimensional cells (closed unit square) = pixels
   - 1-dimensional cells (closed unit segment) = linels
   - 0-dimensional cells (closed point) = pointels

   The set of all cells \f$\mathbf{F}^n\f$ is called the n-dimensional
   space of cubical complexes, or n-dimensional cellular grid
   space. The couple \f$(\mathbf{F}^n,\subseteq)\f$ is a partially
   ordered set or poset. Let \f$X\f$ be any subset of
   \f$\mathbf{F}^n\f$. The set \f$\mathcal{U}=\{U \subseteq X / \forall
   x \in U, x^{\uparrow} \subseteq U \}\f$, where \f$x^{\uparrow}=\{y \in
   X, x \le y\}\f$ or the up incident cells of x, is a topology on
   \f$X\f$, called the Aleksandrov topology. Therefore we can use
   standard combinatorial topology results for any subset of the
   cellular grid space.

   Cells of the cellular grid space are illustrated below. The paving
   mode of digital space gives a nice illustration of what is this
   space. The 2-cell is in red, the 1-cell in green, the 0-cell in blue.
   
   @image html cellular-grid-space-1.png "Illustration of a cellular grid space with cells of different dimensions."
   @image latex cellular-grid-space-1.png "Illustration of a cellular grid space with cells of different dimensions." width=0.4\textwidth


   @subsection dgtal_ctopo_sec1_2 Cells in the cubical grid and Khalimsky coordinates
 
   We use now the regularity of the cubical grid to represent it
   efficiently. In 1D, the cubical grid is a simple line alternating
   closed points {k} and open unit segments (k,k+1). Khalimsky noticed
   that this (topological) space is homeomorphic to the integer set
   \f$\mathbf{Z}\f$, if we declare every even integer as closed and
   every odd integer as open.

   A digital cell in 1D is thus just an integer. Its topology is defined
   by its parity. The cell 2k is the closed point {k}; the cell 2k+1 is
   the segment (k,k+1) (considered open).

   In 2D, we use the fact that \f$\mathbf{Z}^2\f$ is a cartesian
   product. A digital cell in 2D is thus a couple of integer

   - (2i, 2j): a pointel which is the point set {(i,j)} in the plane

   - (2i+1, 2j): an horizontal linel which is the open segment
     {(i,i+1) x j} in the plane.

   - (2i, 2j+1): a vertical linel which is the open segment {i x
     (j,j+1)} in the plane.

   - (2i+1, 2j+1): a pixel which is the open square {(i,i+1) x
     (j,j+1)} in the plane.

   In nD, the principle is the same. A cell is thus uniquely identifed by
   an n-tuple of integers whose parities define the topology of the
   cell. These integers are called the @b Khalimsky @b coordinates of the
   cell.

   For instance, the pixel (x,y) of the digital space
   \f$\mathbf{Z}^2\f$ corresponds to the 2-cell (2x+1,2y+1) of the
   cellular grid space \f$\mathbf{F}^2\f$.

   @subsection dgtal_ctopo_sec1_3 Models for cellular grid spaces 

   Instead of chosing a specific implementation of a cellular grid
   space, we keep the genericity and efficiency objective of DGtal by
   defining a cellular grid space as the concept
   CCellularGridSpaceND. It provides a set of types (Cell, SCell, etc)
   and methods to manipulate cells of arbitrary dimension. Models of
   CCellularGridSpaceND are:

   -# the KhalimskySpaceND template class.
   -# the --- yet to come --- CodedKhalimskySpaceND class, a backport
   from class KnSpace of <a
   href="http://gforge.liris.cnrs.fr/projects/imagene">ImaGene</a>.

   The inner types are:
   - Integer: the type for representing a coordinate or component in this space.
   - Size: the type for representing a size (unsigned) 
   - Cell: the type of unsigned cells
   - SCell: the type of signed cells
   - Sign: the sign type for cells
   - DirIterator: the type for iterating over directions of a cell
   - Point: the type for representing a digital point in this space
   - Vector: the type for representing a digital vector in this space
   - Space: the associated digital space type
   - KhalimskySpace: this cellular grid space
   - Cells: a sequence of unsigned cells
   - SCells: a sequence of signed cells
   
   Methods include:
   - Cell creation services
   - Read accessors to cells
   - Write accessors to cells 
   - Conversion signed/unsigned cells
   - Cell topology services
   - Direction iterator services for cells
   - Unsigned cell geometry services
   - Signed cell geometry services
   - Neighborhood services
   - Incidence services
   - Interface

   @subsection dgtal_ctopo_sec1_4 Creating a cellular grid space

   We use hereafter the model KhalimskySpaceND. To create a 2D
   cellular grid space where cells have coordinates coded with
   standard \c int (32 bits generally), we can write:
   
   @code
   #include "DGtal/topology/KhalimskySpaceND.h"
   ...
   typedef KhalimskySpaceND< 2, int > KSpace;
   KSpace K;
   Point low( -3, -4 );
   Point high( 5, 3 ); 
   // true for closed space, false for open space.
   bool space_ok = K.init( low, high, true );
   @endcode

   Note that the cellular grid space is limited by the given
   bounds. Since the user has chosen a closed space, the Khalimsky
   coordinates of cells are bounded by:
   
   - lower bound: (-3*2, -4*2)
   - upper bound: (5*2+2, 3*2+2)

   Another frequent way of constructing a cellular grid space is to
   start from a preexisting digital space and HyperRectDomain. You can
   define the associated cellular grid space as follows:

   @code
   ...
   typedef SpaceND<3, int> Z;
   typedef HyperRectDomain<Z> Domain;
   ...
   Domain domain( a, b );
   ...
   typedef KhalimskySpaceND< Z::dimension, Z::Integer > KSpace;
   KSpace K;
   bool space_ok = K.init( domain.lowerBound(), domain.upperBound(), true );
   @endcode

   If you wish to build a digital space and a HyperRectDomain from a
   cellular grid space K, you may write:

   @code
   ...
   typedef SpaceND<KSpace::dimension, KSpace::Integer> Z;
   typedef HyperRectDomain<Z> Domain;
   Domain domain( K.lowerBound(), K.upperBound() );
   @endcode

   Last but not least, for standard users it is generally enough to
   use the default types provided in "DGtal/helpers/StdDefs.h".
   @code
   #include "DGtal/helpers/StdDefs.h"
   ...
   using namespace Z2i;
   KSpace K; // or K2 K;
   ...
   @endcode


   @subsection dgtal_ctopo_sec1_5 Creating (unsigned) cells in a cellular grid space

   There are many ways of creating cells within a cellular grid
   space. The simplest way is certainly to give the Khalimsky
   coordinates of the cell you wish to create. Its topology is then
   induced by its coordinates. We use generally
   KhalimskySpaceND::uCell for arbitrary cells,
   KhalimskySpaceND::uSpel for n-dimensional cells,
   KhalimskySpaceND::uPointel for 0-dimensional cells.

   The full code of this example is in file <a
   href="ctopo-1_8cpp-example.html" > ctopo-1.cpp</a>. Pointels or
   0-cells are displayed in blue, linels or 1-cells in green, pixels
   or 2-cells in red. Note that KhalimskySpaceND::uCell requires
   Khalimsky coordinates while the two others require digital
   coordinates (the topology is known in the two latter cases).

   @code
  KSpace K;
  Point plow(-3,-2);
  Point pup(5,3);
  K.init( plow, pup, true );
  Cell pixlow = K.uSpel( plow ); // pixel (-3*2+1,-2*2+1)
  Cell ptlow = K.uPointel( plow ); // pointel (-3*2,-2*2)
  Cell pixup = K.uSpel( pup ); // pixel (5*2+1,3*2+1)
  Cell ptup1 = K.uPointel( pup );   // pointel (5*2,3*2)
  Cell ptup2 = K.uTranslation( ptup1, Point::diagonal() ); // pointel (6*2,4*2)
  Cell linelb = K.uCell( Point( 1, 0 ) ); // linel (1,0) bottom
  Cell linelt = K.uCell( Point( 1, 2 ) ); // linel (1,2) top
  Cell linell = K.uCell( Point( 0, 1 ) ); // linel (0,1) left
  Cell linelr = K.uCell( Point( 2, 1 ) ); // linel (2,1) right
   @endcode

   @image html ctopo-1.png "Displaying some cells in different colors."
   @image latex ctopo-1.png "Displaying some cells in different colors." width=0.5\textwidth
   

   The file <a href="ctopo-1-3d_8cpp-example.html" >
   ctopo-1-3d.cpp</a> shows another example in 3D:


@code 
  KSpace K;
  Point plow(0,0,0);  
  Point pup(3,3,2);
  ...
  Cell ptlow = K.uPointel( plow ); // pointel (0*2,0*2, 0*2)
  Cell ptup1 = K.uPointel( pup ); // pointel (3*2,3*2, 2*2)
  Cell ptup2 = K.uTranslation( ptup1, Point::diagonal() ); // pointel (4*2, 4*2, 3*2)

  viewer << ptlow << ptup1 << ptup2; 
  Cell linel0 = K.uCell( Point( 1, 0, 2 ) ); // linel (2, 0, 2)
  viewer << linel0; // ...
  Cell surfelA = K.uCell( Point( 2, 1, 3 ) ); // surfel (2,1,3)
  viewer << surfelA; //...
  Cell vox1 = K.uCell( Point( 3, 3, 3 ) ); // voxel (3,3,3)
  viewer << vox1;
@endcode 
 
  @image html ctopo-1-3d.png  "Displaying some cells in different colors."
  @image latex ctopo-1-3d.png  "Displaying some cells in different colors." width=0.5\textwidth


 

   @subsection dgtal_ctopo_sec1_6 Cells may be unsigned or signed

   Up to now, we have only consider unsigned cells (type
   Cell). However it is often convenient to assign a sign (POS or NEG)
   to a cell, a kind of orientation. The sign is especially useful to
   define boundary operators and digital surfaces. It is also used in
   algebraic topological models of cubical complexes, for instance to
   define chains (formal sums of cells). 

   Signed cells have type SCell. They are created using methods
   KhalimskySpaceND::sCell for arbitrary cells,
   KhalimskySpaceND::sSpel for n-dimensional cells,
   KhalimskySpaceND::sPointel for 0-dimensional cells. The user gives
   the sign at creation, either K.POS or K.NEG if K is the space.
   
   You may use methods KhalimskySpaceND::sSign,
   KhalimskySpaceND::sSetSign KhalimskySpaceND::signs,
   KhalimskySpaceND::unsigns, KhalimskySpaceND::sOpp, respectively to
   get the sign of a signed cell, to change the sign of a signed cell,
   to sign an unsigned cell, to unsign a signed cell, and to compute
   the cell with opposite sign.

   All methods concerning unsigned cells are prefixed by \c u, all
   methods concerning signed cells are prefixed by \c s.
 
 
 Note that the sign of the signed and unsigned are well taked into
  account in the display with \Ref Viewer3D .


  <CENTER>
   @image html ctopo-1b-3d.png "Visualisation of unsigned Cell"
   @image latex ctopo-1b-3d.png "Visualisation of unsigned Cell" width=0.4\textwidth
   @image html ctopo-1s-3d.png "Visualisation of signed Cell"
   @image latex ctopo-1s-3d.png "Visualisation of signed Cell" width=0.4\textwidth
  </CENTER>




   @subsection dgtal_ctopo_sec1_7 Accessing and modifying cell coordinates.

   Since one does not necessarily know which model of
   CCellularGridSpaceND you may be using, you cannot access the cell
   coordinates directly. Therefore a model of CCellularGridSpaceND
   provides a set of methods to access and modify cell coordinates and
   topology. Here a few of them (with the model example KhalimskySpaceND)

   - Read accessors to coordinate(s)
     - KhalimskySpaceND::uKCoord, KhalimskySpaceND::sKCoord (read Khalimsky coordinate)
     - KhalimskySpaceND::uCoord, KhalimskySpaceND::sCoord (read digital coordinate)
     - KhalimskySpaceND::uKCoords, KhalimskySpaceND::sKCoords (read Khalimsky coordinates)
     - KhalimskySpaceND::uCoords, KhalimskySpaceND::sCoords (read digital coordinates)
   - Write accessors to coordinate(s)
     - KhalimskySpaceND::uSetKCoord, KhalimskySpaceND::sSetKCoord (write Khalimsky coordinate)
     - KhalimskySpaceND::uSetCoord, KhalimskySpaceND::sSetCoord (write digital coordinate)
     - KhalimskySpaceND::uSetKCoords, KhalimskySpaceND::sSetKCoords (write Khalimsky coordinates)
     - KhalimskySpaceND::uSetCoords, KhalimskySpaceND::sSetCoords (write digital coordinates)

   @subsection dgtal_ctopo_sec1_8 Moving within the cellular grid space

   Note that you dispose also of a whole set of methods to determine
   cells according to different geometric queries. The following
   methods do not change the topology of the input cell only the
   coordiantes. Again the prefix \c u is related to method taking as
   input unsigned cells while the prefix \c s is related to signed
   cells:

   - Getting the first or last cell of the space:
     KhalimskySpaceND::uFirst, KhalimskySpaceND::uLast,
     KhalimskySpaceND::sFirst, KhalimskySpaceND::sLast

   - Moving to the adjacent cell with one coordinate greater or one
     coordinate lower: KhalimskySpaceND::uGetIncr,
     KhalimskySpaceND::uGetDecr, KhalimskySpaceND::sGetIncr,
     KhalimskySpaceND::sGetDecr, or moving to an arbitrary cell along
     some axis with KhalimskySpaceND::uGetAdd and
     KhalimskySpaceND::uGetSub, KhalimskySpaceND::sGetAdd and
     KhalimskySpaceND::sGetSub.

   - Testing whether you are the cell with maximal or minimal
     coordinate along some axis with KhalimskySpaceND::uIsMax or
     KhalimskySpaceND::uIsMin, KhalimskySpaceND::sIsMax or
     KhalimskySpaceND::sIsMin

   - Getting the cell along some axis that has same coordinates as the
     input cell but for one which belongs the minimal or maximal
     accepted in this space: KhalimskySpaceND::uGetMax and
     KhalimskySpaceND::uGetMin, KhalimskySpaceND::sGetMax and
     KhalimskySpaceND::sGetMin

   - Projet a cell along some coordinate onto the axis-aligned
     hyperplanes spanned by a cell with KhalimskySpaceND::uProject and
     KhalimskySpaceND::uProjection, KhalimskySpaceND::sProject and
     KhalimskySpaceND::sProjection

   - Computes the distance of the cell to the bounds of the space
     along some axis with KhalimskySpaceND::uDistanceToMax and
     KhalimskySpaceND::uDistanceToMin, KhalimskySpaceND::sDistanceToMax and
     KhalimskySpaceND::sDistanceToMin

   - Getting the next cell in this space such that if one starts from
     the first cell (with same topology) of the space and iterates
     this process, then all cells of the space with same topology were
     visited. This may be done with KhalimskySpaceND::uNext,
     KhalimskySpaceND::sNext. Below is a code snippet that does a
     scanning of all cells of same topology between first and last
     cell.

       \code
       KSpace K;
       Cell first, last; // lower and upper bounds 
       Cell p = first;
       do 
       { // ... whatever [p] is the current cell
       }
       while ( K.uNext( p, first, last ) ); 
       \endcode

     For instance (see.  <a
     href="khalimskySpaceScanner_8cpp-example.html">
     khalimskySpaceScanner.cpp </a> ) you will obtain the default following scan:
          
      @image html khalimskySpaceScanner1.png "Sequence of visited pixels in a scan of Khalimsky Space (standard scan order)."
      @image latex khalimskySpaceScanner1.png "Sequence of visited pixels in a scan of Khalimsky Space (standard scan order)." width=0.4\textwidth
   
   - The scan can also be done by explicitly controll the order:
   @code
   KSpace::Cell q;

   ...
   for (q = K.uGetMaxT(q, 0); K.uIsInside(q,0); q = K.uGetDecr(q, 0))
  	for ( q = K.uGetMinT(q, 1); K.uIsInside(q,1); q = K.uGetIncr(q, 1)){
   	 // ... whatever [q] is the current cell
		
	}		
   @endcode
   You will obtain the following scan:

    @image html khalimskySpaceScanner2.png "Sequence of visited pixels in a scan of Khalimsky Space (other scan order)."
    @image latex khalimskySpaceScanner2.png "Sequence of visited pixels in a scan of Khalimsky Space (other scan order)." width=0.4\textwidth
  


   - Translating arbitrarily a cell in the space with
     KhalimskySpaceND::uTranslation and
     KhalimskySpaceND::sTranslation.

   @subsection dgtal_ctopo_sec1_9 Cell topology and directions

   As said above, the cell topology is defined by the parity of its
   Khalimsky coordinates. The number of coordinates where the cell is
   open define the dimension of the cell. A cell of maximal dimension
   (n) is called a \e pixel in 2D, a \e voxel in 3D, and sometimes
   called a \e spel or \e xel in nD. A cell of minimial dimension (0)
   is often called a \e pointel. n-1 cells are called \e surfels (or
   sometimes \e linels in 2D). Here are the methods related to the
   cell topology.

   - the dimension of a cell is given by KhalimskySpaceND::uDim and
     KhalimskySpaceND::sDim.

   - whether a cell is open or not along some axis is returned by
     KhalimskySpaceND::uIsOpen and KhalimskySpaceND::sIsOpen.

   - whether a cell is a surfel or not is returned by
     KhalimskySpaceND::uIsSurfel and KhalimskySpaceND::sIsSurfel. NB:
     you should use it instead of comparing the dimension of the cell
     with n-1, depending on the model of cellular grid space chosen.

   - the integer coding the topology of the cell such that the k-th
     bit is 1 whenever the cell is open along the k-th axis is
     returned by KhalimskySpaceND::uTopology and
     KhalimskySpaceND::sTopology.

   - you may iterate over all open coordinates (or all closed
     coordinates) of a cell with the iterator returned by
     KhalimskySpaceND::uDirs and KhalimskySpaceND::sDirs
     (KhalimskySpaceND::uOrthDirs and KhalimskySpaceND::sOrthDirs for
     closed coordinates), such as in this snippet:

     @code
     KSpace::Cell p;
     ...
     for ( KnSpace::DirIterator q = ks.uDirs( p ); q != 0; ++q ) 
     { 
        KSpace::Dimension dir = *q;
	...
     } 
     @endcode

   @subsection dgtal_ctopo_sec1_10 Cell adjacency and neighborhood

   You may obtain the cells of same topology which are (face-)adjacent
   to a given cell with the following methods:

   - the neighborhood of a given cell within the space are given by
     KhalimskySpaceND::uNeighborhood and
     KhalimskySpaceND::sNeighborhood, while the proper neighborhood is
     returned by KhalimskySpaceND::uProperNeighborhood and
     KhalimskySpaceND::sProperNeighborhood.

   - the cell that is adjacent forward or backward along some given
     axis is returned by KhalimskySpaceND::uAdjacent and
     KhalimskySpaceND::sAdjacent. 

   @subsection dgtal_ctopo_sec1_11 Cell incidence

   Cells incident to some cell touch the cell but do not have the same
   dimension. Cells lower incident to a cell have lower dimensions,
   cells upper incident to a cell have higher dimensions. Specific
   rules determine the sign of incident cells to a signed cell: 

   -# A first rule is that along some axis, the forward and the
      backward incident cell have opposite sign.

   -# A second rule is that the rules are invariant by translation of
      cells.

   -# A third rule is that changing the sign of the cell changes the
      sign of all incident cells.

   -# A last rule is that taking an incident cell along some axis k
      then taking an incident cell along some other axis l will give a
      cell that has the opposite sign as if the incidence was taken
      before along l and after along k.

   These rules together allow the definition of (co)boundary
   operators, which are homomorphisms between chains of cells. They
   have the property that applied twice they give the null
   chain. Otherwise said, the boundary of a set of cells has an empty
   boundary.

   - The cell incident to some given cell along some axis and in
     forward or backward direction is returned by
     KhalimskySpaceND::uIncident and KhalimskySpaceND::sIncident.

     @code
     SCell pix = K.sSpel( Point( 0,0 ), K.POS ); // pixel (0+1,0+1)
     SCell leftl = K.sIncident( pix, 0, false ); // linel (0,0+1)
     SCell rightl = K.sIncident( pix, 0, true ); // linel (2,0+1)
     SCell downl = K.sIncident( pix, 1, false ); // linel (0+1,0)
     SCell upl = K.sIncident( pix, 1, true );    // linel (0+1,2)
     SCell ptld = K.sIncident( leftl, 1, false );// pointel (0,0)
     SCell ptdl = K.sIncident( downl, 0, false );// pointel (0,0)
     // ptld and ptdl have opposite signs.
     @endcode
  
   - The set of cells low incident to a given cell (i.e. just 1
     dimension less) is returned by
     KhalimskySpaceND::uLowerIncident and
     KhalimskySpaceND::sLowerIncident.

   - The set of cells up incident to a given cell (i.e. just 1
     dimension more) is returned by
     KhalimskySpaceND::uUpperIncident and
     KhalimskySpaceND::sUpperIncident.

   - The proper faces of an unsigned cell are returned by
     KhalimskySpaceND::uFaces.

   - The proper cofaces of an unsigned cell are returned by
     KhalimskySpaceND::uCoFaces.

   - One of the two cells that are incident to some signed cells along
     some axis has a positive sign. The orientation (forward or
     backward) is called the \e direct orientation. It is returned by
     KhalimskySpaceND::sDirect. It is worth to note that the following
     assertion is always true:

     @code
     // c is a signed cell, k a direction
     ASSERT( K.sSign( K.sIncident( c, k, K.sDirect( c, k ) ) ) == K.POS );
     @endcode

   - You may obtain straightforwardly the positive incident cell along
     some axis with KhalimskySpaceND::sDirectIncident and the negative
     incident cell along some axis with
     KhalimskySpaceND::sIndirectIncident.

   @section dgtal_ctopo_sec2 Surfel adjacency and digital surfaces

   The preceding definitions of signed cells and their incidence will
   help us to define consistently what is a digital surface and how to
   move over it.

   

   @subsection dgtal_ctopo_sec2_1 Tracking Boundary
   


   @subsection dgtal_ctopo_sec2_2 Tracking 2D Boundary

   The surfaces classes offers the possibility to extract an open or
   closed contour as a sequence of surfels obtained from a DigitalSet
   and a starting surfel. The full code of this example is available in file <a href="ctopo-2_8cpp-example.html">ctopo-2.cpp </a>. 
   

   The first step to extract the surfel boudary of a 2D digital set is
   to obtain an initial boundary surfel:
   @code 
      aCell = Surfaces<Z2i::KSpace>::findABel(ks, set2d);	
   @endcode

   The first surfel can also be displayed in red with Board2D:      
   @code  
       Board2D board;
       board << image.domain() << set2d; // display domain and set
       board << CustomStyle( aCell.styleName(), new CustomColors(  Board2D::Color( 255, 0, 0 ),
       							           Board2D::Color( 192, 0, 0 ) ));
       board << aCell;
    @endcode  

   @image html ctopo2a.png "Start surfel before a tracking (in red)."
   @image latex ctopo2a.png "Start surfel before a tracking (in red)." width=0.5\textwidth

    
    Then you can extract the sequence of consecutive surfels:
    @code 
     std::vector<Z2i::SCell> vectBdrySCell;
     SurfelAdjacency<2> SAdj( true );
     Surfaces<Z2i::KSpace>::track2DBoundary( vectBdrySCell,
	   				     ks, SAdj, set2d, aCell );
    @endcode
    and display it:
    @code
     GradientColorMap<int> cmap_grad( 0, vectBdrySCell.size() );
     cmap_grad.addColor( Board2D::Color( 50, 50, 255 ) );
     cmap_grad.addColor( Board2D::Color( 255, 0, 0 ) );
     cmap_grad.addColor( Board2D::Color( 255, 255, 10 ) );
   
     unsigned int d=0;
     std::vector<Z2i::SCell>::iterator it;
     for ( it=vectBdrySCell.begin() ; it != vectBdrySCell.end(); it++ ){
     	  board<< CustomStyle((*it).styleName() ,
	           	      new CustomColors( Board2D::Color::Black,
				                cmap_grad( d )))<< *it;
          d++;
    }
   @endcode	
   You will obtain the following ordered sequence of surfels: 

   @image html ctopo2b.png "Tracking of a closed 2D contour."
   @image latex ctopo2b.png "Tracking of a closed 2D contour." width=0.5\textwidth


   The resulting sequence of surfels does not necessary present an
   open contour (try for instance image "samples/circleR10modif.pgm"):

   @image html ctopo2c.png  "Tracking of an open 2D contour."
   @image latex ctopo2c.png  "Tracking of an open 2D contour." width=0.5\textwidth
   


   @subsection dgtal_ctopo_sec2_3 Tracking 3D Boundary

   With only few modifications we can apply the same extraction on 3D
   surfel set. The file <a
   href="ctopo-2-3d_8cpp-example.html">ctopo-2-3d.cpp </a> shows the
   same previous example adapted in 3D.
  
   with the same code we can get a surfel boundary:
   @code
   Z3i::SCell aCell = Surfaces<Z3i::KSpace>::findABel(ks, set3d);
   @endcode
   
   From this SCell all the surfel connected sets can be extracted:
   @code
   // Extracting all boundary surfels which are connected to the initial boundary Cell.
   Surfaces<Z3i::KSpace>::trackBoundary( vectBdrySCellALL,
                                         ks,SAdj, set3d, aCell );
   @endcode

   To see both initial surfel and the surfel set, we can use the transparent mode:

   @code
   viewer << SetMode3D((*(vectBdrySCellALL.begin())).styleName(), "Transparent");
   @endcode
   	
   To avoid surfel superposition we need to increase with a small
   shift the surfel size, for this purpose you can add the following key:
   @code 
   viewer << Viewer3D::shiftSurfelVisu; 
   @endcode
   or use the special mode "Highlighted" which increase automaticly the surfel size.

   You can obtain for instance the following visualisation:
   
   @image html ctopo3dSurfel.png "Tracking surfaces in 3D (start surfel in green)."
   @image latex ctopo3dSurfel.png "Tracking surfaces in 3D (start surfel in green)." width=0.5\textwidth
   
   Since in 3D there are several choice for the direction used to
   exctract surfel boundary, we can specify the constant direction
   need to drive the surfel extraction:

   @code
   // Extract the boundary contour associated to the initial surfel in its first direction
    Surfaces<Z3i::KSpace>::track2DBoundary( vectBdrySCell,
 	    				    ks, *(ks.sDirs( aCell )),SAdj, set3d, aCell );
   @endcode  					    
   
   After extracting the two surfels cut you may obtain the following visualisation:
   
   @image html ctopo3dSurfelCut.png "Tracking surfaces and slices in 3D (start surfel in green)."
   @image latex ctopo3dSurfelCut.png "Tracking surfaces and slices in 3D (start surfel in green)." width=0.5\textwidth
   





   @subsection dgtal_ctopo_sec2_4 Extracting SCell connected boundary surfels

   The class \ref Surfaces shows other usefull function to extract
   connected boundary surfels from a digital set and given a surfel
   adjacency definition. The example <a
   href="3dKSSurfaceExtraction_8cpp-example.html" >
   3dKSSurfaceExtraction.cpp </a> shows an example of such an extraction.

   From a domain we construct a DigitalSet inserting points under given conditions (see.  <a
   href="3dKSSurfaceExtraction_8cpp-example.html" >
   3dKSSurfaceExtraction.cpp </a> for more details)

@code
#include "DGtal/helpers/Surfaces.h"
#include "DGtal/topology/KhalimskySpaceND.h"
...
Domain domain( p1, p2);
DigitalSet diamond_set( domain );
...
  diamond_set.insertNew( *it );
....
@endcode 
   
With this domain bounding points (p1, p2), a KhalimskySpace is
  constructed and a SurfelAdjacency definition is introduced.

@code 
 KSpace K;
 K.init(p1, p2, true);
 SurfelAdjacency<3> SAdj( true );
@endcode 



Then we can extract all connected surfels from the digitalSet surface :

@code 
  SetPredicate<DigitalSet> shape_set_predicate( diamond_set );
  Surfaces<KSpace>::extractAllConnectedSCell(vectConnectedSCell,K, SAdj, shape_set_predicate);
@endcode


After processing a simple display of each resulting connecting component you can obtain such a visualisation:


<center>
@image html KSurfelsConnectedOrientExt.png "Visualisation of connected set of SignefKhalimskySpaceND"
@image latex KSurfelsConnectedOrientExt.png "Visualisation of connected set of SignefKhalimskySpaceND" width=0.5\textwidth
</center>


Here since the last argument is set to true, the resulting
SignedKhalimskySpaceND are signed in order to indicate the direction
of exterior. You can also get the SignefKhalimskySpaceND with default
sign:


@code 
  Surfaces<KSpace>::extractAllConnectedSCell(vectConnectedSCell,K, SAdj, shape_set_predicate, false);
@endcode


and you will get the resulting cell display:



<center>
@image html KSurfelsConnectedDefaultOrient.png "Visualisation of connected set of SignefKhalimskySpaceND"
@image latex KSurfelsConnectedDefaultOrient.png "Visualisation of connected set of SignefKhalimskySpaceND" width=0.5\textwidth
</center>





*/




/**
\example ctopo-1.cpp
*A simple example of cellular grid space with several cells
*instantiated and visualized. This program outputs this image.
*   @image html ctopo-1.png
*
*/


/**
\example ctopo-1-3d.cpp
*A simple example of cellular grid space with several cells
*instantiated and visualized in 3D. This program outputs this image.
*   @image html ctopo-1b-3d.png
*
*/


/**
\example ctopo-1s-3d.cpp
*A simple example of cellular grid space with several cells
*instantiated and visualized in 3D. This program outputs this image.
*   @image html ctopo-1s-3d.png
*
*/



/**
\example ctopo-2.cpp
* A simple example illustrating the extraction of the sequence of surfels boudary. This program outputs this image.
*
*   @image html ctopo2c.png 
*/



/**
\example ctopo-2-3d.cpp
* A simple example illustrating the extraction of the sequence of surfels boudary. This program outputs this image.
*
*   @image html ctopo3dSurfelCut.png 
*/

/**
\example khalimskySpaceScanner.cpp
*
* A simple example illustrating different way to scan a Khalimsky space. This program outputs these images:
 *<table> 
*<TR>
*<td> @image html khalimskySpaceScanner1.png </td>
*<td> @image html khalimskySpaceScanner2.png </td>
*</TR>
*</TABLE>
*/

}





/**
* A simple example illustrating the extraction of 3d connected set of KhalimskyCell. This program outputs these images: 
*   @image html KSurfelsConnectedOrientExt.png 
* \example  3dKSSurfaceExtraction.cpp
*/
